From: csagan5 <32685696+csagan5@users.noreply.github.com>
Date: Mon, 11 Dec 2017 22:42:11 +0100
Subject: Add search engine

Add a Google search engine that forces languages to English,
disable from all its searches RLZ and field experiments querystring parameters.
Add DuckDuckGo Lite

License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
---
 .../browser/ui/RootUiCoordinator.java.porig   | 2053 +++++++++++++++++
 .../search_engine_choice/default_favicon.png  |  Bin 0 -> 903 bytes
 ...search_engine_choice_scaled_resources.grdp |    1 +
 components/search_engines/BUILD.gn            |    3 +
 components/search_engines/cromite/BUILD.gn    |   12 +
 .../cromite/cromite_prepopulated_engines.json |   37 +
 .../search_engine_choice_utils.cc             |    5 +-
 .../search_engines/search_engine_type.h       |    5 +
 .../template_url_prepopulate_data.cc          |   15 +-
 .../template_url_prepopulate_data.h           |    7 -
 tools/json_to_struct/json_to_struct.gni       |    9 +
 tools/json_to_struct/json_to_struct.py        |   26 +-
 tools/json_to_struct/struct_generator.py      |   10 +-
 tools/variations/fieldtrial_to_struct.py      |    4 +-
 14 files changed, 2161 insertions(+), 26 deletions(-)
 create mode 100644 chrome/android/java/src/org/chromium/chrome/browser/ui/RootUiCoordinator.java.porig
 create mode 100644 components/resources/default_100_percent/search_engine_choice/default_favicon.png
 create mode 100644 components/search_engines/cromite/BUILD.gn
 create mode 100644 components/search_engines/cromite/cromite_prepopulated_engines.json

diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ui/RootUiCoordinator.java.porig b/chrome/android/java/src/org/chromium/chrome/browser/ui/RootUiCoordinator.java.porig
new file mode 100644
--- /dev/null
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ui/RootUiCoordinator.java.porig
@@ -0,0 +1,2053 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.ui;
+
+import android.app.Fragment;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.text.TextUtils;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+
+import androidx.annotation.CallSuper;
+import androidx.annotation.ColorInt;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.appcompat.app.AppCompatActivity;
+
+import org.chromium.base.BuildInfo;
+import org.chromium.base.Callback;
+import org.chromium.base.CallbackController;
+import org.chromium.base.TraceEvent;
+import org.chromium.base.lifetime.Destroyable;
+import org.chromium.base.metrics.RecordUserAction;
+import org.chromium.base.supplier.ObservableSupplier;
+import org.chromium.base.supplier.ObservableSupplierImpl;
+import org.chromium.base.supplier.OneShotCallback;
+import org.chromium.base.supplier.OneshotSupplier;
+import org.chromium.base.supplier.OneshotSupplierImpl;
+import org.chromium.base.supplier.Supplier;
+import org.chromium.base.supplier.UnownedUserDataSupplier;
+import org.chromium.chrome.R;
+import org.chromium.chrome.browser.ActivityTabProvider;
+import org.chromium.chrome.browser.ActivityUtils;
+import org.chromium.chrome.browser.ChromeActionModeHandler;
+import org.chromium.chrome.browser.IntentHandler;
+import org.chromium.chrome.browser.app.tabmodel.ArchivedTabModelOrchestrator;
+import org.chromium.chrome.browser.automotivetoolbar.AutomotiveBackButtonToolbarCoordinator;
+import org.chromium.chrome.browser.back_press.BackPressManager;
+import org.chromium.chrome.browser.bookmarks.BookmarkModel;
+import org.chromium.chrome.browser.bookmarks.TabBookmarker;
+import org.chromium.chrome.browser.browser_controls.BottomControlsStacker;
+import org.chromium.chrome.browser.browser_controls.BrowserControlsStateProvider;
+import org.chromium.chrome.browser.browserservices.intents.WebappConstants;
+import org.chromium.chrome.browser.commerce.ShoppingServiceFactory;
+import org.chromium.chrome.browser.compositor.CompositorViewHolder;
+import org.chromium.chrome.browser.compositor.bottombar.OverlayPanel;
+import org.chromium.chrome.browser.compositor.bottombar.OverlayPanelManager;
+import org.chromium.chrome.browser.compositor.layouts.LayoutManagerImpl;
+import org.chromium.chrome.browser.contextualsearch.ContextualSearchManager;
+import org.chromium.chrome.browser.contextualsearch.ContextualSearchManager.ContextualSearchTabPromotionDelegate;
+import org.chromium.chrome.browser.contextualsearch.ContextualSearchManagerSupplier;
+import org.chromium.chrome.browser.contextualsearch.ContextualSearchObserver;
+import org.chromium.chrome.browser.crash.ChromePureJavaExceptionReporter;
+import org.chromium.chrome.browser.data_sharing.DataSharingTabManager;
+import org.chromium.chrome.browser.device_lock.DeviceLockActivityLauncherImpl;
+import org.chromium.chrome.browser.document.ChromeLauncherActivity;
+import org.chromium.chrome.browser.download.DownloadMetrics.OpenWithExternalAppsSource;
+import org.chromium.chrome.browser.download.DownloadUtils;
+import org.chromium.chrome.browser.ephemeraltab.EphemeralTabCoordinator;
+import org.chromium.chrome.browser.feature_engagement.TrackerFactory;
+import org.chromium.chrome.browser.findinpage.FindToolbarManager;
+import org.chromium.chrome.browser.findinpage.FindToolbarObserver;
+import org.chromium.chrome.browser.flags.ActivityType;
+import org.chromium.chrome.browser.flags.ChromeFeatureList;
+import org.chromium.chrome.browser.fullscreen.BrowserControlsManager;
+import org.chromium.chrome.browser.fullscreen.FullscreenManager;
+import org.chromium.chrome.browser.image_descriptions.ImageDescriptionsController;
+import org.chromium.chrome.browser.incognito.reauth.IncognitoReauthController;
+import org.chromium.chrome.browser.incognito.reauth.IncognitoReauthControllerImpl;
+import org.chromium.chrome.browser.incognito.reauth.IncognitoReauthCoordinatorFactory;
+import org.chromium.chrome.browser.incognito.reauth.IncognitoReauthManager;
+import org.chromium.chrome.browser.layouts.LayoutManager;
+import org.chromium.chrome.browser.layouts.LayoutStateProvider;
+import org.chromium.chrome.browser.layouts.LayoutType;
+import org.chromium.chrome.browser.lifecycle.ActivityLifecycleDispatcher;
+import org.chromium.chrome.browser.lifecycle.DestroyObserver;
+import org.chromium.chrome.browser.lifecycle.InflationObserver;
+import org.chromium.chrome.browser.lifecycle.NativeInitObserver;
+import org.chromium.chrome.browser.lifecycle.WindowFocusChangedObserver;
+import org.chromium.chrome.browser.merchant_viewer.MerchantTrustMetrics;
+import org.chromium.chrome.browser.merchant_viewer.MerchantTrustSignalsCoordinator;
+import org.chromium.chrome.browser.messages.ChromeMessageAutodismissDurationProvider;
+import org.chromium.chrome.browser.messages.ChromeMessageQueueMediator;
+import org.chromium.chrome.browser.messages.MessageContainerCoordinator;
+import org.chromium.chrome.browser.messages.MessageContainerObserver;
+import org.chromium.chrome.browser.messages.MessagesResourceMapperInitializer;
+import org.chromium.chrome.browser.metrics.UmaSessionStats;
+import org.chromium.chrome.browser.omnibox.OmniboxFocusReason;
+import org.chromium.chrome.browser.omnibox.geo.GeolocationHeader;
+import org.chromium.chrome.browser.omnibox.suggestions.action.OmniboxActionDelegateImpl;
+import org.chromium.chrome.browser.omnibox.voice.VoiceRecognitionHandler;
+import org.chromium.chrome.browser.paint_preview.DemoPaintPreview;
+import org.chromium.chrome.browser.password_manager.ManagePasswordsReferrer;
+import org.chromium.chrome.browser.password_manager.PasswordManagerLauncher;
+import org.chromium.chrome.browser.pdf.PdfPage;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.quick_delete.QuickDeleteController;
+import org.chromium.chrome.browser.quick_delete.QuickDeleteDelegateImpl;
+import org.chromium.chrome.browser.readaloud.ReadAloudController;
+import org.chromium.chrome.browser.readaloud.ReadAloudControllerSupplier;
+import org.chromium.chrome.browser.recent_tabs.RestoreTabsFeatureHelper;
+import org.chromium.chrome.browser.search_engines.TemplateUrlServiceFactory;
+import org.chromium.chrome.browser.share.ShareDelegate;
+import org.chromium.chrome.browser.share.ShareDelegate.ShareOrigin;
+import org.chromium.chrome.browser.share.qrcode.QrCodeDialog;
+import org.chromium.chrome.browser.share.scroll_capture.ScrollCaptureManager;
+import org.chromium.chrome.browser.tab.AccessibilityVisibilityHandler;
+import org.chromium.chrome.browser.tab.AutofillSessionLifetimeController;
+import org.chromium.chrome.browser.tab.RequestDesktopUtils;
+import org.chromium.chrome.browser.tab.Tab;
+import org.chromium.chrome.browser.tab.TabLaunchType;
+import org.chromium.chrome.browser.tab.TabLoadIfNeededCaller;
+import org.chromium.chrome.browser.tab.TabObscuringHandler;
+import org.chromium.chrome.browser.tab.TabObscuringHandlerSupplier;
+import org.chromium.chrome.browser.tab_ui.RecyclerViewPosition;
+import org.chromium.chrome.browser.tab_ui.TabContentManager;
+import org.chromium.chrome.browser.tab_ui.TabSwitcher;
+import org.chromium.chrome.browser.tabmodel.TabCreator;
+import org.chromium.chrome.browser.tabmodel.TabCreatorManager;
+import org.chromium.chrome.browser.tabmodel.TabModelSelector;
+import org.chromium.chrome.browser.theme.TopUiThemeColorProvider;
+import org.chromium.chrome.browser.toolbar.ToolbarIntentMetadata;
+import org.chromium.chrome.browser.toolbar.ToolbarManager;
+import org.chromium.chrome.browser.toolbar.adaptive.AdaptiveToolbarBehavior;
+import org.chromium.chrome.browser.toolbar.top.ToolbarActionModeCallback;
+import org.chromium.chrome.browser.toolbar.top.ToolbarControlContainer;
+import org.chromium.chrome.browser.ui.activity_recreation.ActivityRecreationController;
+import org.chromium.chrome.browser.ui.appmenu.AppMenuBlocker;
+import org.chromium.chrome.browser.ui.appmenu.AppMenuCoordinator;
+import org.chromium.chrome.browser.ui.appmenu.AppMenuCoordinatorFactory;
+import org.chromium.chrome.browser.ui.appmenu.AppMenuDelegate;
+import org.chromium.chrome.browser.ui.appmenu.AppMenuHandler;
+import org.chromium.chrome.browser.ui.appmenu.AppMenuObserver;
+import org.chromium.chrome.browser.ui.edge_to_edge.EdgeToEdgeController;
+import org.chromium.chrome.browser.ui.edge_to_edge.EdgeToEdgeControllerFactory;
+import org.chromium.chrome.browser.ui.edge_to_edge.EdgeToEdgeUtils;
+import org.chromium.chrome.browser.ui.messages.snackbar.SnackbarManager;
+import org.chromium.chrome.browser.ui.native_page.NativePage;
+import org.chromium.chrome.browser.ui.system.StatusBarColorController;
+import org.chromium.chrome.browser.ui.system.StatusBarColorController.StatusBarColorProvider;
+import org.chromium.chrome.browser.wallet.BoardingPassController;
+import org.chromium.components.browser_ui.accessibility.PageZoomCoordinator;
+import org.chromium.components.browser_ui.accessibility.PageZoomCoordinatorDelegate;
+import org.chromium.components.browser_ui.bottomsheet.BottomSheetController;
+import org.chromium.components.browser_ui.bottomsheet.BottomSheetController.SheetState;
+import org.chromium.components.browser_ui.bottomsheet.BottomSheetControllerFactory;
+import org.chromium.components.browser_ui.bottomsheet.BottomSheetObserver;
+import org.chromium.components.browser_ui.bottomsheet.EmptyBottomSheetObserver;
+import org.chromium.components.browser_ui.bottomsheet.ExpandedSheetHelper;
+import org.chromium.components.browser_ui.bottomsheet.ManagedBottomSheetController;
+import org.chromium.components.browser_ui.desktop_windowing.DesktopWindowStateManager;
+import org.chromium.components.browser_ui.device_lock.DeviceLockActivityLauncher;
+import org.chromium.components.browser_ui.device_lock.DeviceLockActivityLauncherSupplier;
+import org.chromium.components.browser_ui.edge_to_edge.EdgeToEdgeManager;
+import org.chromium.components.browser_ui.util.ComposedBrowserControlsVisibilityDelegate;
+import org.chromium.components.browser_ui.widget.MenuOrKeyboardActionController;
+import org.chromium.components.browser_ui.widget.gesture.BackPressHandler;
+import org.chromium.components.browser_ui.widget.scrim.ScrimManager;
+import org.chromium.components.feature_engagement.EventConstants;
+import org.chromium.components.feature_engagement.Tracker;
+import org.chromium.components.messages.DismissReason;
+import org.chromium.components.messages.ManagedMessageDispatcher;
+import org.chromium.components.messages.MessageContainer;
+import org.chromium.components.messages.MessageDispatcherProvider;
+import org.chromium.components.messages.MessagesFactory;
+import org.chromium.components.ukm.UkmRecorder;
+import org.chromium.content_public.browser.ActionModeCallbackHelper;
+import org.chromium.content_public.browser.BrowserContextHandle;
+import org.chromium.content_public.browser.LoadUrlParams;
+import org.chromium.ui.base.ActivityWindowAndroid;
+import org.chromium.ui.base.DeviceFormFactor;
+import org.chromium.ui.base.IntentRequestTracker;
+import org.chromium.ui.base.MimeTypeUtils;
+import org.chromium.ui.base.PageTransition;
+import org.chromium.ui.display.DisplayAndroid;
+import org.chromium.ui.modaldialog.ModalDialogManager;
+import org.chromium.ui.modaldialog.ModalDialogManager.ModalDialogManagerObserver;
+import org.chromium.ui.modelutil.PropertyModel;
+import org.chromium.ui.widget.Toast;
+
+import java.util.function.BooleanSupplier;
+
+/**
+ * The root UI coordinator. This class will eventually be responsible for inflating and managing
+ * lifecycle of the main UI components.
+ *
+ * <p>The specific things this component will manage and how it will hook into Chrome*Activity are
+ * still being discussed See https://crbug.com/931496.
+ */
+public class RootUiCoordinator
+        implements DestroyObserver,
+                InflationObserver,
+                NativeInitObserver,
+                MenuOrKeyboardActionController.MenuOrKeyboardActionHandler,
+                AppMenuBlocker,
+                ContextualSearchTabPromotionDelegate,
+                WindowFocusChangedObserver {
+    protected final UnownedUserDataSupplier<TabObscuringHandler> mTabObscuringHandlerSupplier =
+            new TabObscuringHandlerSupplier();
+
+    private final UnownedUserDataSupplier<DeviceLockActivityLauncher>
+            mDeviceLockActivityLauncherSupplier = new DeviceLockActivityLauncherSupplier();
+
+    protected final UnownedUserDataSupplier<ContextualSearchManager>
+            mContextualSearchManagerSupplier = new ContextualSearchManagerSupplier();
+
+    protected final UnownedUserDataSupplier<ReadAloudController> mReadAloudControllerSupplier =
+            new ReadAloudControllerSupplier();
+
+    protected AppCompatActivity mActivity;
+    protected @Nullable AppMenuCoordinator mAppMenuCoordinator;
+    private final MenuOrKeyboardActionController mMenuOrKeyboardActionController;
+    protected final ActivityWindowAndroid mWindowAndroid;
+
+    protected final ActivityTabProvider mActivityTabProvider;
+    protected ObservableSupplier<ShareDelegate> mShareDelegateSupplier;
+    protected final OneshotSupplierImpl<DesktopWindowStateManager>
+            mDesktopWindowStateManagerSupplier = new OneshotSupplierImpl<>();
+
+    protected @Nullable FindToolbarManager mFindToolbarManager;
+    private @Nullable FindToolbarObserver mFindToolbarObserver;
+
+    private OverlayPanelManager mOverlayPanelManager;
+    private OverlayPanelManager.OverlayPanelManagerObserver mOverlayPanelManagerObserver;
+
+    protected OneshotSupplier<LayoutStateProvider> mLayoutStateProviderOneShotSupplier;
+    protected LayoutStateProvider mLayoutStateProvider;
+    private LayoutStateProvider.LayoutStateObserver mLayoutStateObserver;
+
+    /**
+     * A controller which is used to show an Incognito re-auth dialog when the feature is available.
+     */
+    private @Nullable IncognitoReauthController mIncognitoReauthController;
+
+    /**
+     * An {@link OneshotSupplierImpl} of the {@link IncognitoReauthController} that can be used by
+     * clients to check to see if a re-auth is being shown or not.
+     */
+    private final OneshotSupplierImpl<IncognitoReauthController>
+            mIncognitoReauthControllerOneshotSupplier = new OneshotSupplierImpl<>();
+
+    /** A means of providing the theme color to different features. */
+    private TopUiThemeColorProvider mTopUiThemeColorProvider;
+
+    @Nullable private final Callback<Boolean> mOnOmniboxFocusChangedListener;
+    protected ToolbarManager mToolbarManager;
+    private ModalDialogManagerObserver mModalDialogManagerObserver;
+
+    private BottomSheetManager mBottomSheetManager;
+    private ManagedBottomSheetController mBottomSheetController;
+    private SnackbarManager mBottomSheetSnackbarManager;
+
+    private ScrimManager mScrimManager;
+    private final ToolbarActionModeCallback mActionModeControllerCallback;
+    private final ObservableSupplierImpl<Boolean> mOmniboxFocusStateSupplier =
+            new ObservableSupplierImpl<>();
+    private final ObservableSupplierImpl<MerchantTrustSignalsCoordinator>
+            mMerchantTrustSignalsCoordinatorSupplier = new ObservableSupplierImpl<>();
+    private final ObservableSupplierImpl<ScrimManager> mScrimManagerSupplier =
+            new ObservableSupplierImpl<>();
+    protected final ObservableSupplier<Profile> mProfileSupplier;
+    protected final ObservableSupplier<BookmarkModel> mBookmarkModelSupplier;
+    private final ObservableSupplier<TabBookmarker> mTabBookmarkerSupplier;
+    private final OneshotSupplierImpl<AppMenuCoordinator> mAppMenuSupplier;
+    private BottomSheetObserver mBottomSheetObserver;
+    protected final CallbackController mCallbackController;
+    protected final BrowserControlsManager mBrowserControlsManager;
+    private BrowserControlsStateProvider.Observer mBrowserControlsObserver;
+    protected final ObservableSupplier<TabModelSelector> mTabModelSelectorSupplier;
+    protected final OneshotSupplier<TabSwitcher> mTabSwitcherSupplier;
+    protected final OneshotSupplier<TabSwitcher> mIncognitoTabSwitcherSupplier;
+    @Nullable protected ManagedMessageDispatcher mMessageDispatcher;
+    @Nullable private MessageContainerCoordinator mMessageContainerCoordinator;
+    private MessageContainerObserver mMessageContainerObserver;
+    @Nullable private ChromeMessageQueueMediator mMessageQueueMediator;
+    private LayoutManagerImpl mLayoutManager;
+    protected OneshotSupplier<ToolbarIntentMetadata> mIntentMetadataOneshotSupplier;
+    protected OneshotSupplierImpl<Boolean> mPromoShownOneshotSupplier = new OneshotSupplierImpl<>();
+    @Nullable private VoiceRecognitionHandler.Observer mMicStateObserver;
+    private MediaCaptureOverlayController mCaptureController;
+    private @Nullable ScrollCaptureManager mScrollCaptureManager;
+    protected final ActivityLifecycleDispatcher mActivityLifecycleDispatcher;
+    protected final ObservableSupplier<LayoutManagerImpl> mLayoutManagerImplSupplier;
+    protected final ObservableSupplierImpl<LayoutManager> mLayoutManagerSupplier;
+    protected final ObservableSupplier<ModalDialogManager> mModalDialogManagerSupplier;
+    private final AppMenuBlocker mAppMenuBlocker;
+    private final BooleanSupplier mSupportsAppMenuSupplier;
+    protected final BooleanSupplier mSupportsFindInPageSupplier;
+    protected final Supplier<TabCreatorManager> mTabCreatorManagerSupplier;
+    protected final FullscreenManager mFullscreenManager;
+    protected final Supplier<CompositorViewHolder> mCompositorViewHolderSupplier;
+    protected StatusBarColorController mStatusBarColorController;
+    protected final Supplier<SnackbarManager> mSnackbarManagerSupplier;
+    protected final ObservableSupplierImpl<EdgeToEdgeController> mEdgeToEdgeControllerSupplier;
+    protected Destroyable mEdgeToEdgeBottomChin;
+    protected final @ActivityType int mActivityType;
+    protected final Supplier<Boolean> mIsInOverviewModeSupplier;
+    private final AppMenuDelegate mAppMenuDelegate;
+    private final Supplier<TabContentManager> mTabContentManagerSupplier;
+    private final IntentRequestTracker mIntentRequestTracker;
+    private final boolean mInitializeUiWithIncognitoColors;
+    protected final OneshotSupplierImpl<EphemeralTabCoordinator> mEphemeralTabCoordinatorSupplier;
+    @Nullable protected final BackPressManager mBackPressManager;
+    private final boolean mIsIncognitoReauthPendingOnRestore;
+    protected final ExpandedSheetHelper mExpandedBottomSheetHelper;
+    protected final BottomControlsStacker mBottomControlsStacker;
+    @NonNull protected final ObservableSupplier<Integer> mOverviewColorSupplier;
+    @Nullable private ContextualSearchObserver mReadAloudContextualSearchObserver;
+    @Nullable private PageZoomCoordinator mPageZoomCoordinator;
+    private AppMenuObserver mAppMenuObserver;
+
+    private final OneshotSupplierImpl<ToolbarManager> mToolbarManagerOneshotSupplier =
+            new OneshotSupplierImpl<>();
+    private ActivityRecreationController mActivityRecreationController;
+    private RestoreTabsFeatureHelper mRestoreTabsFeatureHelper;
+    private @Nullable EdgeToEdgeController mEdgeToEdgeController;
+    private ComposedBrowserControlsVisibilityDelegate mAppBrowserControlsVisibilityDelegate;
+    private @Nullable BoardingPassController mBoardingPassController;
+    private final @NonNull EdgeToEdgeManager mEdgeToEdgeManager;
+    private AutomotiveBackButtonToolbarCoordinator mAutomotiveBackButtonToolbarCoordinator;
+    protected AdaptiveToolbarUiCoordinator mAdaptiveToolbarUiCoordinator;
+
+    /**
+     * Create a new {@link RootUiCoordinator} for the given activity.
+     *
+     * @param activity The activity whose UI the coordinator is responsible for.
+     * @param onOmniboxFocusChangedListener callback to invoke when Omnibox focus changes.
+     * @param shareDelegateSupplier Supplies the {@link ShareDelegate}.
+     * @param tabProvider The {@link ActivityTabProvider} to get current tab of the activity.
+     * @param profileSupplier Supplier of the currently applicable profile.
+     * @param bookmarkModelSupplier Supplier of the bookmark bridge for the current profile.
+     * @param tabBookmarkerSupplier Supplier of {@link TabBookmarker} for bookmarking a given tab.
+     * @param tabModelSelectorSupplier Supplies the {@link TabModelSelector}.
+     * @param tabSwitcherSupplier Supplier of the {@link TabSwitcher}.
+     * @param incognitoTabSwitcherSupplier Supplier of the incognito {@link TabSwitcher}.
+     * @param intentMetadataOneshotSupplier Supplier with information about the launching intent.
+     * @param layoutStateProviderOneshotSupplier Supplier of the {@link LayoutStateProvider}.
+     * @param browserControlsManager Manages the browser controls.
+     * @param windowAndroid The current {@link WindowAndroid}.
+     * @param activityLifecycleDispatcher Allows observation of the activity lifecycle.
+     * @param layoutManagerSupplier Supplies the {@link LayoutManager}.
+     * @param menuOrKeyboardActionController Controls the menu or keyboard action controller.
+     * @param activityThemeColorSupplier Supplies the activity color theme.
+     * @param modalDialogManagerSupplier Supplies the {@link ModalDialogManager}.
+     * @param appMenuBlocker Controls the app menu blocking.
+     * @param supportsAppMenuSupplier Supplies the support state for the app menu.
+     * @param supportsFindInPage Supplies the support state for find in page.
+     * @param tabCreatorManagerSupplier Supplies the {@link TabCreatorManager}.
+     * @param fullscreenManager Manages the fullscreen state.
+     * @param compositorViewHolderSupplier Supplies the {@link CompositorViewHolder}.
+     * @param tabContentManagerSupplier Supplies the {@link TabContentManager}.
+     * @param snackbarManagerSupplier Supplies the {@link SnackbarManager}.
+     * @param edgeToEdgeControllerSupplier Supplies an {@link EdgeToEdgeController}.
+     * @param activityType The {@link ActivityType} for the activity.
+     * @param isInOverviewModeSupplier Supplies whether the app is in overview mode.
+     * @param appMenuDelegate The app menu delegate.
+     * @param statusBarColorProvider Provides the status bar color.
+     * @param intentRequestTracker Tracks intent requests.
+     * @param ephemeralTabCoordinatorSupplier Supplies the {@link EphemeralTabCoordinator}.
+     * @param initializeUiWithIncognitoColors Whether to initialize the UI with incognito colors.
+     * @param backPressManager The {@link BackPressManager} handling back press.
+     * @param savedInstanceState The saved bundle for the last recorded state.
+     * @param overviewColorSupplier Notifies when the overview color changes.
+     * @param edgeToEdgeManager Manages core edge-to-edge state and logic.
+     */
+    public RootUiCoordinator(
+            @NonNull AppCompatActivity activity,
+            @Nullable Callback<Boolean> onOmniboxFocusChangedListener,
+            @NonNull ObservableSupplier<ShareDelegate> shareDelegateSupplier,
+            @NonNull ActivityTabProvider tabProvider,
+            @NonNull ObservableSupplier<Profile> profileSupplier,
+            @NonNull ObservableSupplier<BookmarkModel> bookmarkModelSupplier,
+            @NonNull ObservableSupplier<TabBookmarker> tabBookmarkerSupplier,
+            @NonNull ObservableSupplier<TabModelSelector> tabModelSelectorSupplier,
+            @NonNull OneshotSupplier<TabSwitcher> tabSwitcherSupplier,
+            @NonNull OneshotSupplier<TabSwitcher> incognitoTabSwitcherSupplier,
+            @NonNull OneshotSupplier<ToolbarIntentMetadata> intentMetadataOneshotSupplier,
+            @NonNull OneshotSupplier<LayoutStateProvider> layoutStateProviderOneshotSupplier,
+            @NonNull BrowserControlsManager browserControlsManager,
+            @NonNull ActivityWindowAndroid windowAndroid,
+            @NonNull ActivityLifecycleDispatcher activityLifecycleDispatcher,
+            @NonNull ObservableSupplier<LayoutManagerImpl> layoutManagerSupplier,
+            @NonNull MenuOrKeyboardActionController menuOrKeyboardActionController,
+            @NonNull Supplier<Integer> activityThemeColorSupplier,
+            @NonNull ObservableSupplier<ModalDialogManager> modalDialogManagerSupplier,
+            @NonNull AppMenuBlocker appMenuBlocker,
+            @NonNull BooleanSupplier supportsAppMenuSupplier,
+            @NonNull BooleanSupplier supportsFindInPage,
+            @NonNull Supplier<TabCreatorManager> tabCreatorManagerSupplier,
+            @NonNull FullscreenManager fullscreenManager,
+            @NonNull Supplier<CompositorViewHolder> compositorViewHolderSupplier,
+            @NonNull Supplier<TabContentManager> tabContentManagerSupplier,
+            @NonNull Supplier<SnackbarManager> snackbarManagerSupplier,
+            @NonNull ObservableSupplierImpl<EdgeToEdgeController> edgeToEdgeControllerSupplier,
+            @ActivityType int activityType,
+            @NonNull Supplier<Boolean> isInOverviewModeSupplier,
+            @NonNull AppMenuDelegate appMenuDelegate,
+            @NonNull StatusBarColorProvider statusBarColorProvider,
+            @NonNull IntentRequestTracker intentRequestTracker,
+            @NonNull OneshotSupplierImpl<EphemeralTabCoordinator> ephemeralTabCoordinatorSupplier,
+            boolean initializeUiWithIncognitoColors,
+            @Nullable BackPressManager backPressManager,
+            @Nullable Bundle savedInstanceState,
+            @NonNull ObservableSupplier<Integer> overviewColorSupplier,
+            @NonNull EdgeToEdgeManager edgeToEdgeManager) {
+        mCallbackController = new CallbackController();
+        mActivity = activity;
+        mWindowAndroid = windowAndroid;
+        setupUnownedUserDataSuppliers();
+        mOnOmniboxFocusChangedListener = onOmniboxFocusChangedListener;
+        mBrowserControlsManager = browserControlsManager;
+        mModalDialogManagerSupplier = modalDialogManagerSupplier;
+        mActivityLifecycleDispatcher = activityLifecycleDispatcher;
+        mActivityLifecycleDispatcher.register(this);
+        mAppMenuBlocker = appMenuBlocker;
+        mSupportsAppMenuSupplier = supportsAppMenuSupplier;
+        mSupportsFindInPageSupplier = supportsFindInPage;
+        mTabCreatorManagerSupplier = tabCreatorManagerSupplier;
+        mFullscreenManager = fullscreenManager;
+        mCompositorViewHolderSupplier = compositorViewHolderSupplier;
+        mTabContentManagerSupplier = tabContentManagerSupplier;
+        mSnackbarManagerSupplier = snackbarManagerSupplier;
+        mEdgeToEdgeControllerSupplier = edgeToEdgeControllerSupplier;
+        mActivityType = activityType;
+        mIsInOverviewModeSupplier = isInOverviewModeSupplier;
+        mAppMenuDelegate = appMenuDelegate;
+        mIntentRequestTracker = intentRequestTracker;
+        mInitializeUiWithIncognitoColors = initializeUiWithIncognitoColors;
+        mBackPressManager = backPressManager;
+        mIsIncognitoReauthPendingOnRestore =
+                savedInstanceState != null
+                        && savedInstanceState.getBoolean(
+                                IncognitoReauthControllerImpl.KEY_IS_INCOGNITO_REAUTH_PENDING,
+                                false);
+
+        mMenuOrKeyboardActionController = menuOrKeyboardActionController;
+        mMenuOrKeyboardActionController.registerMenuOrKeyboardActionHandler(this);
+        mActivityTabProvider = tabProvider;
+
+        // This little bit of arithmetic is necessary because of Java doesn't like accepting
+        // Supplier<BaseImpl> where Supplier<Base> is expected. We should remove the need for
+        // LayoutManagerImpl in this class so we can simply use Supplier<LayoutManager>.
+        mLayoutManagerSupplier = new ObservableSupplierImpl<>();
+        Callback<LayoutManagerImpl> mLayoutManagerSupplierCallback =
+                (layoutManager) -> {
+                    onLayoutManagerAvailable(layoutManager);
+                    mLayoutManagerSupplier.set(layoutManager);
+                };
+        mLayoutManagerImplSupplier = layoutManagerSupplier;
+        mLayoutManagerImplSupplier.addObserver(mLayoutManagerSupplierCallback);
+
+        mShareDelegateSupplier = shareDelegateSupplier;
+        mTabObscuringHandlerSupplier.set(new TabObscuringHandler());
+        mDeviceLockActivityLauncherSupplier.set(DeviceLockActivityLauncherImpl.get());
+        new AccessibilityVisibilityHandler(
+                mActivityLifecycleDispatcher,
+                mActivityTabProvider,
+                mTabObscuringHandlerSupplier.get());
+        // While Autofill is supported on Android O, meaningful Autofill interactions in Chrome
+        // require the compatibility mode introduced in Android P.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+            new AutofillSessionLifetimeController(
+                    activity, mActivityLifecycleDispatcher, mActivityTabProvider);
+        }
+        mProfileSupplier = profileSupplier;
+        mBookmarkModelSupplier = bookmarkModelSupplier;
+        mTabBookmarkerSupplier = tabBookmarkerSupplier;
+        mAppMenuSupplier = new OneshotSupplierImpl<>();
+        mActionModeControllerCallback = new ToolbarActionModeCallback();
+
+        mTabModelSelectorSupplier = tabModelSelectorSupplier;
+
+        mOmniboxFocusStateSupplier.set(false);
+
+        mLayoutStateProviderOneShotSupplier = layoutStateProviderOneshotSupplier;
+        mLayoutStateProviderOneShotSupplier.onAvailable(
+                mCallbackController.makeCancelable(this::setLayoutStateProvider));
+
+        mTabSwitcherSupplier = tabSwitcherSupplier;
+        mIncognitoTabSwitcherSupplier = incognitoTabSwitcherSupplier;
+        mIntentMetadataOneshotSupplier = intentMetadataOneshotSupplier;
+
+        boolean isTablet = DeviceFormFactor.isNonMultiDisplayContextOnTablet(activity);
+        mTopUiThemeColorProvider =
+                new TopUiThemeColorProvider(
+                        mActivity,
+                        mActivityTabProvider,
+                        activityThemeColorSupplier,
+                        isTablet,
+                        shouldAllowThemingInNightMode(),
+                        shouldAllowBrightThemeColors());
+
+        mStatusBarColorController =
+                new StatusBarColorController(
+                        mActivity.getWindow(),
+                        DeviceFormFactor.isNonMultiDisplayContextOnTablet(/* Context */ mActivity),
+                        mActivity,
+                        statusBarColorProvider,
+                        mLayoutManagerSupplier,
+                        mActivityLifecycleDispatcher,
+                        mActivityTabProvider,
+                        mTopUiThemeColorProvider,
+                        edgeToEdgeManager.getEdgeToEdgeSystemBarColorHelper(),
+                        mDesktopWindowStateManagerSupplier);
+        mEphemeralTabCoordinatorSupplier = ephemeralTabCoordinatorSupplier;
+
+        mPageZoomCoordinator =
+                new PageZoomCoordinator(
+                        new PageZoomCoordinatorDelegate() {
+                            @Override
+                            public View getZoomControlView() {
+                                ViewStub viewStub =
+                                        mActivity.findViewById(R.id.page_zoom_container);
+                                return viewStub.inflate();
+                            }
+
+                            @Override
+                            public BrowserContextHandle getBrowserContextHandle() {
+                                return mProfileSupplier.get().getOriginalProfile();
+                            }
+                        });
+        mActivityRecreationController =
+                new ActivityRecreationController(
+                        mToolbarManagerOneshotSupplier,
+                        mLayoutManagerSupplier,
+                        mActivityTabProvider,
+                        new Handler());
+        mExpandedBottomSheetHelper =
+                new ExpandedSheetHelperImpl(mModalDialogManagerSupplier, getTabObscuringHandler());
+        mOverviewColorSupplier = overviewColorSupplier;
+        mEdgeToEdgeManager = edgeToEdgeManager;
+        mBottomControlsStacker =
+                new BottomControlsStacker(mBrowserControlsManager, mActivity, mWindowAndroid);
+    }
+
+    // TODO(pnoland, crbug.com/865801): remove this in favor of wiring it directly.
+    public ToolbarManager getToolbarManager() {
+        return mToolbarManager;
+    }
+
+    public StatusBarColorController getStatusBarColorController() {
+        return mStatusBarColorController;
+    }
+
+    // TODO(jinsukkim): remove this in favor of wiring it directly.
+    /**
+     * @return {@link ThemeColorProvider} for top UI.
+     */
+    public TopUiThemeColorProvider getTopUiThemeColorProvider() {
+        return mTopUiThemeColorProvider;
+    }
+
+    /**
+     * @return The {@link DesktopWindowStateManager} instance associated with the current activity.
+     */
+    public @Nullable DesktopWindowStateManager getDesktopWindowStateManager() {
+        return null;
+    }
+
+    public void onAttachFragment(Fragment fragment) {
+        if (fragment instanceof QrCodeDialog) {
+            QrCodeDialog qrCodeDialog = (QrCodeDialog) fragment;
+            qrCodeDialog.setWindowAndroid(mWindowAndroid);
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        // TODO(meiliang): Understand why we need to set most of the class member instances to null
+        //  other than the mActivity. If the nulling calls are not necessary, we can remove them.
+        mCallbackController.destroy();
+        mMenuOrKeyboardActionController.unregisterMenuOrKeyboardActionHandler(this);
+
+        destroyUnownedUserDataSuppliers();
+        mActivityLifecycleDispatcher.unregister(this);
+
+        if (mMessageDispatcher != null) {
+            mMessageDispatcher.dismissAllMessages(DismissReason.ACTIVITY_DESTROYED);
+            MessagesFactory.detachMessageDispatcher(mMessageDispatcher);
+            mMessageDispatcher = null;
+        }
+
+        if (mMessageQueueMediator != null) {
+            mMessageQueueMediator.destroy();
+            mMessageQueueMediator = null;
+        }
+
+        if (mMessageContainerCoordinator != null) {
+            if (mMessageContainerObserver != null) {
+                mMessageContainerCoordinator.removeObserver(mMessageContainerObserver);
+            }
+            mMessageContainerCoordinator.destroy();
+            mMessageContainerCoordinator = null;
+        }
+
+        if (mOverlayPanelManager != null) {
+            mOverlayPanelManager.removeObserver(mOverlayPanelManagerObserver);
+        }
+
+        if (mLayoutStateProvider != null) {
+            mLayoutStateProvider.removeObserver(mLayoutStateObserver);
+            mLayoutStateProvider = null;
+        }
+
+        if (mToolbarManager != null) {
+            if (mMicStateObserver != null && mToolbarManager.getVoiceRecognitionHandler() != null) {
+                mToolbarManager.getVoiceRecognitionHandler().removeObserver(mMicStateObserver);
+            }
+            mToolbarManager.destroy();
+            mToolbarManager = null;
+        }
+
+        if (mAdaptiveToolbarUiCoordinator != null) {
+            mAdaptiveToolbarUiCoordinator.destroy();
+            mAdaptiveToolbarUiCoordinator = null;
+        }
+
+        if (mAppMenuCoordinator != null) {
+            mAppMenuCoordinator.unregisterAppMenuBlocker(this);
+            mAppMenuCoordinator.unregisterAppMenuBlocker(mAppMenuBlocker);
+
+            if (mAppMenuObserver != null) {
+                mAppMenuCoordinator.getAppMenuHandler().removeObserver(mAppMenuObserver);
+            }
+            mAppMenuCoordinator.destroy();
+        }
+
+        if (mTopUiThemeColorProvider != null) {
+            mTopUiThemeColorProvider.destroy();
+            mTopUiThemeColorProvider = null;
+        }
+
+        if (mFindToolbarManager != null) mFindToolbarManager.removeObserver(mFindToolbarObserver);
+
+        if (mModalDialogManagerObserver != null && mModalDialogManagerSupplier.hasValue()) {
+            mModalDialogManagerSupplier.get().removeObserver(mModalDialogManagerObserver);
+        }
+
+        if (mBottomSheetManager != null) mBottomSheetManager.onDestroy();
+        if (mBottomSheetController != null) {
+            if (mBottomSheetObserver != null) {
+                mBottomSheetController.removeObserver(mBottomSheetObserver);
+            }
+            BottomSheetControllerFactory.detach(mBottomSheetController);
+            mBottomSheetController.destroy();
+        }
+
+        if (mScrimManager != null) mScrimManager.destroy();
+        mScrimManager = null;
+
+        if (mCaptureController != null) {
+            mCaptureController.destroy();
+            mCaptureController = null;
+        }
+
+        if (mMerchantTrustSignalsCoordinatorSupplier.hasValue()) {
+            mMerchantTrustSignalsCoordinatorSupplier.get().destroy();
+            mMerchantTrustSignalsCoordinatorSupplier.set(null);
+        }
+
+        if (mScrollCaptureManager != null) {
+            mScrollCaptureManager.destroy();
+            mScrollCaptureManager = null;
+        }
+
+        if (mIncognitoReauthController != null) {
+            mIncognitoReauthController.destroy();
+        }
+
+        if (mPageZoomCoordinator != null) {
+            mPageZoomCoordinator.destroy();
+            mPageZoomCoordinator = null;
+        }
+
+        if (mBrowserControlsObserver != null) {
+            mBrowserControlsManager.removeObserver(mBrowserControlsObserver);
+        }
+
+        if (mActivityRecreationController != null) {
+            mActivityRecreationController = null;
+        }
+
+        if (mRestoreTabsFeatureHelper != null) {
+            mRestoreTabsFeatureHelper.destroy();
+            mRestoreTabsFeatureHelper = null;
+        }
+
+        if (mReadAloudControllerSupplier.hasValue()) {
+            ContextualSearchManager contextualSearchManager =
+                    mContextualSearchManagerSupplier.get();
+            if (contextualSearchManager != null) {
+                contextualSearchManager.removeObserver(mReadAloudContextualSearchObserver);
+            }
+            var readAloudController = mReadAloudControllerSupplier.get();
+            mReadAloudControllerSupplier.set(null);
+            readAloudController.destroy();
+        }
+
+        if (mContextualSearchManagerSupplier.hasValue()) {
+            mContextualSearchManagerSupplier.get().destroy();
+            mContextualSearchManagerSupplier.set(null);
+        }
+
+        if (mEdgeToEdgeController != null) {
+            mEdgeToEdgeController.destroy();
+            mEdgeToEdgeController = null;
+        }
+        mEdgeToEdgeControllerSupplier.set(null);
+
+        if (mEdgeToEdgeBottomChin != null) {
+            mEdgeToEdgeBottomChin.destroy();
+        }
+
+        if (mBoardingPassController != null) {
+            mBoardingPassController.destroy();
+            mBoardingPassController = null;
+        }
+
+        if (mAutomotiveBackButtonToolbarCoordinator != null) {
+            mAutomotiveBackButtonToolbarCoordinator.destroy();
+            mAutomotiveBackButtonToolbarCoordinator = null;
+        }
+        mBottomControlsStacker.destroy();
+        mActivity = null;
+    }
+
+    private void setupUnownedUserDataSuppliers() {
+        var userDataHost = mWindowAndroid.getUnownedUserDataHost();
+        mTabObscuringHandlerSupplier.attach(userDataHost);
+        mDeviceLockActivityLauncherSupplier.attach(userDataHost);
+        mContextualSearchManagerSupplier.attach(userDataHost);
+        mReadAloudControllerSupplier.attach(userDataHost);
+    }
+
+    private void destroyUnownedUserDataSuppliers() {
+        // TabObscuringHandler doesn't have a destroy method.
+        mTabObscuringHandlerSupplier.destroy();
+        mDeviceLockActivityLauncherSupplier.destroy();
+        mContextualSearchManagerSupplier.destroy();
+        mReadAloudControllerSupplier.destroy();
+    }
+
+    @Override
+    public void onPreInflationStartup() {
+        initializeBottomSheetController();
+    }
+
+    @Override
+    public void onInflationComplete() {
+        mScrimManager = buildScrimWidget();
+        mScrimManagerSupplier.set(mScrimManager);
+        initFindToolbarManager();
+        initializeToolbar();
+    }
+
+    @Override
+    public void onPostInflationStartup() {
+        initAppMenu();
+        initBottomSheetObserver();
+        initSnackbarObserver();
+        initBrowserControlsObserver();
+        if (mAppMenuCoordinator != null && mModalDialogManagerSupplier.hasValue()) {
+            mModalDialogManagerObserver =
+                    new ModalDialogManagerObserver() {
+                        @Override
+                        public void onDialogAdded(PropertyModel model) {
+                            mAppMenuCoordinator.getAppMenuHandler().hideAppMenu();
+                        }
+                    };
+            mModalDialogManagerSupplier.get().addObserver(mModalDialogManagerObserver);
+        }
+        new ChromeActionModeHandler(
+                mActivityTabProvider,
+                (searchText) -> {
+                    if (mTabModelSelectorSupplier.get() == null) return;
+
+                    String query =
+                            ActionModeCallbackHelper.sanitizeQuery(
+                                    searchText, ActionModeCallbackHelper.MAX_SEARCH_QUERY_LENGTH);
+                    if (TextUtils.isEmpty(query)) return;
+
+                    Tab tab = mActivityTabProvider.get();
+                    TrackerFactory.getTrackerForProfile(tab.getProfile())
+                            .notifyEvent(EventConstants.WEB_SEARCH_PERFORMED);
+
+                    mTabModelSelectorSupplier
+                            .get()
+                            .openNewTab(
+                                    generateUrlParamsForSearch(tab, query),
+                                    TabLaunchType.FROM_LONGPRESS_FOREGROUND,
+                                    tab,
+                                    tab.isIncognito());
+                },
+                showWebSearchInActionMode(),
+                mShareDelegateSupplier,
+                mBrowserControlsManager,
+                mReadAloudControllerSupplier);
+
+        mCaptureController =
+                new MediaCaptureOverlayController(
+                        mWindowAndroid, mActivity.findViewById(R.id.capture_overlay));
+
+        // Ensure the bottom sheet's container has been laid out at least once before hiding it.
+        // TODO(crbug.com/40759801): This should be owned by the BottomSheetControllerImpl, but
+        // there are some
+        //                complexities around the order of events resulting from waiting for layout.
+        ViewGroup sheetContainer = mActivity.findViewById(R.id.sheet_container);
+        if (!sheetContainer.isLaidOut()) {
+            sheetContainer.addOnLayoutChangeListener(
+                    new View.OnLayoutChangeListener() {
+                        @Override
+                        public void onLayoutChange(
+                                View view,
+                                int left,
+                                int top,
+                                int right,
+                                int bottom,
+                                int oldLeft,
+                                int oldTop,
+                                int oldRight,
+                                int oldBottom) {
+                            sheetContainer.setVisibility(View.GONE);
+                            sheetContainer.removeOnLayoutChangeListener(this);
+                        }
+                    });
+        } else {
+            sheetContainer.setVisibility(View.GONE);
+        }
+    }
+
+    protected boolean showWebSearchInActionMode() {
+        return true;
+    }
+
+    @Override
+    @CallSuper
+    public void onFinishNativeInitialization() {
+        if (mProfileSupplier.hasValue()) {
+            initProfileDependentFeatures(mProfileSupplier.get());
+        } else {
+            new OneShotCallback<>(
+                    mProfileSupplier,
+                    mCallbackController.makeCancelable(this::initProfileDependentFeatures));
+        }
+
+        initMessagesInfra();
+        initScrollCapture();
+
+        // TODO(crbug.com/350610430) Potentially create the E2EController earlier during startup
+        initializeEdgeToEdgeController();
+        initBoardingPassDetector();
+
+        if (EphemeralTabCoordinator.isSupported()) {
+            Supplier<TabCreator> tabCreator =
+                    () ->
+                            mTabCreatorManagerSupplier
+                                    .get()
+                                    .getTabCreator(
+                                            mTabModelSelectorSupplier.get().isIncognitoSelected());
+            mEphemeralTabCoordinatorSupplier.set(
+                    new EphemeralTabCoordinator(
+                            mActivity,
+                            mWindowAndroid,
+                            mActivity.getWindow().getDecorView(),
+                            mActivityTabProvider,
+                            tabCreator,
+                            getBottomSheetController(),
+                            canPreviewPromoteToTab()));
+        }
+        if (ChromeFeatureList.isEnabled(ChromeFeatureList.READALOUD)) {
+            TabModelSelector tabModelSelector = mTabModelSelectorSupplier.get();
+            ReadAloudController controller =
+                    new ReadAloudController(
+                            mActivity,
+                            mProfileSupplier,
+                            tabModelSelector.getModel(/* incognito= */ false),
+                            tabModelSelector.getModel(/* incognito= */ true),
+                            getBottomSheetController(),
+                            mBottomControlsStacker,
+                            mLayoutManagerSupplier,
+                            mWindowAndroid,
+                            mActivityLifecycleDispatcher,
+                            mLayoutStateProviderOneShotSupplier,
+                            mFullscreenManager);
+            mReadAloudControllerSupplier.set(controller);
+            mReadAloudContextualSearchObserver =
+                    new ContextualSearchObserver() {
+                        @Override
+                        public void onShowContextualSearch() {
+                            controller.maybeHidePlayer();
+                        }
+
+                        @Override
+                        public void onHideContextualSearch() {
+                            controller.maybeShowPlayer();
+                        }
+                    };
+            ContextualSearchManager contextualSearchManager =
+                    mContextualSearchManagerSupplier.get();
+            if (contextualSearchManager != null) {
+                contextualSearchManager.addObserver(mReadAloudContextualSearchObserver);
+            }
+        }
+        if (BuildInfo.getInstance().isAutomotive
+                && ChromeFeatureList.isEnabled(
+                        ChromeFeatureList.AUTOMOTIVE_FULLSCREEN_TOOLBAR_IMPROVEMENTS)) {
+            mAutomotiveBackButtonToolbarCoordinator =
+                    new AutomotiveBackButtonToolbarCoordinator(
+                            mActivity,
+                            mActivity.findViewById(R.id.automotive_base_frame_layout),
+                            mFullscreenManager,
+                            mCompositorViewHolderSupplier.get(),
+                            mBackPressManager);
+        }
+    }
+
+    /** Preview Tab can be promoted to a normal tab by default. */
+    protected boolean canPreviewPromoteToTab() {
+        return true;
+    }
+
+    protected boolean isContextualSearchEnabled() {
+        return true;
+    }
+
+    public void createContextualSearchManager(Profile profile) {
+        if (!isContextualSearchEnabled()) return;
+
+        mContextualSearchManagerSupplier.set(
+                new ContextualSearchManager(
+                        mActivity,
+                        profile,
+                        this,
+                        mScrimManager,
+                        mActivityTabProvider,
+                        mFullscreenManager,
+                        mBrowserControlsManager,
+                        mWindowAndroid,
+                        mTabModelSelectorSupplier.get(),
+                        mEdgeToEdgeControllerSupplier));
+    }
+
+    public void initContextualSearchManager() {
+        var manager = mContextualSearchManagerSupplier.get();
+        if (manager == null) return;
+
+        int controlContainerHeightId = getControlContainerHeightResource();
+        float toolbarHeightDp =
+                controlContainerHeightId == ActivityUtils.NO_RESOURCE_ID
+                        ? 0f
+                        : mActivity.getResources().getDimension(controlContainerHeightId);
+        manager.initialize(
+                mActivity.findViewById(android.R.id.content),
+                mLayoutManager,
+                getBottomSheetController(),
+                mCompositorViewHolderSupplier.get(),
+                toolbarHeightDp,
+                mToolbarManager,
+                canContextualSearchPromoteToNewTab(),
+                mIntentRequestTracker,
+                getDesktopWindowStateManager(),
+                mBottomControlsStacker);
+    }
+
+    public ObservableSupplier<ContextualSearchManager> getContextualSearchManagerSupplier() {
+        return mContextualSearchManagerSupplier;
+    }
+
+    /** Whether contextual search panel is opened. */
+    public boolean isContextualSearchOpened() {
+        return mContextualSearchManagerSupplier.hasValue()
+                && mContextualSearchManagerSupplier.get().isSearchPanelOpened();
+    }
+
+    /** Hide contextual search panel. */
+    public void hideContextualSearch() {
+        if (mContextualSearchManagerSupplier.hasValue()) {
+            mContextualSearchManagerSupplier
+                    .get()
+                    .hideContextualSearch(OverlayPanel.StateChangeReason.UNKNOWN);
+        }
+    }
+
+    /**
+     * @return The resource id that contains how large the browser controls are.
+     */
+    public int getControlContainerHeightResource() {
+        return ActivityUtils.NO_RESOURCE_ID;
+    }
+
+    protected boolean canContextualSearchPromoteToNewTab() {
+        return false;
+    }
+
+    @Override
+    public void createContextualSearchTab(String searchUrl) {
+        Tab currentTab = mActivityTabProvider.get();
+        if (currentTab == null) return;
+
+        TabCreator tabCreator =
+                mTabCreatorManagerSupplier.get().getTabCreator(currentTab.isIncognito());
+        if (tabCreator == null) return;
+
+        tabCreator.createNewTab(
+                new LoadUrlParams(searchUrl, PageTransition.LINK),
+                TabLaunchType.FROM_LINK,
+                mActivityTabProvider.get());
+    }
+
+    /** Handle post native initialization of features that require the Profile to be available. */
+    @CallSuper
+    protected void initProfileDependentFeatures(Profile currentlySelectedProfile) {
+        Profile originalProfile = currentlySelectedProfile.getOriginalProfile();
+
+        // Setup IncognitoReauthController as early as possible, to show the re-auth screen.
+        if (IncognitoReauthManager.isIncognitoReauthFeatureAvailable()) {
+            initIncognitoReauthController(originalProfile);
+        }
+
+        if (DeviceFormFactor.isWindowOnTablet(mWindowAndroid)
+                && RequestDesktopUtils.maybeDefaultEnableGlobalSetting(
+                        getPrimaryDisplaySizeInInches(), originalProfile, mActivity)) {
+            // TODO(crbug.com/40856393): Remove this explicit load when this bug is addressed.
+            if (mActivityTabProvider != null && mActivityTabProvider.get() != null) {
+                mActivityTabProvider
+                        .get()
+                        .loadIfNeeded(TabLoadIfNeededCaller.ON_FINISH_NATIVE_INITIALIZATION);
+            }
+        }
+
+        RequestDesktopUtils.maybeDefaultEnableWindowSetting(mActivity, originalProfile);
+
+        initMerchantTrustSignals(originalProfile);
+    }
+
+    private void initMessagesInfra() {
+        // TODO(crbug.com/40753426): Move feature flag and parameters into a separate class in
+        MessagesResourceMapperInitializer.init();
+        MessageContainer container = mActivity.findViewById(R.id.message_container);
+        mMessageContainerCoordinator =
+                new MessageContainerCoordinator(container, mBrowserControlsManager);
+        mMessageContainerObserver =
+                new MessageContainerObserver() {
+                    @Override
+                    public void onShowMessageContainer() {
+                        if (mPageZoomCoordinator != null) {
+                            mPageZoomCoordinator.hide();
+                        }
+                    }
+
+                    @Override
+                    public void onHideMessageContainer() {}
+                };
+        mMessageContainerCoordinator.addObserver(mMessageContainerObserver);
+        mMessageDispatcher =
+                MessagesFactory.createMessageDispatcher(
+                        container,
+                        mMessageContainerCoordinator::getMessageTopOffset,
+                        mMessageContainerCoordinator::getMessageMaxTranslation,
+                        new ChromeMessageAutodismissDurationProvider(),
+                        mWindowAndroid::startAnimationOverContent,
+                        mWindowAndroid);
+        mMessageQueueMediator =
+                new ChromeMessageQueueMediator(
+                        mBrowserControlsManager,
+                        mMessageContainerCoordinator,
+                        mActivityTabProvider,
+                        mLayoutStateProviderOneShotSupplier,
+                        mModalDialogManagerSupplier,
+                        getBottomSheetController(),
+                        mActivityLifecycleDispatcher,
+                        mMessageDispatcher);
+        mMessageDispatcher.setDelegate(mMessageQueueMediator);
+        MessagesFactory.attachMessageDispatcher(mWindowAndroid, mMessageDispatcher);
+    }
+
+    private void initIncognitoReauthController(Profile profile) {
+        IncognitoReauthCoordinatorFactory incognitoReauthCoordinatorFactory =
+                getIncognitoReauthCoordinatorFactory(profile);
+        assert incognitoReauthCoordinatorFactory != null
+                : "Sub-classes need to provide a valid factory instance.";
+        mIncognitoReauthController =
+                new IncognitoReauthControllerImpl(
+                        mTabModelSelectorSupplier.get(),
+                        mActivityLifecycleDispatcher,
+                        mLayoutStateProviderOneShotSupplier,
+                        mProfileSupplier,
+                        incognitoReauthCoordinatorFactory,
+                        () -> mIsIncognitoReauthPendingOnRestore,
+                        mActivity.getTaskId());
+        mIncognitoReauthControllerOneshotSupplier.set(mIncognitoReauthController);
+    }
+
+    /**
+     * @return The primary display size of the device, in inches.
+     */
+    public double getPrimaryDisplaySizeInInches() {
+        DisplayAndroid display = DisplayAndroid.getNonMultiDisplay(mActivity);
+        double xInches = display.getDisplayWidth() / display.getXdpi();
+        double yInches = display.getDisplayHeight() / display.getYdpi();
+        return Math.sqrt(Math.pow(xInches, 2) + Math.pow(yInches, 2));
+    }
+
+    /**
+     * This method is meant to be overridden for sub-classes which needs to provide an incognito
+     * re-auth view.
+     *
+     * @return {@link IncognitoReauthCoordiantorFactory} instance.
+     */
+    protected IncognitoReauthCoordinatorFactory getIncognitoReauthCoordinatorFactory(
+            Profile profile) {
+        return null;
+    }
+
+    private void initMerchantTrustSignals(Profile profile) {
+        if (ShoppingServiceFactory.getForProfile(profile).isMerchantViewerEnabled()
+                && shouldInitializeMerchantTrustSignals()) {
+            MerchantTrustSignalsCoordinator merchantTrustSignalsCoordinator =
+                    new MerchantTrustSignalsCoordinator(
+                            mActivity,
+                            mWindowAndroid,
+                            getBottomSheetController(),
+                            mActivity.getWindow().getDecorView(),
+                            MessageDispatcherProvider.from(mWindowAndroid),
+                            mActivityTabProvider,
+                            mProfileSupplier,
+                            new MerchantTrustMetrics(),
+                            mIntentRequestTracker);
+            mMerchantTrustSignalsCoordinatorSupplier.set(merchantTrustSignalsCoordinator);
+        }
+    }
+
+    private void initScrollCapture() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) return;
+
+        mScrollCaptureManager = new ScrollCaptureManager(mActivityTabProvider);
+    }
+
+    /**
+     * @return Whether the {@link MerchantTrustSignalsCoordinator} should be initialized in the
+     * context of this coordinator's UI.
+     **/
+    protected boolean shouldInitializeMerchantTrustSignals() {
+        return false;
+    }
+
+    /** Returns the supplier of {@link MerchantTrustSignalsCoordinator}. */
+    @NonNull
+    public Supplier<MerchantTrustSignalsCoordinator> getMerchantTrustSignalsCoordinatorSupplier() {
+        return mMerchantTrustSignalsCoordinatorSupplier;
+    }
+
+    /** Generate the LoadUrlParams necessary to load the specified search query. */
+    private static LoadUrlParams generateUrlParamsForSearch(Tab tab, String query) {
+        String url =
+                TemplateUrlServiceFactory.getForProfile(tab.getProfile())
+                        .getUrlForSearchQuery(query);
+
+        LoadUrlParams loadUrlParams = new LoadUrlParams(url);
+        loadUrlParams.setTransitionType(PageTransition.GENERATED);
+        return loadUrlParams;
+    }
+
+    /**
+     * Triggered when the share menu item is selected.
+     * This creates and shows a share intent picker dialog or starts a share intent directly.
+     * @param shareDirectly Whether it should share directly with the activity that was most
+     *                      recently used to share.
+     * @param isIncognito Whether currentTab is incognito.
+     */
+    @VisibleForTesting
+    public void onShareMenuItemSelected(final boolean shareDirectly, final boolean isIncognito) {
+        ShareDelegate shareDelegate = mShareDelegateSupplier.get();
+        Tab tab = mActivityTabProvider.get();
+
+        if (shareDelegate == null || tab == null) return;
+
+        if (shareDirectly) {
+            RecordUserAction.record("MobileMenuDirectShare");
+            new UkmRecorder(tab.getWebContents(), "MobileMenu.DirectShare")
+                    .addBooleanMetric("HasOccurred")
+                    .record();
+        } else {
+            RecordUserAction.record("MobileMenuShare");
+            new UkmRecorder(tab.getWebContents(), "MobileMenu.Share")
+                    .addBooleanMetric("HasOccurred")
+                    .record();
+        }
+        shareDelegate.share(tab, shareDirectly, ShareOrigin.OVERFLOW_MENU);
+    }
+
+    // MenuOrKeyboardActionHandler implementation
+
+    @Override
+    public boolean handleMenuOrKeyboardAction(int id, boolean fromMenu) {
+        if (id == R.id.show_menu && mAppMenuCoordinator != null) {
+            mAppMenuCoordinator.showAppMenuForKeyboardEvent();
+            return true;
+        } else if (id == R.id.find_in_page_id) {
+            Tab tab = mActivityTabProvider.get();
+            // PDF pages require Android pdf viewer API to "find in page".
+            if (tab != null && tab.isNativePage() && tab.getNativePage().isPdf()) {
+                NativePage pdfPage = tab.getNativePage();
+                assert pdfPage instanceof PdfPage;
+                return ((PdfPage) pdfPage).findInPage();
+            }
+
+            if (mFindToolbarManager == null) return false;
+
+            mFindToolbarManager.showToolbar();
+
+            if (fromMenu) {
+                RecordUserAction.record("MobileMenuFindInPage");
+                new UkmRecorder(tab.getWebContents(), "MobileMenu.FindInPage")
+                        .addBooleanMetric("HasOccurred")
+                        .record();
+            } else {
+                RecordUserAction.record("MobileShortcutFindInPage");
+            }
+            return true;
+        } else if (id == R.id.share_menu_id || id == R.id.direct_share_menu_id) {
+            onShareMenuItemSelected(
+                    id == R.id.direct_share_menu_id,
+                    mTabModelSelectorSupplier.get().isIncognitoSelected());
+            return true;
+        } else if (id == R.id.paint_preview_show_id) {
+            DemoPaintPreview.showForTab(mActivityTabProvider.get());
+            return true;
+        } else if (id == R.id.get_image_descriptions_id) {
+            ImageDescriptionsController.getInstance()
+                    .onImageDescriptionsMenuItemSelected(
+                            mActivity,
+                            mModalDialogManagerSupplier.get(),
+                            mActivityTabProvider.get().getWebContents());
+            return true;
+        } else if (id == R.id.page_zoom_id) {
+            Tab tab = mActivityTabProvider.get();
+            TrackerFactory.getTrackerForProfile(tab.getProfile())
+                    .notifyEvent(EventConstants.PAGE_ZOOM_OPENED);
+            mPageZoomCoordinator.show(tab.getWebContents());
+        } else if (id == R.id.open_with_id) {
+            Tab tab = mActivityTabProvider.get();
+            assert tab != null && tab.isNativePage() && tab.getNativePage() instanceof PdfPage;
+            Uri uri = ((PdfPage) tab.getNativePage()).getUri();
+            if (uri == null
+                    || !DownloadUtils.openFileWithExternalApps(
+                            uri.toString(),
+                            MimeTypeUtils.PDF_MIME_TYPE,
+                            /* originalUrl= */ null,
+                            /* referrer= */ null,
+                            mActivity,
+                            OpenWithExternalAppsSource.APP_MENU)) {
+                Toast.makeText(
+                                mActivity,
+                                mActivity.getString(R.string.download_cant_open_file),
+                                Toast.LENGTH_SHORT)
+                        .show();
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    // AppMenuBlocker implementation
+
+    @Override
+    public boolean canShowAppMenu() {
+        // TODO(https:crbug.com/931496): Eventually the ContextualSearchManager,
+        // EphemeralTabCoordinator, and FindToolbarManager will all be owned by this class.
+
+        // Do not show the menu if Contextual Search panel is opened.
+        if (mContextualSearchManagerSupplier.get() != null
+                && mContextualSearchManagerSupplier.get().isSearchPanelOpened()) {
+            return false;
+        }
+
+        // Do not show the menu if we are in find in page view.
+        if (mFindToolbarManager != null
+                && mFindToolbarManager.isShowing()
+                && !DeviceFormFactor.isNonMultiDisplayContextOnTablet(mActivity)) {
+            return false;
+        }
+
+        return true;
+    }
+
+    // WindowFocusChangedObserver implementation
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        if (!hasFocus && mPageZoomCoordinator != null) {
+            // If the window loses focus, dismiss the slider so two windows cannot modify the same
+            // value simultaneously.
+            mPageZoomCoordinator.hide();
+        }
+    }
+
+    // Protected class methods
+    protected void onLayoutManagerAvailable(LayoutManagerImpl layoutManager) {
+        mLayoutManager = layoutManager;
+        if (mOverlayPanelManager != null) {
+            mOverlayPanelManager.removeObserver(mOverlayPanelManagerObserver);
+        }
+        mOverlayPanelManager = layoutManager.getOverlayPanelManager();
+
+        if (mOverlayPanelManagerObserver == null) {
+            mOverlayPanelManagerObserver =
+                    new OverlayPanelManager.OverlayPanelManagerObserver() {
+                        @Override
+                        public void onOverlayPanelShown() {
+                            if (mFindToolbarManager != null) {
+                                mFindToolbarManager.hideToolbar(false);
+                            }
+
+                            if (mPageZoomCoordinator != null) {
+                                // On show overlay panel, hide page zoom dialog
+                                mPageZoomCoordinator.hide();
+                            }
+                        }
+
+                        @Override
+                        public void onOverlayPanelHidden() {}
+                    };
+        }
+
+        mOverlayPanelManager.addObserver(mOverlayPanelManagerObserver);
+    }
+
+    protected AdaptiveToolbarBehavior createAdaptiveToolbarBehavior(
+            Supplier<Tracker> trackerSupplier) {
+        assert false : "Should be overriden by an inherited class.";
+        return null;
+    }
+
+    /**
+     * Constructs {@link ToolbarManager} and the handler necessary for controlling the menu on the
+     * {@link Toolbar}.
+     */
+    protected void initializeToolbar() {
+        try (TraceEvent te = TraceEvent.scoped("RootUiCoordinator.initializeToolbar")) {
+            final View controlContainer = mActivity.findViewById(R.id.control_container);
+            assert controlContainer != null;
+            ToolbarControlContainer toolbarContainer = (ToolbarControlContainer) controlContainer;
+            Callback<Boolean> urlFocusChangedCallback =
+                    hasFocus -> {
+                        if (mOnOmniboxFocusChangedListener != null) {
+                            mOnOmniboxFocusChangedListener.onResult(hasFocus);
+                        }
+                        if (mMessageQueueMediator != null) {
+                            mMessageQueueMediator.onUrlFocusChange(hasFocus);
+                        }
+                        mOmniboxFocusStateSupplier.set(hasFocus);
+                    };
+            if (getDesktopWindowStateManager() != null) {
+                toolbarContainer.setAppInUnfocusedDesktopWindow(
+                        getDesktopWindowStateManager().isInUnfocusedDesktopWindow());
+            }
+
+            Supplier<Tracker> trackerSupplier =
+                    () -> {
+                        Profile profile = mProfileSupplier.get();
+                        return profile == null
+                                ? null
+                                : TrackerFactory.getTrackerForProfile(profile);
+                    };
+            mAdaptiveToolbarUiCoordinator =
+                    new AdaptiveToolbarUiCoordinator(
+                            mActivity, mActivityTabProvider, mModalDialogManagerSupplier);
+
+            mAdaptiveToolbarUiCoordinator.initialize(
+                    createAdaptiveToolbarBehavior(trackerSupplier),
+                    mActivityLifecycleDispatcher,
+                    mTabModelSelectorSupplier,
+                    getBottomSheetController(),
+                    mSnackbarManagerSupplier,
+                    mTabBookmarkerSupplier,
+                    mProfileSupplier,
+                    mBookmarkModelSupplier,
+                    mReadAloudControllerSupplier,
+                    mShareDelegateSupplier,
+                    /* onShareRunnable= */ () ->
+                            mToolbarManager.setUrlBarFocus(false, OmniboxFocusReason.UNFOCUS),
+                    mWindowAndroid,
+                    trackerSupplier,
+                    this::getScrimManager);
+
+            var omniboxActionDelegate =
+                    new OmniboxActionDelegateImpl(
+                            mActivity,
+                            mActivityTabProvider,
+                            // TODO(ender): phase out callbacks when the modules below are
+                            // components.
+                            // Open URL in an existing, else new regular tab.
+                            url -> {
+                                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
+                                intent.setComponent(
+                                        new ComponentName(mActivity, ChromeLauncherActivity.class));
+                                intent.putExtra(
+                                        WebappConstants.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB, true);
+                                mActivity.startActivity(intent);
+                            },
+                            // Open Incognito Tab callback:
+                            () -> {
+                                mActivity.startActivity(
+                                        IntentHandler.createTrustedOpenNewTabIntent(
+                                                mActivity, true));
+                            },
+                            // Open Password Settings callback:
+                            () -> {
+                                PasswordManagerLauncher.showPasswordSettings(
+                                        mActivity,
+                                        mProfileSupplier.get(),
+                                        ManagePasswordsReferrer.CHROME_SETTINGS,
+                                        mModalDialogManagerSupplier,
+                                        /* managePasskeys= */ false);
+                            },
+                            // Open Quick Delete Dialog callback:
+                            () -> {
+                                new QuickDeleteController(
+                                        mActivity,
+                                        new QuickDeleteDelegateImpl(
+                                                mProfileSupplier, mTabSwitcherSupplier),
+                                        mModalDialogManagerSupplier.get(),
+                                        mSnackbarManagerSupplier.get(),
+                                        mLayoutManager,
+                                        mTabModelSelectorSupplier.get(),
+                                        ArchivedTabModelOrchestrator.getForProfile(
+                                                        mProfileSupplier.get())
+                                                .getTabModelSelector());
+                            });
+
+            mToolbarManager =
+                    new ToolbarManager(
+                            mActivity,
+                            mBottomControlsStacker,
+                            mBrowserControlsManager,
+                            mFullscreenManager,
+                            mEdgeToEdgeControllerSupplier,
+                            toolbarContainer,
+                            mCompositorViewHolderSupplier.get(),
+                            urlFocusChangedCallback,
+                            mTopUiThemeColorProvider,
+                            mTabObscuringHandlerSupplier.get(),
+                            mShareDelegateSupplier,
+                            mAdaptiveToolbarUiCoordinator.getButtonDataProviders(),
+                            mActivityTabProvider,
+                            mScrimManager,
+                            mActionModeControllerCallback,
+                            mFindToolbarManager,
+                            mProfileSupplier,
+                            mBookmarkModelSupplier,
+                            mLayoutStateProviderOneShotSupplier,
+                            mAppMenuSupplier,
+                            canShowMenuUpdateBadge(),
+                            mTabModelSelectorSupplier,
+                            mOmniboxFocusStateSupplier,
+                            mPromoShownOneshotSupplier,
+                            mWindowAndroid,
+                            mIsInOverviewModeSupplier,
+                            mModalDialogManagerSupplier,
+                            mStatusBarColorController,
+                            mAppMenuDelegate,
+                            mActivityLifecycleDispatcher,
+                            mBottomSheetController,
+                            getDataSharingTabManager(),
+                            mTabContentManagerSupplier.get(),
+                            mTabCreatorManagerSupplier.get(),
+                            getMerchantTrustSignalsCoordinatorSupplier(),
+                            omniboxActionDelegate,
+                            mEphemeralTabCoordinatorSupplier,
+                            mInitializeUiWithIncognitoColors,
+                            mBackPressManager,
+                            mOverviewColorSupplier,
+                            mReadAloudControllerSupplier,
+                            getDesktopWindowStateManager());
+            if (!mSupportsAppMenuSupplier.getAsBoolean()) {
+                mToolbarManager.getToolbar().disableMenuButton();
+            }
+
+            var voiceButtonController =
+                    mAdaptiveToolbarUiCoordinator.getVoiceToolbarButtonController();
+            var voiceRecognitionHandler = mToolbarManager.getVoiceRecognitionHandler();
+            if (voiceButtonController != null && voiceRecognitionHandler != null) {
+                mMicStateObserver = voiceButtonController::updateMicButtonState;
+                voiceRecognitionHandler.addObserver(mMicStateObserver);
+            }
+            mToolbarManagerOneshotSupplier.set(mToolbarManager);
+        }
+    }
+
+    protected void addVoiceSearchAdaptiveButton(Supplier<Tracker> trackerSupplier) {
+        mAdaptiveToolbarUiCoordinator.addVoiceSearchAdaptiveButton(
+                () -> mToolbarManager.getVoiceRecognitionHandler(), trackerSupplier);
+    }
+
+    /**
+     * Constructs a {@link ScrimManager} and sets up observers. Lifetime of all these objects should
+     * match.
+     */
+    protected ScrimManager buildScrimWidget() {
+        ViewGroup coordinator = mActivity.findViewById(R.id.coordinator);
+        ScrimManager scrimManager = new ScrimManager(mActivity, coordinator);
+        scrimManager
+                .getStatusBarColorSupplier()
+                .addObserver(RootUiCoordinator.this::onScrimColorChanged);
+        return scrimManager;
+    }
+
+    protected void onScrimColorChanged(@ColorInt int scrimColor) {
+        mStatusBarColorController.setScrimColor(scrimColor);
+    }
+
+    protected void setLayoutStateProvider(LayoutStateProvider layoutStateProvider) {
+        assert layoutStateProvider != null;
+        assert mLayoutStateProvider == null : "The LayoutStateProvider should set at most once.";
+
+        mLayoutStateProvider = layoutStateProvider;
+        mLayoutStateObserver =
+                new LayoutStateProvider.LayoutStateObserver() {
+                    @Override
+                    public void onStartedShowing(int layoutType) {
+                        if (layoutType != LayoutType.BROWSING
+                                && layoutType != LayoutType.SIMPLE_ANIMATION) {
+                            // Hide contextual search.
+                            if (mContextualSearchManagerSupplier.get() != null) {
+                                mContextualSearchManagerSupplier.get().dismissContextualSearchBar();
+                            }
+                        }
+
+                        if (layoutType == LayoutType.TAB_SWITCHER) {
+                            // Hide find toolbar and app menu.
+                            if (mFindToolbarManager != null) mFindToolbarManager.hideToolbar();
+                            hideAppMenu();
+                            // Attempt to show the promo sheet for the restore tabs feature.
+                            // Do not attempt to show the promo if in incognito mode.
+                            if (!mTabModelSelectorSupplier.get().isIncognitoSelected()) {
+                                // TODO(crbug.com/40274033): Add support for triggering in incognito
+                                // mode.
+                                attemptToShowRestoreTabsPromo();
+                            }
+                        }
+                    }
+
+                    @Override
+                    public void onFinishedShowing(int layoutType) {
+                        if (layoutType == LayoutType.TAB_SWITCHER) {
+                            // Ideally we wouldn't allow the app menu to show while animating the
+                            // overview mode. This is hard to track, however, because in some
+                            // instances #onOverviewModeStartedShowing is called after
+                            // #onOverviewModeFinishedShowing (see https://crbug.com/969047).
+                            // Once that bug is fixed, we can remove this call to hide in favor of
+                            // disallowing app menu shows during animation. Alternatively, we
+                            // could expose a way to query whether an animation is in progress.
+                            hideAppMenu();
+                        }
+                    }
+
+                    @Override
+                    public void onStartedHiding(int layoutType) {
+                        if (layoutType == LayoutType.TAB_SWITCHER) {
+                            hideAppMenu();
+                        }
+                    }
+
+                    @Override
+                    public void onFinishedHiding(int layoutType) {
+                        if (layoutType != LayoutType.TAB_SWITCHER) {
+                            hideAppMenu();
+                        }
+                    }
+                };
+        mLayoutStateProvider.addObserver(mLayoutStateObserver);
+    }
+
+    private void initAppMenu() {
+        // TODO(crbug.com/40613711): Revisit this as part of the broader
+        // discussion around activity-specific UI customizations.
+        if (mSupportsAppMenuSupplier.getAsBoolean()) {
+            mAppMenuCoordinator =
+                    AppMenuCoordinatorFactory.createAppMenuCoordinator(
+                            mActivity,
+                            mActivityLifecycleDispatcher,
+                            mToolbarManager,
+                            mAppMenuDelegate,
+                            mActivity.getWindow().getDecorView(),
+                            mActivity
+                                    .getWindow()
+                                    .getDecorView()
+                                    .findViewById(R.id.menu_anchor_stub),
+                            this::getAppRectOnScreen,
+                            mWindowAndroid,
+                            mBrowserControlsManager);
+            AppMenuCoordinatorFactory.setExceptionReporter(
+                    ChromePureJavaExceptionReporter::reportJavaException);
+
+            mAppMenuCoordinator.registerAppMenuBlocker(this);
+            mAppMenuCoordinator.registerAppMenuBlocker(mAppMenuBlocker);
+
+            mAppMenuSupplier.set(mAppMenuCoordinator);
+
+            mAppMenuObserver =
+                    new AppMenuObserver() {
+                        @Override
+                        public void onMenuVisibilityChanged(boolean isVisible) {
+                            if (isVisible && mPageZoomCoordinator != null) {
+                                // On show app menu, hide page zoom dialog
+                                mPageZoomCoordinator.hide();
+                            }
+                        }
+
+                        @Override
+                        public void onMenuHighlightChanged(boolean highlighting) {}
+                    };
+            mAppMenuCoordinator.getAppMenuHandler().addObserver(mAppMenuObserver);
+        }
+    }
+
+    /** Returns {@link Rect} that represents the app client area the app menu should fit in. */
+    protected Rect getAppRectOnScreen() {
+        Rect appRect = new Rect();
+        mActivity.getWindow().getDecorView().getWindowVisibleDisplayFrame(appRect);
+        return appRect;
+    }
+
+    private void hideAppMenu() {
+        if (mAppMenuCoordinator != null) mAppMenuCoordinator.getAppMenuHandler().hideAppMenu();
+    }
+
+    private void initFindToolbarManager() {
+        if (!mSupportsFindInPageSupplier.getAsBoolean()) return;
+
+        int stubId = R.id.find_toolbar_stub;
+        if (DeviceFormFactor.isNonMultiDisplayContextOnTablet(mActivity)) {
+            stubId = R.id.find_toolbar_tablet_stub;
+        }
+        mFindToolbarManager =
+                new FindToolbarManager(
+                        mActivity.findViewById(stubId),
+                        mTabModelSelectorSupplier.get(),
+                        mWindowAndroid,
+                        mActionModeControllerCallback,
+                        mBackPressManager);
+
+        mFindToolbarObserver =
+                new FindToolbarObserver() {
+                    @Override
+                    public void onFindToolbarShown() {
+                        RootUiCoordinator.this.onFindToolbarShown();
+                    }
+
+                    @Override
+                    public void onFindToolbarHidden() {
+                        RootUiCoordinator.this.onFindToolbarHidden();
+                    }
+                };
+
+        mFindToolbarManager.addObserver(mFindToolbarObserver);
+    }
+
+    /**
+     * Called when the find in page toolbar is shown. Sub-classes may override to manage
+     * cross-feature interaction, e.g. hide other features when this feature is shown.
+     */
+    protected void onFindToolbarShown() {
+        if (mContextualSearchManagerSupplier.get() != null) {
+            mContextualSearchManagerSupplier
+                    .get()
+                    .hideContextualSearch(OverlayPanel.StateChangeReason.UNKNOWN);
+        }
+    }
+
+    /**
+     * Called when the find in page toolbar is shown. Sub-classes may override to manage
+     * cross-feature interaction, e.g. hide other features when this feature is shown.
+     */
+    protected void onFindToolbarHidden() {}
+
+    /**
+     * @return Whether the "update available" badge can be displayed on menu button(s) in the
+     *     context of this coordinator's UI.
+     */
+    protected boolean canShowMenuUpdateBadge() {
+        return false;
+    }
+
+    /**
+     * Whether the top toolbar theme color provider should allow using the web pages theme if the
+     * device is in night mode.
+     */
+    protected boolean shouldAllowThemingInNightMode() {
+        return false;
+    }
+
+    /** Whether the top toolbar theme color provider should allow bright theme colors. */
+    protected boolean shouldAllowBrightThemeColors() {
+        return false;
+    }
+
+    /**
+     * Initialize the {@link BottomSheetController}. The view for this component is not created
+     * until content is requested in the sheet.
+     */
+    private void initializeBottomSheetController() {
+        // TODO(crbug.com/40135254): Componentize SnackbarManager so BottomSheetController can own
+        // this.
+        Callback<View> sheetInitializedCallback =
+                (view) -> {
+                    mBottomSheetSnackbarManager =
+                            new SnackbarManager(
+                                    mActivity,
+                                    view.findViewById(R.id.bottom_sheet_snackbar_container),
+                                    mWindowAndroid);
+                };
+
+        Supplier<OverlayPanelManager> panelManagerSupplier =
+                () -> {
+                    if (mCompositorViewHolderSupplier.get() != null
+                            && mCompositorViewHolderSupplier.get().getLayoutManager() != null) {
+                        return mCompositorViewHolderSupplier
+                                .get()
+                                .getLayoutManager()
+                                .getOverlayPanelManager();
+                    }
+                    return null;
+                };
+
+        // TODO(crbug.com/40135255): Initialize after inflation so we don't need to pass in view
+        // suppliers.
+        mBottomSheetController =
+                BottomSheetControllerFactory.createBottomSheetController(
+                        () -> mScrimManager,
+                        sheetInitializedCallback,
+                        mActivity.getWindow(),
+                        mWindowAndroid.getKeyboardDelegate(),
+                        () -> mActivity.findViewById(R.id.sheet_container),
+                        () -> {
+                            return mEdgeToEdgeControllerSupplier.get() == null
+                                    ? 0
+                                    : mEdgeToEdgeControllerSupplier.get().getBottomInset();
+                        },
+                        getDesktopWindowStateManager());
+        BottomSheetControllerFactory.setExceptionReporter(
+                ChromePureJavaExceptionReporter::reportJavaException);
+        BottomSheetControllerFactory.attach(mWindowAndroid, mBottomSheetController);
+
+        mBottomSheetManager =
+                new BottomSheetManager(
+                        mBottomSheetController,
+                        mActivityTabProvider,
+                        mBrowserControlsManager,
+                        mExpandedBottomSheetHelper,
+                        this::getBottomSheetSnackbarManager,
+                        mOmniboxFocusStateSupplier,
+                        panelManagerSupplier,
+                        mLayoutStateProviderOneShotSupplier);
+
+        // TODO(crbug.com/40208738): Consider moving handler registration to feature code.
+        assert mBackPressManager != null
+                && !mBackPressManager.has(BackPressHandler.Type.BOTTOM_SHEET);
+        BackPressHandler mBottomSheetBackPressHandler =
+                mBottomSheetController.getBottomSheetBackPressHandler();
+        if (mBottomSheetBackPressHandler != null) {
+            mBackPressManager.addHandler(
+                    mBottomSheetBackPressHandler, BackPressHandler.Type.BOTTOM_SHEET);
+        }
+    }
+
+    /**
+     * @return whether the Android Edge To Edge Feature is supported for the current activity.
+     */
+    protected boolean supportsEdgeToEdge() {
+        return false;
+    }
+
+    /** Setup drawing using Android Edge-to-Edge. */
+    @CallSuper
+    protected void initializeEdgeToEdgeController() {
+        boolean eligible = EdgeToEdgeUtils.recordEligibility(mActivity);
+
+        UmaSessionStats.registerSyntheticFieldTrial(
+                "EdgeToEdgeChinEligibility", eligible ? "Eligible" : "Not Eligible");
+
+        if (supportsEdgeToEdge() && EdgeToEdgeUtils.isEdgeToEdgeBottomChinEnabled()) {
+            mEdgeToEdgeController =
+                    EdgeToEdgeControllerFactory.create(
+                            mActivity,
+                            mWindowAndroid,
+                            mActivityTabProvider,
+                            mEdgeToEdgeManager,
+                            mBrowserControlsManager,
+                            mLayoutManagerSupplier,
+                            mFullscreenManager);
+            mEdgeToEdgeControllerSupplier.set(mEdgeToEdgeController);
+            mEdgeToEdgeBottomChin = createEdgeToEdgeBottomChin();
+        }
+    }
+
+    /** Create a bottom chin for Edge-to-Edge. */
+    protected Destroyable createEdgeToEdgeBottomChin() {
+        return null;
+    }
+
+    /**
+     * TODO(jinsukkim): remove/hide this in favor of wiring it directly.
+     *
+     * @return {@link TabObscuringHandler} object.
+     */
+    public TabObscuringHandler getTabObscuringHandler() {
+        return mTabObscuringHandlerSupplier.get();
+    }
+
+    /** @return The {@link BottomSheetController} for this activity. */
+    public ManagedBottomSheetController getBottomSheetController() {
+        return mBottomSheetController;
+    }
+
+    /**
+     * @return Supplies the {@link EphemeralTabCoordinator}
+     */
+    public Supplier<EphemeralTabCoordinator> getEphemeralTabCoordinatorSupplier() {
+        return mEphemeralTabCoordinatorSupplier;
+    }
+
+    /**
+     * @return The {@link FindToolbarManager} controlling find toolbar.
+     */
+    public @Nullable FindToolbarManager getFindToolbarManager() {
+        return mFindToolbarManager;
+    }
+
+    /**
+     * @return {@link ComposedBrowserControlsVisibilityDelegate} object for tabbed activity.
+     */
+    public ComposedBrowserControlsVisibilityDelegate getAppBrowserControlsVisibilityDelegate() {
+        if (mAppBrowserControlsVisibilityDelegate == null) {
+            mAppBrowserControlsVisibilityDelegate = new ComposedBrowserControlsVisibilityDelegate();
+        }
+        return mAppBrowserControlsVisibilityDelegate;
+    }
+
+    /**
+     * Gets the browser controls manager, creates it unless already created.
+     *
+     * @deprecated Instead, inject this directly to your constructor. If that's not possible, then
+     *     use {@link BrowserControlsManagerSupplier}.
+     */
+    @NonNull
+    @Deprecated
+    public BrowserControlsManager getBrowserControlsManager() {
+        return mBrowserControlsManager;
+    }
+
+    /** Returns the {@link ScrimManager} to control scrims over the activity. */
+    public ScrimManager getScrimManager() {
+        return mScrimManager;
+    }
+
+    /** @return The {@link SnackbarManager} for the {@link BottomSheetController}. */
+    public SnackbarManager getBottomSheetSnackbarManager() {
+        return mBottomSheetSnackbarManager;
+    }
+
+    /**
+     * Initializes a glue logic that suppresses Contextual Search and hides the Page Zoom slider
+     * while a Bottom Sheet feature is in action.
+     */
+    private void initBottomSheetObserver() {
+        if (mBottomSheetController == null) return;
+        mBottomSheetObserver =
+                new EmptyBottomSheetObserver() {
+                    private boolean mOpened;
+
+                    @Override
+                    public void onSheetStateChanged(int newState, int reason) {
+                        switch (newState) {
+                            case SheetState.PEEK:
+                            case SheetState.HALF:
+                            case SheetState.FULL:
+                                if (!mOpened) {
+                                    mOpened = true;
+                                    ContextualSearchManager manager =
+                                            mContextualSearchManagerSupplier.get();
+                                    if (manager != null) manager.onBottomSheetVisible(true);
+                                }
+
+                                // On visible bottom sheet, hide page zoom dialog
+                                mPageZoomCoordinator.hide();
+                                break;
+                            case SheetState.HIDDEN:
+                                mOpened = false;
+                                ContextualSearchManager manager =
+                                        mContextualSearchManagerSupplier.get();
+                                if (manager != null) manager.onBottomSheetVisible(false);
+                                break;
+                        }
+                    }
+                };
+        mBottomSheetController.addObserver(mBottomSheetObserver);
+    }
+
+    /** Initialize logic for hiding page zoom slider when snackbar is showing */
+    private void initSnackbarObserver() {
+        mSnackbarManagerSupplier
+                .get()
+                .isShowingSupplier()
+                .addObserver(
+                        (Boolean isShowing) -> {
+                            if (isShowing && mPageZoomCoordinator != null) {
+                                // On show snackbar, hide page zoom dialog
+                                mPageZoomCoordinator.hide();
+                            }
+                        });
+    }
+
+    /**
+     * Initialize logic for changing page zoom slider margins when browser bottom controls are
+     * showing
+     */
+    private void initBrowserControlsObserver() {
+        mBrowserControlsObserver =
+                new BrowserControlsStateProvider.Observer() {
+                    @Override
+                    public void onBottomControlsHeightChanged(
+                            int bottomControlsHeight, int bottomControlsMinHeight) {
+                        mPageZoomCoordinator.onBottomControlsHeightChanged(bottomControlsHeight);
+                    }
+                };
+        mBrowserControlsManager.addObserver(mBrowserControlsObserver);
+    }
+
+    public OneshotSupplier<IncognitoReauthController> getIncognitoReauthControllerSupplier() {
+        return mIncognitoReauthControllerOneshotSupplier;
+    }
+
+    /** Returns the supplier of {@link ReadAloudController}. */
+    @NonNull
+    public Supplier<ReadAloudController> getReadAloudControllerSupplier() {
+        return mReadAloudControllerSupplier;
+    }
+
+    /** Returns the {@link AppMenuHandler}. */
+    public @Nullable AppMenuHandler getAppMenuHandler() {
+        if (mAppMenuCoordinator != null) {
+            return mAppMenuCoordinator.getAppMenuHandler();
+        }
+        return null;
+    }
+
+    /** Saves the relevant UI state when the activity is recreated on a device fold transition. */
+    public void prepareUiState() {
+        mActivityRecreationController.prepareUiState();
+    }
+
+    /**
+     * Saves relevant information preserved by {@code RootUiCoordinator#prepareUiState()} to the
+     * saved instance state bundle that will be used to restore the UI state after the activity is
+     * recreated. This is expected to be invoked in {@code Activity#onSaveInstanceState(Bundle)}.
+     *
+     * @param outState The {@link Bundle} that is used to save state information.
+     */
+    public void onSaveInstanceState(Bundle outState) {
+        assert mTabModelSelectorSupplier.hasValue();
+        mActivityRecreationController.saveUiState(outState);
+    }
+
+    /**
+     * Restores the relevant UI state when the activity is recreated on a device fold transition.
+     *
+     * @param savedInstanceState The {@link Bundle} that is used to restore the UI state.
+     */
+    public void restoreUiState(Bundle savedInstanceState) {
+        mActivityRecreationController.restoreUiState(savedInstanceState);
+    }
+
+    private void attemptToShowRestoreTabsPromo() {
+        if (mRestoreTabsFeatureHelper == null) {
+            mRestoreTabsFeatureHelper = new RestoreTabsFeatureHelper();
+        }
+
+        Supplier<Integer> gtsTabListModelSizeSupplier =
+                () -> {
+                    if (mTabSwitcherSupplier.get() != null) {
+                        return mTabSwitcherSupplier.get().getTabSwitcherTabListModelSize();
+                    }
+                    return 0;
+                };
+
+        Callback<Integer> scrollGTSToRestoredTabsCallback =
+                (tabListModelSize) -> {
+                    if (mTabSwitcherSupplier.get() != null) {
+                        mTabSwitcherSupplier
+                                .get()
+                                .setTabSwitcherRecyclerViewPosition(
+                                        new RecyclerViewPosition(tabListModelSize, 0));
+                    }
+                };
+
+        mRestoreTabsFeatureHelper.maybeShowPromo(
+                mActivity,
+                mProfileSupplier.get(),
+                mTabCreatorManagerSupplier.get(),
+                getBottomSheetController(),
+                gtsTabListModelSizeSupplier,
+                scrollGTSToRestoredTabsCallback);
+    }
+
+    private void initBoardingPassDetector() {
+        if (ChromeFeatureList.isEnabled(ChromeFeatureList.BOARDING_PASS_DETECTOR)) {
+            mBoardingPassController = new BoardingPassController(mActivityTabProvider);
+        }
+    }
+
+    // Testing methods
+
+    public AppMenuCoordinator getAppMenuCoordinatorForTesting() {
+        return mAppMenuCoordinator;
+    }
+
+    public void destroyActivityForTesting() {
+        // Actually destroying or finishing the activity hinders the shutdown process after
+        // a test is done. Just null it out to give an effect of |onDestroy| being invoked.
+        mActivity = null;
+    }
+
+    public BottomControlsStacker getBottomControlsStackerForTesting() {
+        return mBottomControlsStacker;
+    }
+
+    public DataSharingTabManager getDataSharingTabManager() {
+        // This should only be called on an instance of TabbedRootUiCoordinator.
+        return null;
+    }
+
+    /** Returns the entry point for all scrim interactions. */
+    public ObservableSupplier<ScrimManager> getScrimManagerSupplier() {
+        return mScrimManagerSupplier;
+    }
+
+    /** Returns a supplier of the share delegate. */
+    public Supplier<ShareDelegate> getShareDelegateSupplier() {
+        return mShareDelegateSupplier;
+    }
+}
diff --git a/components/resources/default_100_percent/search_engine_choice/default_favicon.png b/components/resources/default_100_percent/search_engine_choice/default_favicon.png
new file mode 100644
index 0000000000000000000000000000000000000000..6533419f2d6b40f7735054dec62c51ddf1ee1201
GIT binary patch
literal 903
zcmV;219<$2P)<h;3K|Lk000e1NJLTq001xm001xu1^@s6R|5Hm0009{Nkl<Zc-rk*
zHI&>u5dJaD%uTpU6K1Ny)MmAo?2~ki?Li;rI(@haGcz+YGo$8ZtH|rstmUBf-W*z<
z`LqMyjQ;vbR=naxn4FxTa$SOo%Y^Yq3CiCp`IM5k@HhA$JOj`EJVrBqK*>90<Y$Z!
zD&E1~9|C4N=Y0}PoKKzZ=aBLV-UaWB-0*4BX4X}1up41G3JAO#bVTDWd3iku6Hh={
zlma?HmsR5(hfh(b^FD*}4@!0sS4zV2hPiHTHz{QUr=p@EW3ne<xuXf?=gfeJ_n_0B
z@lJY|QARx>G)Ly==Qj#^Pm*zg`6NIm=nm~RX-}Ss_k_usva+)JncnmH^XI=4jNih$
zlz0y|WF4^Se4bG8m@v`L_#mWg6DB6I3T(&-X<X(aWBDC2?f1MT|2uB(BxS%X1$a%k
z;1;{ldEPHo!pWN$|21g&X`3k)RVSdZ`1-to+dxbxpx11tSFj1eY4p>FfHecpOCzcg
zpNwb+@DsmO2`6iI0DN;)MGkB;0q{--kR#0r9={VIfOiJ&qgPlcQV0O=qNN%EZUkK2
zXVWfZ`h5{40I)Gg`DG2UD<uwqtRPHQ`3e=w!vhePgFgO88URJiY>`5mlRG3V0I)IO
z^!VFvHvp@&1;F!4TUc<Tw?P23{124aYG2{<#pZ1%U*J~{i~%4NJtI_HQU19p>56LN
z%3gt$n(-Z(idK@zIi#qli66~IxloAGzuNPP+NSLfTs{_pT7f^J06kI9KUZ>A$&#d(
z+ZUd3gy@cNAuWhQ3vePzWtVK-4H5_<h_y6oOLkRNRsEA)yhw>iqgo-eCg3jF08o2(
zV+xr@B`n6nQmpYnUx3CSsDwu5Yyvoe1poxnZ<>do)Aj_?EW-9wQ^cQO=(N_*SpEcF
zA!n{N_=ZMrDQ)uj`{u@re$c++TFQW?-c&%T<H_NEl62(&6TL7nfTD(I>Jej=5G2dk
zc*-y0$13Q-mVE%=HZZcm54P~5#qa<$Vkc|B{qUnj<Z#y}04P$B=OI-_I^4yL*CEaE
zjS0pJfK7T{VJFY4st5f9G(|wnQru>jUSTzPpE5qa;Lv>bM_w_-mwYy_S=Aoxnl--Y
d#;<tA>kFnu^?NN9uE_uZ002ovPDHLkV1m60sc!%P

literal 0
HcmV?d00001

diff --git a/components/resources/search_engine_choice_scaled_resources.grdp b/components/resources/search_engine_choice_scaled_resources.grdp
--- a/components/resources/search_engine_choice_scaled_resources.grdp
+++ b/components/resources/search_engine_choice_scaled_resources.grdp
@@ -5,6 +5,7 @@
   <if expr="_google_chrome">
     <structure type="chrome_scaled_image" name="IDR_GOOGLE_COM_PNG" file="google_chrome/google_search_logo.png" />
   </if>
+  <structure type="chrome_scaled_image" name="IDR_GOOGLEEN_PNG" file="search_engine_choice/default_favicon.png" />
   <structure type="chrome_scaled_image" name="IDR_AR_YAHOO_COM_PNG" file="search_engine_choice/yahoo_com.png" />
   <structure type="chrome_scaled_image" name="IDR_AT_YAHOO_COM_PNG" file="search_engine_choice/yahoo_com.png" />
   <structure type="chrome_scaled_image" name="IDR_AU_YAHOO_COM_PNG" file="search_engine_choice/yahoo_com.png" />
diff --git a/components/search_engines/BUILD.gn b/components/search_engines/BUILD.gn
--- a/components/search_engines/BUILD.gn
+++ b/components/search_engines/BUILD.gn
@@ -73,6 +73,7 @@ static_library("search_engines") {
     "//third_party/omnibox_proto",
     "//third_party/search_engines_data:prepopulated_engines",
     "//third_party/search_engines_data:regional_settings",
+    "cromite:cromite_prepopulated_engines",
   ]
 
   deps = [
@@ -159,6 +160,7 @@ source_set("search_engine_utils") {
     ":search_engine_type",
     "//components/google/core/common",
     "//third_party/search_engines_data:prepopulated_engines",
+    "cromite:cromite_prepopulated_engines",
   ]
 
   deps = [ "//url" ]
@@ -242,6 +244,7 @@ source_set("unit_tests") {
     "//testing/gmock",
     "//testing/gtest",
     "//third_party/search_engines_data:prepopulated_engines",
+    "cromite:cromite_prepopulated_engines",
     "//ui/base",
     "//url",
   ]
diff --git a/components/search_engines/cromite/BUILD.gn b/components/search_engines/cromite/BUILD.gn
new file mode 100644
--- /dev/null
+++ b/components/search_engines/cromite/BUILD.gn
@@ -0,0 +1,12 @@
+import("//tools/json_to_struct/json_to_struct.gni")
+
+json_to_struct("cromite_prepopulated_engines") {
+  visibility = [ "//components/search_engines:*" ]
+
+  source = "cromite_prepopulated_engines.json"
+  schema_file = "//third_party/search_engines_data/prepopulated_engines_schema.json"
+  namespace = "TemplateURLPrepopulateData"
+  excludetype = true
+
+  deps = [ "//base" ]
+}
diff --git a/components/search_engines/cromite/cromite_prepopulated_engines.json b/components/search_engines/cromite/cromite_prepopulated_engines.json
new file mode 100644
--- /dev/null
+++ b/components/search_engines/cromite/cromite_prepopulated_engines.json
@@ -0,0 +1,37 @@
+{
+    "additionals_includes": {
+        "third_party/search_engines_data/resources/definitions/prepopulated_engines.h": ""
+    },
+    "elements": {
+        "duckduckgo_light": {
+            "name": "DuckDuckGo Light",
+            "keyword": "duckduckgo.com/lite",
+            "favicon_url": "https://duckduckgo.com/favicon.ico",
+            "search_url": "https://duckduckgo.com/lite/?q={searchTerms}",
+            "suggest_url": "https://duckduckgo.com/ac/?q={searchTerms}&type=list",
+            "type": "SEARCH_ENGINE_DUCKDUCKGOLIGHT",
+            "id": 12
+        },
+
+        "googleen": {
+            "name": "Google in English",
+            "keyword": "googleen",
+            "favicon_url": "https://www.google.com/favicon.ico",
+            "search_url": "{google:baseURL}search?q={searchTerms}&ie={inputEncoding}&hl=en",
+            "suggest_url": "{google:baseSuggestURL}search?client={google:suggestClient}&q={searchTerms}&hl=en",
+            "image_url": "{google:baseURL}searchbyimage/upload?hl=en",
+            "new_tab_url": "{google:baseURL}_/chrome/newtab?hl=en&ie={inputEncoding}",
+            "contextual_search_url": "{google:baseURL}_/contextualsearch?{google:contextualSearchVersion}{google:contextualSearchContextData}&hl=en",
+            "image_url_post_params": "encoded_image={google:imageThumbnail},image_url={google:imageURL},sbisrc={google:imageSearchSource},original_width={google:imageOriginalWidth},original_height={google:imageOriginalHeight}",
+            "alternate_urls": [
+              "{google:baseURL}?hl=en#q={searchTerms}",
+              "{google:baseURL}search?hl=en#q={searchTerms}",
+              "{google:baseURL}webhp?hl=en#q={searchTerms}",
+              "{google:baseURL}s?hl=en#q={searchTerms}",
+              "{google:baseURL}s?hl=en&q={searchTerms}"
+            ],
+            "type": "SEARCH_ENGINE_GOOGLE_EN",
+            "id": 13
+        }
+    }
+}
diff --git a/components/search_engines/search_engine_choice/search_engine_choice_utils.cc b/components/search_engines/search_engine_choice/search_engine_choice_utils.cc
--- a/components/search_engines/search_engine_choice/search_engine_choice_utils.cc
+++ b/components/search_engines/search_engine_choice/search_engine_choice_utils.cc
@@ -183,10 +183,7 @@ void RecordChoiceScreenDefaultSearchProviderType(
 }
 
 void RecordChoiceScreenSelectedIndex(int selected_engine_index) {
-  base::UmaHistogramExactLinear(
-      kSearchEngineChoiceScreenSelectedEngineIndexHistogram,
-      selected_engine_index,
-      TemplateURLPrepopulateData::kMaxEeaPrepopulatedEngines);
+  // do nothing in Cromite
 }
 
 void RecordChoiceScreenPositionsCountryMismatch(bool has_mismatch) {
diff --git a/components/search_engines/search_engine_type.h b/components/search_engines/search_engine_type.h
--- a/components/search_engines/search_engine_type.h
+++ b/components/search_engines/search_engine_type.h
@@ -97,11 +97,16 @@ enum SearchEngineType {
   SEARCH_ENGINE_MCAFEE = 77,
   SEARCH_ENGINE_FREESPOKE = 78,
   SEARCH_ENGINE_KAGI = 79,
+  SEARCH_ENGINE_GOOGLE_EN = 80,
+  SEARCH_ENGINE_DUCKDUCKGOLIGHT = 81,
 
   SEARCH_ENGINE_MAX  // Bounding value needed for UMA histogram macro.
 };
 // LINT.ThenChange(//tools/metrics/histograms/enums.xml:OmniboxSearchEngineType)
 
+static_assert(SEARCH_ENGINE_DUCKDUCKGOLIGHT == (SEARCH_ENGINE_MAX - 1),
+              "Please check this patch");
+
 // Enum to record the type of search engine a user used in keyword mode. This
 // should be kept aligned with the `OmniboxBuiltinEngineType` enum in enums.xml.
 // Entries should not be renumbered and numeric values should never be reused.
diff --git a/components/search_engines/template_url_prepopulate_data.cc b/components/search_engines/template_url_prepopulate_data.cc
--- a/components/search_engines/template_url_prepopulate_data.cc
+++ b/components/search_engines/template_url_prepopulate_data.cc
@@ -30,6 +30,8 @@
 #include "third_party/search_engines_data/resources/definitions/prepopulated_engines.h"
 #include "third_party/search_engines_data/resources/definitions/regional_settings.h"
 
+#include "components/search_engines/cromite/cromite_prepopulated_engines.h"
+
 namespace TemplateURLPrepopulateData {
 
 // Helpers --------------------------------------------------------------------
@@ -85,11 +87,10 @@ GetPrepopulatedEnginesForEeaRegionCountries(CountryId country_id,
   generator.seed(profile_seed);
   std::shuffle(t_urls.begin(), t_urls.end(), generator);
 
-  CHECK_LE(t_urls.size(), kMaxEeaPrepopulatedEngines);
   return t_urls;
 }
 
-std::vector<std::unique_ptr<TemplateURLData>> GetPrepopulatedTemplateURLData(
+std::vector<std::unique_ptr<TemplateURLData>> GetPrepopulatedTemplateURLDataChromium(
     CountryId country_id,
     PrefService& prefs) {
   if (regional_capabilities::HasSearchEngineCountryListOverride()) {
@@ -115,6 +116,16 @@ std::vector<std::unique_ptr<TemplateURLData>> GetPrepopulatedTemplateURLData(
                         &PrepopulatedEngineToTemplateURLData);
 }
 
+std::vector<std::unique_ptr<TemplateURLData>> GetPrepopulatedTemplateURLData(
+    CountryId country_id,
+    PrefService& prefs) {
+  std::vector<std::unique_ptr<TemplateURLData>> t_urls =
+    GetPrepopulatedTemplateURLDataChromium(country_id, prefs);
+  t_urls.push_back(TemplateURLDataFromPrepopulatedEngine(googleen));
+  t_urls.push_back(TemplateURLDataFromPrepopulatedEngine(duckduckgo_light));
+  return t_urls;
+}
+
 // These values are persisted to logs. Entries should not be renumbered and
 // numeric values should never be reused.
 enum class SearchProviderOverrideStatus {
diff --git a/components/search_engines/template_url_prepopulate_data.h b/components/search_engines/template_url_prepopulate_data.h
--- a/components/search_engines/template_url_prepopulate_data.h
+++ b/components/search_engines/template_url_prepopulate_data.h
@@ -32,13 +32,6 @@ struct PrepopulatedEngine;
 
 extern const int kMaxPrepopulatedEngineID;
 
-// The maximum number of prepopulated search engines that can be returned in
-// any of the EEA countries by `GetPrepopulatedEngines()`.
-//
-// Note: If this is increased, please also increase the declared variant count
-// for the `Search.ChoiceScreenShowedEngineAt.Index{Index}` histogram.
-inline constexpr size_t kMaxEeaPrepopulatedEngines = 8;
-
 // The maximum number of prepopulated search engines that can be returned in
 // in the rest of the world by `GetPrepopulatedEngines()`.
 inline constexpr size_t kMaxRowPrepopulatedEngines = 5;
diff --git a/tools/json_to_struct/json_to_struct.gni b/tools/json_to_struct/json_to_struct.gni
--- a/tools/json_to_struct/json_to_struct.gni
+++ b/tools/json_to_struct/json_to_struct.gni
@@ -39,6 +39,11 @@ template("json_to_struct") {
   action_name = target_name + "_action"
   source_set_name = target_name
 
+  excludetype = false
+  if (defined(invoker.excludetype)) {
+    excludetype = invoker.excludetype
+  }
+
   action(action_name) {
     visibility = [ ":$source_set_name" ]
     script = "//tools/json_to_struct/json_to_struct.py"
@@ -61,6 +66,10 @@ template("json_to_struct") {
       "--namespace=" + invoker.namespace,
       "--schema=" + rebase_path(invoker.schema_file, root_build_dir),
     ]
+
+    if (excludetype) {
+      args += [ "--excludetype=yes" ]
+    }
   }
 
   source_set(source_set_name) {
diff --git a/tools/json_to_struct/json_to_struct.py b/tools/json_to_struct/json_to_struct.py
--- a/tools/json_to_struct/json_to_struct.py
+++ b/tools/json_to_struct/json_to_struct.py
@@ -100,7 +100,7 @@ def _GenerateHeaderGuard(h_filename):
   return re.sub(u'^_*', '', result) + u'_'  # Remove leading underscores.
 
 
-def _GenerateH(basepath, fileroot, head, namespace, schema, description):
+def _GenerateH(basepath, fileroot, head, namespace, schema, description, excludetype):
   """Generates the .h file containing the definition of the structure specified
   by the schema.
 
@@ -136,11 +136,15 @@ def _GenerateH(basepath, fileroot, head, namespace, schema, description):
       f.write(u'#include "%s"\n' % header)
     f.write(u'\n')
 
+    for header in description.get(u'additionals_includes', []):
+      f.write(u'#include "%s"\n' % header)
+    f.write(u'\n')
+
     if namespace:
       f.write(u'namespace %s {\n' % namespace)
       f.write(u'\n')
 
-    f.write(struct_generator.GenerateStruct(
+    f.write(struct_generator.GenerateStruct(excludetype,
       schema['type_name'], schema['schema']))
     f.write(u'\n')
 
@@ -175,7 +179,7 @@ def _GenerateH(basepath, fileroot, head, namespace, schema, description):
     f.write(u'#endif  // %s\n' % header_guard)
 
 
-def _GenerateCC(basepath, fileroot, head, namespace, schema, description):
+def _GenerateCC(basepath, fileroot, head, namespace, schema, description, excludetype):
   """Generates the .cc file containing the static initializers for the
   of the elements specified in the description.
 
@@ -210,7 +214,7 @@ def _GenerateCC(basepath, fileroot, head, namespace, schema, description):
     f.write(element_generator.GenerateElements(schema['type_name'],
         schema['schema'], description))
 
-    if not aggregation.export_items:
+    if excludetype == False and not aggregation.export_items:
       f.write('\n}  // anonymous namespace \n\n')
 
     if aggregation.kind == AggregationKind.ARRAY:
@@ -315,7 +319,7 @@ def GenerateClass(basepath,
 
 
 def GenerateStruct(basepath, output_root, namespace, schema, description,
-                   description_filename, schema_filename, year=None):
+                   description_filename, schema_filename, excludetype, year):
   """Generates a C++ struct from a JSON description.
 
   Args:
@@ -334,8 +338,8 @@ def GenerateStruct(basepath, output_root, namespace, schema, description,
   """
   year = int(year) if year else datetime.now().year
   head = HEAD % (year, schema_filename, description_filename)
-  _GenerateH(basepath, output_root, head, namespace, schema, description)
-  _GenerateCC(basepath, output_root, head, namespace, schema, description)
+  _GenerateH(basepath, output_root, head, namespace, schema, description, excludetype)
+  _GenerateCC(basepath, output_root, head, namespace, schema, description, excludetype)
 
 if __name__ == '__main__':
   parser = optparse.OptionParser(
@@ -350,11 +354,17 @@ if __name__ == '__main__':
   parser.add_option('-s', '--schema', help='path to the schema file, '
       'mandatory.')
   parser.add_option('-o', '--output', help='output filename, ')
+  parser.add_option('-x', '--excludetype', help='exclude type generator, ')
   (opts, args) = parser.parse_args()
 
   if not opts.schema:
     parser.error('You must specify a --schema.')
 
+  if not opts.excludetype:
+    opts.excludetype = False
+  else:
+    opts.excludetype = True
+
   description_filename = os.path.normpath(args[0])
   root, ext = os.path.splitext(description_filename)
   shortroot = opts.output if opts.output else os.path.split(root)[1]
@@ -371,4 +381,4 @@ if __name__ == '__main__':
   schema = _Load(opts.schema)
   description = _Load(description_filename)
   GenerateStruct(basepath, output_root, opts.namespace, schema, description,
-                 description_filename, opts.schema)
+                 description_filename, opts.schema, opts.excludetype, datetime.now().year)
diff --git a/tools/json_to_struct/struct_generator.py b/tools/json_to_struct/struct_generator.py
--- a/tools/json_to_struct/struct_generator.py
+++ b/tools/json_to_struct/struct_generator.py
@@ -30,20 +30,24 @@ def GenerateField(field_info):
   else:
     raise RuntimeError('Unknown field type "%s"' % type)
 
-def GenerateStruct(type_name, schema):
+def GenerateStruct(excludetype, type_name, schema):
   """Generate a string defining a structure containing the fields specified in
   the schema list.
   """
   lines = []
+  if excludetype:
+    lines.append('struct %s;' % type_name)
+    return '\n'.join(lines) + '\n'
+
   lines.append('struct %s {' % type_name)
   for field_info in schema:
     if field_info['type'] == 'struct':
-      lines.insert(0, GenerateStruct(field_info['type_name'],
+      lines.insert(0, GenerateStruct(excludetype, field_info['type_name'],
                                      field_info['fields']))
     elif (field_info['type'] == 'array'
           and field_info['contents']['type'] == 'struct'):
       contents = field_info['contents']
-      lines.insert(0, GenerateStruct(contents['type_name'],
+      lines.insert(0, GenerateStruct(excludetype, contents['type_name'],
                                      contents['fields']))
     lines.append('  ' + GenerateField(field_info) + ';')
   lines.append('};')
diff --git a/tools/variations/fieldtrial_to_struct.py b/tools/variations/fieldtrial_to_struct.py
--- a/tools/variations/fieldtrial_to_struct.py
+++ b/tools/variations/fieldtrial_to_struct.py
@@ -232,14 +232,14 @@ def main(arguments):
   json_to_struct.GenerateStruct(
       basepath, output_root, opts.namespace, schema, description,
       os.path.split(description_filename)[1], os.path.split(opts.schema)[1],
-      opts.year)
+      False, opts.year)
 
   # TODO(peilinwang) filter the schema by platform, form_factor, etc.
   if opts.java:
     json_to_struct.GenerateClass(basepath, output_root, opts.namespace, schema,
                                  description,
                                  os.path.split(description_filename)[1],
-                                 os.path.split(opts.schema)[1], opts.year)
+                                 os.path.split(opts.schema)[1], False, opts.year)
 
 
 if __name__ == '__main__':
-- 

