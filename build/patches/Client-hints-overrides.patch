From: csagan5 <32685696+csagan5@users.noreply.github.com>
Date: Thu, 22 Jul 2021 23:10:52 +0200
Subject: Client hints overrides

Disable critical client hints and network early hints
Use Google Chrome branding for client hints

License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html

Change-Id: I85c134e85ede5ab1ad30643cb84b4c7f3aca08f7
---
 .../embedder_support/user_agent_utils.cc      |   4 +-
 content/browser/client_hints/client_hints.cc  |  17 +-
 .../loader/navigation_url_loader_impl.cc      |   5 +
 .../about_flags_cc/Client-hints-overrides.inc |   9 +
 .../features_cc/Client-hints-overrides.inc    |   1 +
 .../features_cc/Client-hints-overrides.inc    |   1 +
 net/http/http_network_transaction.cc          |   1 +
 services/network/public/cpp/client_hints.cc   |   1 +
 .../blink/common/client_hints/client_hints.cc |   6 +-
 .../client_hints/enabled_client_hints.cc      |   4 +-
 .../renderer/core/frame/navigator_ua.idl      |   4 +-
 .../renderer/core/frame/navigator_ua_data.cc  |   1 +
 .../renderer/core/frame/navigator_ua_data.idl |   5 +-
 .../core/loader/base_fetch_context.cc         | 614 ++++++++++++++++++
 .../platform/runtime_enabled_features.json5   |   5 +
 15 files changed, 664 insertions(+), 14 deletions(-)
 create mode 100644 cromite_flags/chrome/browser/about_flags_cc/Client-hints-overrides.inc
 create mode 100644 cromite_flags/content/common/features_cc/Client-hints-overrides.inc
 create mode 100644 cromite_flags/services/network/public/cpp/features_cc/Client-hints-overrides.inc

diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -187,9 +187,7 @@ const blink::UserAgentBrandList GetUserAgentBrandList(
   bool parse_result = base::StringToInt(major_version, &major_version_number);
   DCHECK(parse_result);
   std::optional<std::string> brand;
-#if !BUILDFLAG(CHROMIUM_BRANDING)
-  brand = version_info::GetProductName();
-#endif
+  brand = "Google Chrome";
   std::optional<std::string> maybe_brand_override =
       base::GetFieldTrialParamValueByFeature(features::kGreaseUACH,
                                              "brand_override");
diff --git a/content/browser/client_hints/client_hints.cc b/content/browser/client_hints/client_hints.cc
--- a/content/browser/client_hints/client_hints.cc
+++ b/content/browser/client_hints/client_hints.cc
@@ -60,6 +60,7 @@
 #include "third_party/blink/public/common/permissions_policy/origin_with_possible_wildcards.h"
 #include "third_party/blink/public/common/permissions_policy/permissions_policy.h"
 #include "third_party/blink/public/common/user_agent/user_agent_metadata.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
 #include "url/origin.h"
@@ -521,7 +522,8 @@ void AddPrefersReducedTransparencyHeader(net::HttpRequestHeaders* headers,
                         : network::kPrefersReducedTransparencyNoPreference);
 }
 
-bool IsValidURLForClientHints(const url::Origin& origin) {
+bool IsValidURLForClientHints(const url::Origin& origin) { // disabled in Bromite
+  if ((true)) return false;
   return network::IsOriginPotentiallyTrustworthy(origin);
 }
 
@@ -722,7 +724,8 @@ void UpdateNavigationRequestClientUaHeadersImpl(
     // value, disable them. This overwrites previous decision from UI.
     disable_due_to_custom_ua = !ua_metadata.has_value();
   }
-
+  if (!blink::RuntimeEnabledFeatures::UserAgentClientHintEnabled())
+    disable_due_to_custom_ua = true;
   if (!disable_due_to_custom_ua) {
     if (!ua_metadata.has_value())
       ua_metadata = delegate->GetUserAgentMetadata();
@@ -904,10 +907,12 @@ void AddRequestClientHintsHeaders(
     AddEctHeader(headers, network_quality_tracker, url);
   }
 
-  UpdateNavigationRequestClientUaHeadersImpl(
-      delegate, is_ua_override_on, frame_tree_node,
-      ClientUaHeaderCallType::kDuringCreation, headers, container_policy,
-      request_url, data);
+  if (blink::RuntimeEnabledFeatures::UserAgentClientHintEnabled()) {
+    UpdateNavigationRequestClientUaHeadersImpl(
+        delegate, is_ua_override_on, frame_tree_node,
+        ClientUaHeaderCallType::kDuringCreation, headers, container_policy,
+        request_url, data);
+  }
 
   if (ShouldAddClientHint(data, WebClientHintsType::kPrefersColorScheme)) {
     AddPrefersColorSchemeHeader(headers, frame_tree_node);
diff --git a/content/browser/loader/navigation_url_loader_impl.cc b/content/browser/loader/navigation_url_loader_impl.cc
--- a/content/browser/loader/navigation_url_loader_impl.cc
+++ b/content/browser/loader/navigation_url_loader_impl.cc
@@ -1208,6 +1208,11 @@ void NavigationURLLoaderImpl::OnAcceptCHFrameReceived(
     return;
   }
 
+  if (!base::FeatureList::IsEnabled(network::features::kAcceptCHFrame)) {
+    std::move(callback).Run(net::OK);
+    return;
+  }
+
   LogAcceptCHFrameStatus(AcceptCHFrameRestart::kFramePresent);
 
   // Given that this is happening in the middle of navigation, there should
diff --git a/cromite_flags/chrome/browser/about_flags_cc/Client-hints-overrides.inc b/cromite_flags/chrome/browser/about_flags_cc/Client-hints-overrides.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/chrome/browser/about_flags_cc/Client-hints-overrides.inc
@@ -0,0 +1,9 @@
+#ifdef FLAG_SECTION
+
+    {"enable-ua-client-hint",
+     "Enable UA client hint",
+     "Allow sending base low entropy client hints as "
+     "UA, UAMobile and UAPlatform for compatibility", kOsAll,
+     FEATURE_VALUE_TYPE(blink::features::kUserAgentClientHint)},
+
+#endif
diff --git a/cromite_flags/content/common/features_cc/Client-hints-overrides.inc b/cromite_flags/content/common/features_cc/Client-hints-overrides.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/content/common/features_cc/Client-hints-overrides.inc
@@ -0,0 +1 @@
+SET_CROMITE_FEATURE_DISABLED(kCriticalClientHint);
diff --git a/cromite_flags/services/network/public/cpp/features_cc/Client-hints-overrides.inc b/cromite_flags/services/network/public/cpp/features_cc/Client-hints-overrides.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/services/network/public/cpp/features_cc/Client-hints-overrides.inc
@@ -0,0 +1 @@
+SET_CROMITE_FEATURE_DISABLED(kAcceptCHFrame);
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -108,6 +108,7 @@ const size_t kMaxRestarts = 32;
 
 // Returns true when Early Hints are allowed on the given protocol.
 bool EarlyHintsAreAllowedOn(HttpConnectionInfo connection_info) {
+  if ((true)) return false;
   switch (connection_info) {
     case HttpConnectionInfo::kHTTP0_9:
     case HttpConnectionInfo::kHTTP1_0:
diff --git a/services/network/public/cpp/client_hints.cc b/services/network/public/cpp/client_hints.cc
--- a/services/network/public/cpp/client_hints.cc
+++ b/services/network/public/cpp/client_hints.cc
@@ -120,6 +120,7 @@ const DecodeMap& GetDecodeMap() {
 
 std::optional<std::vector<network::mojom::WebClientHintsType>>
 ParseClientHintsHeader(const std::string& header) {
+  if ((true)) return std::nullopt;
   // Accept-CH is an sh-list of tokens; see:
   // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-structure-19#section-3.1
   std::optional<net::structured_headers::List> maybe_list =
diff --git a/third_party/blink/common/client_hints/client_hints.cc b/third_party/blink/common/client_hints/client_hints.cc
--- a/third_party/blink/common/client_hints/client_hints.cc
+++ b/third_party/blink/common/client_hints/client_hints.cc
@@ -14,6 +14,7 @@
 #include "base/strings/string_util.h"
 #include "services/network/public/cpp/client_hints.h"
 #include "third_party/blink/public/common/features.h"
+#include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/public/common/permissions_policy/permissions_policy.h"
 #include "url/origin.h"
 
@@ -106,11 +107,12 @@ const PolicyFeatureToClientHintMap& GetPolicyFeatureToClientHintMap() {
 
 bool IsClientHintSentByDefault(network::mojom::WebClientHintsType type) {
   switch (type) {
-    case network::mojom::WebClientHintsType::kSaveData:
     case network::mojom::WebClientHintsType::kUA:
     case network::mojom::WebClientHintsType::kUAMobile:
     case network::mojom::WebClientHintsType::kUAPlatform:
-      return true;
+      return RuntimeEnabledFeatures::UserAgentClientHintEnabled();
+    case network::mojom::WebClientHintsType::kSaveData:
+      return false;
     default:
       return false;
   }
diff --git a/third_party/blink/common/client_hints/enabled_client_hints.cc b/third_party/blink/common/client_hints/enabled_client_hints.cc
--- a/third_party/blink/common/client_hints/enabled_client_hints.cc
+++ b/third_party/blink/common/client_hints/enabled_client_hints.cc
@@ -15,6 +15,7 @@ namespace {
 using ::network::mojom::WebClientHintsType;
 
 bool IsDisabledByFeature(const WebClientHintsType type) {
+  if ((true)) return true;
   switch (type) {
     case WebClientHintsType::kUA:
     case WebClientHintsType::kUAArch:
@@ -96,7 +97,7 @@ bool IsDisabledByFeature(const WebClientHintsType type) {
 }  // namespace
 
 bool EnabledClientHints::IsEnabled(const WebClientHintsType type) const {
-  return enabled_types_[static_cast<int>(type)];
+  return false;
 }
 
 void EnabledClientHints::SetIsEnabled(const WebClientHintsType type,
@@ -107,6 +108,7 @@ void EnabledClientHints::SetIsEnabled(const WebClientHintsType type,
 
 std::vector<WebClientHintsType> EnabledClientHints::GetEnabledHints() const {
   std::vector<WebClientHintsType> hints;
+  if ((true)) return hints;
   for (const auto& elem : network::GetClientHintToNameMap()) {
     const auto& type = elem.first;
     if (IsEnabled(type))
diff --git a/third_party/blink/renderer/core/frame/navigator_ua.idl b/third_party/blink/renderer/core/frame/navigator_ua.idl
--- a/third_party/blink/renderer/core/frame/navigator_ua.idl
+++ b/third_party/blink/renderer/core/frame/navigator_ua.idl
@@ -4,6 +4,8 @@
 
 // https://github.com/WICG/ua-client-hints
 
-interface mixin NavigatorUA {
+[
+    RuntimeEnabled=UserAgentClientHint
+] interface mixin NavigatorUA {
   [SecureContext] readonly attribute NavigatorUAData userAgentData;
 };
diff --git a/third_party/blink/renderer/core/frame/navigator_ua_data.cc b/third_party/blink/renderer/core/frame/navigator_ua_data.cc
--- a/third_party/blink/renderer/core/frame/navigator_ua_data.cc
+++ b/third_party/blink/renderer/core/frame/navigator_ua_data.cc
@@ -219,6 +219,7 @@ ScriptPromise<UADataValues> NavigatorUAData::getHighEntropyValues(
   Dactyloscoper::RecordDirectSurface(
       GetExecutionContext(), WebFeature::kNavigatorUAData_Platform, platform());
 
+  if ((false))
   for (const String& hint : hints) {
     if (hint == "platformVersion") {
       values->setPlatformVersion(platform_version_);
diff --git a/third_party/blink/renderer/core/frame/navigator_ua_data.idl b/third_party/blink/renderer/core/frame/navigator_ua_data.idl
--- a/third_party/blink/renderer/core/frame/navigator_ua_data.idl
+++ b/third_party/blink/renderer/core/frame/navigator_ua_data.idl
@@ -4,7 +4,10 @@
 
 // https://github.com/WICG/ua-client-hints
 
-[Exposed=(Window,Worker)] interface NavigatorUAData {
+[
+    RuntimeEnabled=UserAgentClientHint,
+    Exposed=(Window,Worker)
+] interface NavigatorUAData {
   [HighEntropy, MeasureAs=NavigatorUAData_Brands] readonly attribute FrozenArray<NavigatorUABrandVersion> brands;
   [HighEntropy=Direct, MeasureAs=NavigatorUAData_Mobile]  readonly attribute boolean mobile;
   [HighEntropy=Direct, MeasureAs=NavigatorUAData_Platform] readonly attribute DOMString platform;
diff --git a/third_party/blink/renderer/core/loader/base_fetch_context.cc b/third_party/blink/renderer/core/loader/base_fetch_context.cc
--- a/third_party/blink/renderer/core/loader/base_fetch_context.cc
+++ b/third_party/blink/renderer/core/loader/base_fetch_context.cc
@@ -90,6 +90,580 @@ bool BaseFetchContext::CalculateIfAdSubresource(
          (filter && filter->IsAdResource(url, request.GetRequestContext()));
 }
 
+<<<<<<< HEAD
+||||||| parent of b424c435e5298 (Client hints overrides)
+// TODO(https://crbug.com/1469830) Refactor the strings into some sort of
+// context object
+void BaseFetchContext::AddClientHintsIfNecessary(
+    const ClientHintsPreferences& hints_preferences,
+    const url::Origin& resource_origin,
+    bool is_1p_origin,
+    std::optional<UserAgentMetadata> ua,
+    const PermissionsPolicy* policy,
+    base::optional_ref<const ClientHintImageInfo> image_info,
+    base::optional_ref<const WTF::AtomicString> prefers_color_scheme,
+    base::optional_ref<const WTF::AtomicString> prefers_reduced_motion,
+    base::optional_ref<const WTF::AtomicString> prefers_reduced_transparency,
+    ResourceRequest& request) {
+  // If the feature is enabled, then client hints are allowed only on secure
+  // URLs.
+  if (!ClientHintsPreferences::IsClientHintsAllowed(request.Url()))
+    return;
+
+  // Sec-CH-UA is special: we always send the header to all origins that are
+  // eligible for client hints (e.g. secure transport, JavaScript enabled).
+  //
+  // https://github.com/WICG/ua-client-hints
+  //
+  // One exception, however, is that a custom UA is sometimes set without
+  // specifying accomponying client hints, in which case we disable sending
+  // them.
+  using network::mojom::blink::WebClientHintsType;
+  if (ua) {
+    // ShouldSendClientHint is called to make sure UA is controlled by
+    // Permissions Policy.
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUA, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUA,
+                    AtomicString(ua->SerializeBrandMajorVersionList().c_str()),
+                    request);
+    }
+
+    // We also send Sec-CH-UA-Mobile to all hints. It is a one-bit header
+    // identifying if the browser has opted for a "mobile" experience.
+    // ShouldSendClientHint is called to make sure it's controlled by
+    // PermissionsPolicy.
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAMobile,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAMobile,
+                    SerializeBoolHeader(ua->mobile), request);
+    }
+  }
+
+  // If the frame is detached, then don't send any hints other than UA.
+  if (!policy)
+    return;
+
+  // The next 4 hints should be enabled if we're allowing legacy hints to third
+  // parties, or if PermissionsPolicy delegation says they are allowed.
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kDeviceMemory_DEPRECATED,
+                           hints_preferences)) {
+    SetHttpHeader(WebClientHintsType::kDeviceMemory_DEPRECATED,
+                  AtomicString(String::Number(
+                      ApproximatedDeviceMemory::GetApproximatedDeviceMemory())),
+                  request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kDeviceMemory,
+                           hints_preferences)) {
+    SetHttpHeader(WebClientHintsType::kDeviceMemory,
+                  AtomicString(String::Number(
+                      ApproximatedDeviceMemory::GetApproximatedDeviceMemory())),
+                  request);
+  }
+
+  // These hints only make sense if the image info is available
+  if (image_info.has_value()) {
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kDpr_DEPRECATED,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kDpr_DEPRECATED,
+                    AtomicString(String::Number(image_info->dpr)), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kDpr, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kDpr,
+                    AtomicString(String::Number(image_info->dpr)), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kViewportWidth_DEPRECATED,
+                             hints_preferences) &&
+        image_info->viewport_width) {
+      SetHttpHeader(
+          WebClientHintsType::kViewportWidth_DEPRECATED,
+          AtomicString(String::Number(image_info->viewport_width.value())),
+          request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kViewportWidth,
+                             hints_preferences) &&
+        image_info->viewport_width) {
+      SetHttpHeader(
+          WebClientHintsType::kViewportWidth,
+          AtomicString(String::Number(image_info->viewport_width.value())),
+          request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kViewportHeight,
+                             hints_preferences) &&
+        image_info->viewport_height) {
+      SetHttpHeader(
+          WebClientHintsType::kViewportHeight,
+          AtomicString(String::Number(image_info->viewport_height.value())),
+          request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kResourceWidth_DEPRECATED,
+                             hints_preferences)) {
+      if (image_info->resource_width) {
+        float physical_width =
+            image_info->resource_width.value() * image_info->dpr;
+        SetHttpHeader(WebClientHintsType::kResourceWidth_DEPRECATED,
+                      AtomicString(String::Number(ceil(physical_width))),
+                      request);
+      }
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kResourceWidth,
+                             hints_preferences)) {
+      if (image_info->resource_width) {
+        float physical_width =
+            image_info->resource_width.value() * image_info->dpr;
+        SetHttpHeader(WebClientHintsType::kResourceWidth,
+                      AtomicString(String::Number(ceil(physical_width))),
+                      request);
+      }
+    }
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kRtt_DEPRECATED,
+                           hints_preferences)) {
+    std::optional<base::TimeDelta> http_rtt =
+        GetNetworkStateNotifier().GetWebHoldbackHttpRtt();
+    if (!http_rtt) {
+      http_rtt = GetNetworkStateNotifier().HttpRtt();
+    }
+
+    uint32_t rtt =
+        GetNetworkStateNotifier().RoundRtt(request.Url().Host(), http_rtt);
+    SetHttpHeader(WebClientHintsType::kRtt_DEPRECATED,
+                  AtomicString(String::Number(rtt)), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kDownlink_DEPRECATED,
+                           hints_preferences)) {
+    std::optional<double> throughput_mbps =
+        GetNetworkStateNotifier().GetWebHoldbackDownlinkThroughputMbps();
+    if (!throughput_mbps) {
+      throughput_mbps = GetNetworkStateNotifier().DownlinkThroughputMbps();
+    }
+
+    double mbps = GetNetworkStateNotifier().RoundMbps(request.Url().Host(),
+                                                      throughput_mbps);
+    SetHttpHeader(WebClientHintsType::kDownlink_DEPRECATED,
+                  AtomicString(String::Number(mbps)), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kEct_DEPRECATED,
+                           hints_preferences)) {
+    std::optional<WebEffectiveConnectionType> holdback_ect =
+        GetNetworkStateNotifier().GetWebHoldbackEffectiveType();
+    if (!holdback_ect)
+      holdback_ect = GetNetworkStateNotifier().EffectiveType();
+
+    SetHttpHeader(
+        WebClientHintsType::kEct_DEPRECATED,
+        AtomicString(NetworkStateNotifier::EffectiveConnectionTypeToString(
+            holdback_ect.value())),
+        request);
+  }
+
+  // Only send User Agent hints if the info is available
+  if (ua) {
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAArch, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAArch,
+                    SerializeStringHeader(ua->architecture), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAPlatform,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAPlatform,
+                    SerializeStringHeader(ua->platform), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAPlatformVersion,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAPlatformVersion,
+                    SerializeStringHeader(ua->platform_version), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAModel, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAModel,
+                    SerializeStringHeader(ua->model), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAFullVersion,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAFullVersion,
+                    SerializeStringHeader(ua->full_version), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAFullVersionList,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAFullVersionList,
+                    AtomicString(ua->SerializeBrandFullVersionList().c_str()),
+                    request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUABitness,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUABitness,
+                    SerializeStringHeader(ua->bitness), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAWoW64, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAWoW64,
+                    SerializeBoolHeader(ua->wow64), request);
+    }
+
+    if (ShouldSendClientHint(
+            policy, resource_origin, is_1p_origin,
+            network::mojom::blink::WebClientHintsType::kUAFormFactors,
+            hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAFormFactors,
+                    AtomicString(ua->SerializeFormFactors().c_str()), request);
+    }
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kPrefersColorScheme,
+                           hints_preferences) &&
+      prefers_color_scheme.has_value()) {
+    SetHttpHeader(WebClientHintsType::kPrefersColorScheme,
+                  prefers_color_scheme.value(), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kSaveData, hints_preferences)) {
+    if (GetNetworkStateNotifier().SaveDataEnabled()) {
+      SetHttpHeader(WebClientHintsType::kSaveData, AtomicString("on"), request);
+    }
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kPrefersReducedMotion,
+                           hints_preferences) &&
+      prefers_reduced_motion.has_value()) {
+    SetHttpHeader(WebClientHintsType::kPrefersReducedMotion,
+                  prefers_reduced_motion.value(), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kPrefersReducedTransparency,
+                           hints_preferences) &&
+      prefers_reduced_transparency.has_value()) {
+    SetHttpHeader(WebClientHintsType::kPrefersReducedTransparency,
+                  prefers_reduced_transparency.value(), request);
+  }
+}
+
+=======
+// TODO(https://crbug.com/1469830) Refactor the strings into some sort of
+// context object
+void BaseFetchContext::AddClientHintsIfNecessary(
+    const ClientHintsPreferences& hints_preferences,
+    const url::Origin& resource_origin,
+    bool is_1p_origin,
+    std::optional<UserAgentMetadata> ua,
+    const PermissionsPolicy* policy,
+    base::optional_ref<const ClientHintImageInfo> image_info,
+    base::optional_ref<const WTF::AtomicString> prefers_color_scheme,
+    base::optional_ref<const WTF::AtomicString> prefers_reduced_motion,
+    base::optional_ref<const WTF::AtomicString> prefers_reduced_transparency,
+    ResourceRequest& request) {
+  // If the feature is enabled, then client hints are allowed only on secure
+  // URLs.
+  if (!ClientHintsPreferences::IsClientHintsAllowed(request.Url()))
+    return;
+
+  // Sec-CH-UA is special: we always send the header to all origins that are
+  // eligible for client hints (e.g. secure transport, JavaScript enabled).
+  //
+  // https://github.com/WICG/ua-client-hints
+  //
+  // One exception, however, is that a custom UA is sometimes set without
+  // specifying accomponying client hints, in which case we disable sending
+  // them.
+  using network::mojom::blink::WebClientHintsType;
+  if (RuntimeEnabledFeatures::UserAgentClientHintEnabled() && ua) {
+    // ShouldSendClientHint is called to make sure UA is controlled by
+    // Permissions Policy.
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUA, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUA,
+                    AtomicString(ua->SerializeBrandMajorVersionList().c_str()),
+                    request);
+    }
+
+    // We also send Sec-CH-UA-Mobile to all hints. It is a one-bit header
+    // identifying if the browser has opted for a "mobile" experience.
+    // ShouldSendClientHint is called to make sure it's controlled by
+    // PermissionsPolicy.
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAMobile,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAMobile,
+                    SerializeBoolHeader(ua->mobile), request);
+    }
+  }
+
+  // If the frame is detached, then don't send any hints other than UA.
+  if (!policy)
+    return;
+
+  // The next 4 hints should be enabled if we're allowing legacy hints to third
+  // parties, or if PermissionsPolicy delegation says they are allowed.
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kDeviceMemory_DEPRECATED,
+                           hints_preferences)) {
+    SetHttpHeader(WebClientHintsType::kDeviceMemory_DEPRECATED,
+                  AtomicString(String::Number(
+                      ApproximatedDeviceMemory::GetApproximatedDeviceMemory())),
+                  request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kDeviceMemory,
+                           hints_preferences)) {
+    SetHttpHeader(WebClientHintsType::kDeviceMemory,
+                  AtomicString(String::Number(
+                      ApproximatedDeviceMemory::GetApproximatedDeviceMemory())),
+                  request);
+  }
+
+  // These hints only make sense if the image info is available
+  if (image_info.has_value()) {
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kDpr_DEPRECATED,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kDpr_DEPRECATED,
+                    AtomicString(String::Number(image_info->dpr)), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kDpr, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kDpr,
+                    AtomicString(String::Number(image_info->dpr)), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kViewportWidth_DEPRECATED,
+                             hints_preferences) &&
+        image_info->viewport_width) {
+      SetHttpHeader(
+          WebClientHintsType::kViewportWidth_DEPRECATED,
+          AtomicString(String::Number(image_info->viewport_width.value())),
+          request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kViewportWidth,
+                             hints_preferences) &&
+        image_info->viewport_width) {
+      SetHttpHeader(
+          WebClientHintsType::kViewportWidth,
+          AtomicString(String::Number(image_info->viewport_width.value())),
+          request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kViewportHeight,
+                             hints_preferences) &&
+        image_info->viewport_height) {
+      SetHttpHeader(
+          WebClientHintsType::kViewportHeight,
+          AtomicString(String::Number(image_info->viewport_height.value())),
+          request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kResourceWidth_DEPRECATED,
+                             hints_preferences)) {
+      if (image_info->resource_width) {
+        float physical_width =
+            image_info->resource_width.value() * image_info->dpr;
+        SetHttpHeader(WebClientHintsType::kResourceWidth_DEPRECATED,
+                      AtomicString(String::Number(ceil(physical_width))),
+                      request);
+      }
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kResourceWidth,
+                             hints_preferences)) {
+      if (image_info->resource_width) {
+        float physical_width =
+            image_info->resource_width.value() * image_info->dpr;
+        SetHttpHeader(WebClientHintsType::kResourceWidth,
+                      AtomicString(String::Number(ceil(physical_width))),
+                      request);
+      }
+    }
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kRtt_DEPRECATED,
+                           hints_preferences)) {
+    std::optional<base::TimeDelta> http_rtt =
+        GetNetworkStateNotifier().GetWebHoldbackHttpRtt();
+    if (!http_rtt) {
+      http_rtt = GetNetworkStateNotifier().HttpRtt();
+    }
+
+    uint32_t rtt =
+        GetNetworkStateNotifier().RoundRtt(request.Url().Host(), http_rtt);
+    SetHttpHeader(WebClientHintsType::kRtt_DEPRECATED,
+                  AtomicString(String::Number(rtt)), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kDownlink_DEPRECATED,
+                           hints_preferences)) {
+    std::optional<double> throughput_mbps =
+        GetNetworkStateNotifier().GetWebHoldbackDownlinkThroughputMbps();
+    if (!throughput_mbps) {
+      throughput_mbps = GetNetworkStateNotifier().DownlinkThroughputMbps();
+    }
+
+    double mbps = GetNetworkStateNotifier().RoundMbps(request.Url().Host(),
+                                                      throughput_mbps);
+    SetHttpHeader(WebClientHintsType::kDownlink_DEPRECATED,
+                  AtomicString(String::Number(mbps)), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kEct_DEPRECATED,
+                           hints_preferences)) {
+    std::optional<WebEffectiveConnectionType> holdback_ect =
+        GetNetworkStateNotifier().GetWebHoldbackEffectiveType();
+    if (!holdback_ect)
+      holdback_ect = GetNetworkStateNotifier().EffectiveType();
+
+    SetHttpHeader(
+        WebClientHintsType::kEct_DEPRECATED,
+        AtomicString(NetworkStateNotifier::EffectiveConnectionTypeToString(
+            holdback_ect.value())),
+        request);
+  }
+
+  // Only send User Agent hints if the info is available
+  if (RuntimeEnabledFeatures::UserAgentClientHintEnabled() && ua) {
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAArch, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAArch,
+                    SerializeStringHeader(ua->architecture), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAPlatform,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAPlatform,
+                    SerializeStringHeader(ua->platform), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAPlatformVersion,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAPlatformVersion,
+                    SerializeStringHeader(ua->platform_version), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAModel, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAModel,
+                    SerializeStringHeader(ua->model), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAFullVersion,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAFullVersion,
+                    SerializeStringHeader(ua->full_version), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAFullVersionList,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAFullVersionList,
+                    AtomicString(ua->SerializeBrandFullVersionList().c_str()),
+                    request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUABitness,
+                             hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUABitness,
+                    SerializeStringHeader(ua->bitness), request);
+    }
+
+    if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                             WebClientHintsType::kUAWoW64, hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAWoW64,
+                    SerializeBoolHeader(ua->wow64), request);
+    }
+
+    if (ShouldSendClientHint(
+            policy, resource_origin, is_1p_origin,
+            network::mojom::blink::WebClientHintsType::kUAFormFactors,
+            hints_preferences)) {
+      SetHttpHeader(WebClientHintsType::kUAFormFactors,
+                    AtomicString(ua->SerializeFormFactors().c_str()), request);
+    }
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kPrefersColorScheme,
+                           hints_preferences) &&
+      prefers_color_scheme.has_value()) {
+    SetHttpHeader(WebClientHintsType::kPrefersColorScheme,
+                  prefers_color_scheme.value(), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kSaveData, hints_preferences)) {
+    if (GetNetworkStateNotifier().SaveDataEnabled()) {
+      SetHttpHeader(WebClientHintsType::kSaveData, AtomicString("on"), request);
+    }
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kPrefersReducedMotion,
+                           hints_preferences) &&
+      prefers_reduced_motion.has_value()) {
+    SetHttpHeader(WebClientHintsType::kPrefersReducedMotion,
+                  prefers_reduced_motion.value(), request);
+  }
+
+  if (ShouldSendClientHint(policy, resource_origin, is_1p_origin,
+                           WebClientHintsType::kPrefersReducedTransparency,
+                           hints_preferences) &&
+      prefers_reduced_transparency.has_value()) {
+    SetHttpHeader(WebClientHintsType::kPrefersReducedTransparency,
+                  prefers_reduced_transparency.value(), request);
+  }
+}
+
+>>>>>>> b424c435e5298 (Client hints overrides)
 void BaseFetchContext::PrintAccessDeniedMessage(const KURL& url) const {
   if (url.IsNull())
     return;
@@ -337,6 +911,46 @@ BaseFetchContext::CanRequestInternal(
   return std::nullopt;
 }
 
+<<<<<<< HEAD
+||||||| parent of b424c435e5298 (Client hints overrides)
+bool BaseFetchContext::ShouldSendClientHint(
+    const PermissionsPolicy* policy,
+    const url::Origin& resource_origin,
+    bool is_1p_origin,
+    network::mojom::blink::WebClientHintsType type,
+    const ClientHintsPreferences& hints_preferences) const {
+  // For subresource requests, sending the hint in the fetch request based on
+  // the permissions policy.
+  if ((!policy ||
+       !policy->IsFeatureEnabledForOrigin(
+           GetClientHintToPolicyFeatureMap().at(type), resource_origin))) {
+    return false;
+  }
+
+  return IsClientHintSentByDefault(type) || hints_preferences.ShouldSend(type);
+}
+
+=======
+bool BaseFetchContext::ShouldSendClientHint(
+    const PermissionsPolicy* policy,
+    const url::Origin& resource_origin,
+    bool is_1p_origin,
+    network::mojom::blink::WebClientHintsType type,
+    const ClientHintsPreferences& hints_preferences) const {
+  if (!RuntimeEnabledFeatures::UserAgentClientHintEnabled())
+    return false;
+  // For subresource requests, sending the hint in the fetch request based on
+  // the permissions policy.
+  if ((!policy ||
+       !policy->IsFeatureEnabledForOrigin(
+           GetClientHintToPolicyFeatureMap().at(type), resource_origin))) {
+    return false;
+  }
+
+  return IsClientHintSentByDefault(type) || hints_preferences.ShouldSend(type);
+}
+
+>>>>>>> b424c435e5298 (Client hints overrides)
 void BaseFetchContext::Trace(Visitor* visitor) const {
   visitor->Trace(fetcher_properties_);
   visitor->Trace(console_logger_);
diff --git a/third_party/blink/renderer/platform/runtime_enabled_features.json5 b/third_party/blink/renderer/platform/runtime_enabled_features.json5
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -381,6 +381,11 @@
       name: "AtomicMoveAPI",
       status: "test",
     },
+    {
+      name: "UserAgentClientHint",
+      status: "stable",
+      base_feature: "UserAgentClientHint",
+    },
     {
       name: "AttributionReporting",
       status: "stable",
-- 

