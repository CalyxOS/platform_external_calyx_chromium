From: uazo <uazo@users.noreply.github.com>
Date: Fri, 8 Apr 2022 11:04:04 +0000
Subject: Add lifetime options for permissions

Indicate the session mode for content-settings by using the constraint `content_settings::SessionModel` as
UserSession when setting the value, and also make use of an expiration time value.
This is used in Chromium for `ClientHints` but it is generally possible to use this functionality when a
specific value needs to be persisted by origin.
All content settings of this type are not saved on disk (except for the `Forever` option), allowing user to
reset the status each time application is restarted.

There are 4 main areas affected to introduce the functionality:
* components/content_settings
  A new `content_settings::LifetimeMode` enum value is defined to specify the user's
  choice (Always, OnlyThisTime, UntilOriginClosed, UntilBrowserClosed).
  Enumeration is also generated for java by adding it in `content_settings_enums_javagen` (gn).
  This is mainly used in `content_settings_utils.cc` to create a specialised `content_settings::ContentSettingConstraints`
  that is then used in `SetContentSettingDefaultScope()` by `PermissionContextBase::UpdateContentSetting`.
  Existing Chromium data structures do not provide a specific property to define a choice which is instead encoded through
  the `ContentSettingConstraints`; this approach is already used in other parts of the Chromium codebase so it is not
  novel here.
  Therefore, `content_settings::GetConstraintSessionExpiration()` and `content_settings::IsConstraintSessionExpiration()`
  manage the lifetime modes of the session content-settings.
  The modificaiton also adds the session pattern to the ContentSettingPatternSource so that it is available for the UI.
* components/permissions
  Lifetime support is added to the permissions; most of the changes are caused by the fact that it is necessary to report
  the value selected by the user from the Java UI managed by `components/browser_ui` up to
  `PermissionContextBase::UpdateContentSetting()`,   without necessarily having to modify all requests that are not
  related to geolocation/camera/microphone. The approach used is a new
  `PermissionRequest::PermissionDecidedCallbackWithLifetime` used by an overload of
  `PermissionContextBase::CreatePermissionRequest` so that options are present only for the specific content-settings
  (see `PermissionDialogModel.java`).
  For other permissions no behaviour is changed (see `PermissionDialogDelegate::Accept`); for geolocation it was
  necessary to act directly in the specific context, because, unlike microphone/camera, the content-setting value is
  inserted in its specific method (`FinishNotifyPermissionSet`, that calls the callback), even if the class always
  derives from `PermissionContextBase`.
* components/page_info
  Some changes needed to see in the summary of the `page_info` the text "(only this session)"
  (aka `page_info_android_permission_session_permission`) through adding a new property "is_user_session" in
  `PageInfoPermissionEntry` (Java).
* components/browser_ui
  Changes to the Settings UI to show "(only this session)" in the specific content-setting.
  The same view is used both in the settings and in the page_info.

For the management of `UntilOriginClosed` the logic used by flag `kOneTimeGeolocationPermission` was used; this flag
is active only in the desktop (files `last_tab_standing_tracker_*`). It is a class that manages a list of the active
origins and allows to perform operations when all the tabs relating to that origin have been closed, in this case
deleting the session content settings of `UntilOriginClosed`.

See also: https://github.com/bromite/bromite/issues/1549

Original License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html
---
 .../permissions/last_tab_standing_tracker.cc  | 32 ++++++++
 .../one_time_permissions_tracker.cc           | 33 +++++++-
 .../one_time_permissions_tracker.h            |  5 +-
 .../one_time_permissions_tracker_factory.cc   |  2 +-
 .../views/permissions/chip/chip_controller.cc |  2 +-
 ...exclusive_access_permission_prompt_view.cc |  2 +-
 .../permission_prompt_bubble_base_view.cc     |  2 +-
 .../site_settings/PermissionInfo.java         |  1 +
 .../site_settings/SingleWebsiteSettings.java  |  9 ++
 .../android/website_preference_bridge.cc      |  2 +-
 .../strings/android/browser_ui_strings.grd    |  5 ++
 .../core/browser/content_settings_utils.cc    | 42 ++++++++--
 .../core/browser/content_settings_utils.h     |  6 ++
 .../core/common/content_settings_enums.mojom  |  9 ++
 .../page_info/PageInfoController.java         |  4 +-
 .../PermissionParamsListBuilder.java          | 13 ++-
 .../android/page_info_controller_android.cc   | 10 ++-
 components/page_info/page_info.cc             |  2 +
 components/page_info/page_info.h              |  1 +
 .../permissions/PermissionDialogDelegate.java | 13 +++
 .../PermissionDialogModelFactory.java         | 82 ++++++++++++++++++-
 .../embedded_permission_prompt_android.cc     |  3 +-
 .../embedded_permission_prompt_android.h      |  2 +-
 .../permission_dialog_delegate.cc             | 24 +++++-
 .../permission_dialog_delegate.h              |  1 +
 .../permission_prompt_android.cc              |  8 +-
 .../permission_prompt_android.h               |  3 +-
 .../android/permissions_android_strings.grd   | 17 ++++
 .../geolocation_permission_context_android.cc | 34 ++++++--
 .../geolocation_permission_context_android.h  | 13 ++-
 .../embedded_permission_prompt_flow_model.cc  |  2 +-
 .../permissions/permission_context_base.cc    | 52 ++++++++++--
 .../permissions/permission_context_base.h     | 23 +++++-
 components/permissions/permission_prompt.h    |  3 +-
 components/permissions/permission_request.cc  | 30 ++++++-
 components/permissions/permission_request.h   | 16 +++-
 .../permissions/permission_request_manager.cc | 45 ++++++----
 .../permissions/permission_request_manager.h  | 11 ++-
 38 files changed, 493 insertions(+), 71 deletions(-)

diff --git a/chrome/browser/permissions/last_tab_standing_tracker.cc b/chrome/browser/permissions/last_tab_standing_tracker.cc
--- a/chrome/browser/permissions/last_tab_standing_tracker.cc
+++ b/chrome/browser/permissions/last_tab_standing_tracker.cc
@@ -7,6 +7,32 @@
 #include "base/observer_list.h"
 #include "url/gurl.h"
 
+#include "components/content_settings/core/browser/host_content_settings_map.h"
+#include "components/content_settings/core/common/content_settings_utils.h"
+#include "components/permissions/permissions_client.h"
+
+namespace {
+  // Remove all sessions content setting by origin and type
+  void RemoveSessionSettings(HostContentSettingsMap* content_settings,
+                             const url::Origin& origin,
+                             ContentSettingsType type) {
+    ContentSettingsForOneType session_settings =
+      content_settings->GetSettingsForOneType(
+          type, content_settings::mojom::SessionModel::USER_SESSION);
+
+    GURL url = origin.GetURL();
+    for (ContentSettingPatternSource& entry : session_settings) {
+      if (content_settings::IsConstraintSessionExpiration(entry,
+              content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED) &&
+          entry.primary_pattern.Matches(url)) {
+        content_settings->SetWebsiteSettingCustomScope(
+            entry.primary_pattern, entry.secondary_pattern,
+            type, base::Value());
+      }
+    }
+  }
+}
+
 LastTabStandingTracker::LastTabStandingTracker(content::BrowserContext* context)
     : context_(context) {}
 
@@ -56,4 +82,10 @@ void LastTabStandingTracker::WebContentsUnloadedOrigin(
     for (auto& observer : observer_list_) {
       observer.OnLastPageFromOriginClosed(origin);
     }
+    HostContentSettingsMap* content_settings =
+            permissions::PermissionsClient::Get()->GetSettingsMap(context_);
+    RemoveSessionSettings(content_settings, origin, ContentSettingsType::GEOLOCATION);
+    RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_MIC);
+    RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_CAMERA);
+  }
 }
diff --git a/chrome/browser/permissions/one_time_permissions_tracker.cc b/chrome/browser/permissions/one_time_permissions_tracker.cc
--- a/chrome/browser/permissions/one_time_permissions_tracker.cc
+++ b/chrome/browser/permissions/one_time_permissions_tracker.cc
@@ -19,8 +19,34 @@
 #include "components/permissions/permission_context_base.h"
 #include "content/public/browser/visibility.h"
 #include "url/gurl.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
+#include "components/content_settings/core/common/content_settings_utils.h"
+#include "components/permissions/permissions_client.h"
+
+namespace {
+  // Remove all sessions content setting by origin and type
+  void RemoveSessionSettings(HostContentSettingsMap* content_settings,
+                             const url::Origin& origin,
+                             ContentSettingsType type) {
+    ContentSettingsForOneType session_settings =
+      content_settings->GetSettingsForOneType(
+          type, content_settings::mojom::SessionModel::USER_SESSION);
+
+    GURL url = origin.GetURL();
+    for (ContentSettingPatternSource& entry : session_settings) {
+      if (content_settings::IsConstraintSessionExpiration(entry,
+              content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED) &&
+          entry.primary_pattern.Matches(url)) {
+        content_settings->SetWebsiteSettingCustomScope(
+            entry.primary_pattern, entry.secondary_pattern,
+            type, base::Value());
+      }
+    }
+  }
+}
 
-OneTimePermissionsTracker::OneTimePermissionsTracker() = default;
+OneTimePermissionsTracker::OneTimePermissionsTracker(content::BrowserContext* context)
+    : context_(context) {}
 OneTimePermissionsTracker::~OneTimePermissionsTracker() = default;
 
 OneTimePermissionsTracker::OriginTrackEntry::OriginTrackEntry() = default;
@@ -257,6 +283,11 @@ void OneTimePermissionsTracker::NotifyLastPageFromOriginClosed(
   for (auto& observer : observer_list_) {
     observer.OnLastPageFromOriginClosed(origin);
   }
+  HostContentSettingsMap* content_settings =
+          permissions::PermissionsClient::Get()->GetSettingsMap(context_);
+  RemoveSessionSettings(content_settings, origin, ContentSettingsType::GEOLOCATION);
+  RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_MIC);
+  RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_CAMERA);
 }
 
 bool OneTimePermissionsTracker::ShouldIgnoreOrigin(const url::Origin& origin) {
diff --git a/chrome/browser/permissions/one_time_permissions_tracker.h b/chrome/browser/permissions/one_time_permissions_tracker.h
--- a/chrome/browser/permissions/one_time_permissions_tracker.h
+++ b/chrome/browser/permissions/one_time_permissions_tracker.h
@@ -12,6 +12,7 @@
 #include "base/timer/timer.h"
 #include "chrome/browser/permissions/one_time_permissions_tracker_observer.h"
 #include "components/content_settings/core/common/content_settings_pattern.h"
+#include "chrome/browser/profiles/profile.h"
 #include "components/content_settings/core/common/content_settings_types.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "content/public/browser/visibility.h"
@@ -24,7 +25,7 @@ class OneTimePermissionsTracker : public KeyedService {
       void (OneTimePermissionsTracker::*)(const url::Origin&);
 
  public:
-  OneTimePermissionsTracker();
+  OneTimePermissionsTracker(content::BrowserContext* context);
   ~OneTimePermissionsTracker() override;
 
   OneTimePermissionsTracker(const OneTimePermissionsTracker&) = delete;
@@ -138,7 +139,7 @@ class OneTimePermissionsTracker : public KeyedService {
   base::ObserverList<OneTimePermissionsTrackerObserver> observer_list_;
 
   std::map<url::Origin, OriginTrackEntry> origin_tracker_;
-
+  raw_ptr<content::BrowserContext> context_;
   base::WeakPtrFactory<OneTimePermissionsTracker> weak_factory_{this};
 };
 
diff --git a/chrome/browser/permissions/one_time_permissions_tracker_factory.cc b/chrome/browser/permissions/one_time_permissions_tracker_factory.cc
--- a/chrome/browser/permissions/one_time_permissions_tracker_factory.cc
+++ b/chrome/browser/permissions/one_time_permissions_tracker_factory.cc
@@ -44,5 +44,5 @@ bool OneTimePermissionsTrackerFactory::ServiceIsCreatedWithBrowserContext()
 std::unique_ptr<KeyedService>
 OneTimePermissionsTrackerFactory::BuildServiceInstanceForBrowserContext(
     content::BrowserContext* context) const {
-  return std::make_unique<OneTimePermissionsTracker>();
+  return std::make_unique<OneTimePermissionsTracker>(context);
 }
diff --git a/chrome/browser/ui/views/permissions/chip/chip_controller.cc b/chrome/browser/ui/views/permissions/chip/chip_controller.cc
--- a/chrome/browser/ui/views/permissions/chip/chip_controller.cc
+++ b/chrome/browser/ui/views/permissions/chip/chip_controller.cc
@@ -224,7 +224,7 @@ void ChipController::OnWidgetDestroyed(views::Widget* widget) {
       active_chip_permission_request_manager_.value()->Accept();
       break;
     case permissions::PermissionAction::GRANTED_ONCE:
-      active_chip_permission_request_manager_.value()->AcceptThisTime();
+      active_chip_permission_request_manager_.value()->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       break;
     case permissions::PermissionAction::DENIED:
       active_chip_permission_request_manager_.value()->Deny();
diff --git a/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc b/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc
--- a/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc
+++ b/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc
@@ -100,7 +100,7 @@ void ExclusiveAccessPermissionPromptView::RunButtonCallback(int button_id) {
   }
   ButtonType button = GetButtonType(button_id);
   if (button == ButtonType::kAllowThisTime) {
-    delegate_->AcceptThisTime();
+    delegate_->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
   } else if (button == ButtonType::kAlwaysAllow) {
     delegate_->Accept();
   } else if (button == ButtonType::kNeverAllow) {
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc
@@ -266,7 +266,7 @@ void PermissionPromptBubbleBaseView::RunButtonCallback(int button_id) {
       delegate_->Accept();
       return;
     case PermissionDialogButton::kAcceptOnce:
-      delegate_->AcceptThisTime();
+      delegate_->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       return;
     case PermissionDialogButton::kDeny:
       delegate_->Deny();
diff --git a/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/PermissionInfo.java b/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/PermissionInfo.java
--- a/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/PermissionInfo.java
+++ b/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/PermissionInfo.java
@@ -10,6 +10,7 @@ import org.chromium.components.content_settings.ContentSettingValues;
 import org.chromium.components.content_settings.ContentSettingsType;
 import org.chromium.components.content_settings.SessionModel;
 import org.chromium.content_public.browser.BrowserContextHandle;
+import org.chromium.components.content_settings.SessionModel;
 
 import java.io.Serializable;
 
diff --git a/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java b/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java
--- a/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java
+++ b/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java
@@ -617,6 +617,11 @@ public class SingleWebsiteSettings extends BaseSiteSettingsFragment
     }
 
     @RequiresNonNull({"mSite"})
+    private boolean isSessionPermission(@ContentSettingsType.EnumType int type) {
+        return mSite.getPermissionInfo(type) != null &&
+               mSite.getPermissionInfo(type).getSessionModel() == SessionModel.USER_SESSION;
+    }
+
     private void setUpClearDataPreference() {
         ClearWebsiteStorage preference = findPreference(PREF_CLEAR_DATA);
         long usage = mSite.getTotalUsage();
@@ -1285,6 +1290,10 @@ public class SingleWebsiteSettings extends BaseSiteSettingsFragment
                     AppCompatResources.getColorStateList(getContext(), mHighlightColor)
                             .getDefaultColor());
         }
+        if (isSessionPermission(contentType)) {
+            switchPreference.setSummary(switchPreference.getSummary() + " " +
+                getString(R.string.page_info_android_permission_session_permission));
+        }
     }
 
     /**
diff --git a/components/browser_ui/site_settings/android/website_preference_bridge.cc b/components/browser_ui/site_settings/android/website_preference_bridge.cc
--- a/components/browser_ui/site_settings/android/website_preference_bridge.cc
+++ b/components/browser_ui/site_settings/android/website_preference_bridge.cc
@@ -208,7 +208,7 @@ void GetOrigins(JNIEnv* env,
       seen_origins.push_back(origin);
       insertionFunc(env, static_cast<int>(content_type), list,
                     ConvertOriginToJavaString(env, origin), jembedder,
-                    /*is_embargoed=*/true, /*is_one_time=*/false);
+                    /*is_embargoed=*/true, 0);
     }
   }
 }
diff --git a/components/browser_ui/strings/android/browser_ui_strings.grd b/components/browser_ui/strings/android/browser_ui_strings.grd
--- a/components/browser_ui/strings/android/browser_ui_strings.grd
+++ b/components/browser_ui/strings/android/browser_ui_strings.grd
@@ -646,6 +646,11 @@
       <message name="IDS_PAGE_INFO_URL_TRUNCATED" desc="Accessibility announcement when the URL in PageInfo switches from full to truncated display">
         URL truncated
       </message>
+      <message name="IDS_PAGE_INFO_ANDROID_PERMISSION_SESSION_PERMISSION"
+               desc="The label used in the About Page dialog to indicate a session permission">
+        (only this session)
+      </message>
+
       <message name="IDS_PAGE_INFO_AD_PRIVACY_HEADER" desc="A label that represents the new ad-related settings. 1) Navigate to any site. 2) Click the icon (often a lock) to the left of the URL in the address bar. Information about the page you're viewing appears. The 'Ad privacy' label will appear above the 'Site settings' button.">
         Ad privacy
       </message>
diff --git a/components/content_settings/core/browser/content_settings_utils.cc b/components/content_settings/core/browser/content_settings_utils.cc
--- a/components/content_settings/core/browser/content_settings_utils.cc
+++ b/components/content_settings/core/browser/content_settings_utils.cc
@@ -157,6 +157,42 @@ bool IsConstraintPersistent(const ContentSettingConstraints& constraints) {
   return constraints.session_model() == mojom::SessionModel::DURABLE;
 }
 
+ContentSettingConstraints GetConstraintSessionExpiration(content_settings::mojom::LifetimeMode lifetime_mode) {
+  int lifetime;
+  base::Time now;
+  if (lifetime_mode == content_settings::mojom::LifetimeMode::ONLY_THIS_TIME) {
+    // note: this content settings will be discarded immediately
+    // 1h is used as a magic constant to identify the one-time lifetime mode
+    lifetime = 1;
+  } else if (lifetime_mode == content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED) {
+    now = base::Time::Now();
+    lifetime = 24;
+  } else {
+    lifetime = 0;
+  }
+  ContentSettingConstraints c(now);
+  c.set_lifetime(base::Hours(lifetime));
+  c.set_session_model(mojom::SessionModel::USER_SESSION);
+  return c;
+}
+
+bool IsConstraintSessionExpiration(const ContentSettingPatternSource& source,
+                                   content_settings::mojom::LifetimeMode lifetime_mode) {
+  if (source.metadata.session_model() != content_settings::mojom::SessionModel::USER_SESSION)
+    return false;
+
+  mojom::LifetimeMode type;
+  if (source.metadata.lifetime() == base::Hours(24)) {
+    type = content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED;
+  } else if (source.metadata.expiration() == (base::Time() + base::Hours(1))) {
+    type = content_settings::mojom::LifetimeMode::ONLY_THIS_TIME;
+  } else {
+    type = content_settings::mojom::LifetimeMode::UNTIL_BROWSER_CLOSED;
+  }
+
+  return lifetime_mode == type;
+}
+
 bool CanTrackLastVisit(ContentSettingsType type) {
   // Last visit is not tracked for notification permission as it shouldn't be
   // auto-revoked.
@@ -240,9 +276,6 @@ const std::vector<ContentSettingsType>& GetTypesWithTemporaryGrants() {
       ContentSettingsType::CAPTURED_SURFACE_CONTROL,
 #endif
       ContentSettingsType::KEYBOARD_LOCK,
-      ContentSettingsType::GEOLOCATION,
-      ContentSettingsType::MEDIASTREAM_MIC,
-      ContentSettingsType::MEDIASTREAM_CAMERA,
       ContentSettingsType::HAND_TRACKING,
       ContentSettingsType::SMART_CARD_DATA,
       ContentSettingsType::AR,
@@ -258,9 +291,6 @@ const std::vector<ContentSettingsType>& GetTypesWithTemporaryGrantsInHcsm() {
       ContentSettingsType::CAPTURED_SURFACE_CONTROL,
 #endif
       ContentSettingsType::KEYBOARD_LOCK,
-      ContentSettingsType::GEOLOCATION,
-      ContentSettingsType::MEDIASTREAM_MIC,
-      ContentSettingsType::MEDIASTREAM_CAMERA,
       ContentSettingsType::HAND_TRACKING,
       ContentSettingsType::AR,
       ContentSettingsType::VR,
diff --git a/components/content_settings/core/browser/content_settings_utils.h b/components/content_settings/core/browser/content_settings_utils.h
--- a/components/content_settings/core/browser/content_settings_utils.h
+++ b/components/content_settings/core/browser/content_settings_utils.h
@@ -74,6 +74,12 @@ bool IsConstraintPersistent(const ContentSettingConstraints& constraints);
 // Returns whether the given type supports tracking last_visit timestamps.
 bool CanTrackLastVisit(ContentSettingsType type);
 
+ContentSettingConstraints GetConstraintSessionExpiration(mojom::LifetimeMode lifetime_mode);
+
+bool IsConstraintSessionExpiration(
+    const ContentSettingPatternSource& source,
+    mojom::LifetimeMode lifetime_mode);
+
 // Get a timestamp with week-precision.
 base::Time GetCoarseVisitedTime(base::Time time);
 
diff --git a/components/content_settings/core/common/content_settings_enums.mojom b/components/content_settings/core/common/content_settings_enums.mojom
--- a/components/content_settings/core/common/content_settings_enums.mojom
+++ b/components/content_settings/core/common/content_settings_enums.mojom
@@ -63,6 +63,15 @@ enum SessionModel {
   ONE_TIME = 3,
 };
 
+// GENERATED_JAVA_ENUM_PACKAGE: org.chromium.components.content_settings
+// GENERATED_JAVA_CLASS_NAME_OVERRIDE: LifetimeMode
+enum LifetimeMode {
+  ALWAYS = 99,
+  ONLY_THIS_TIME = 1,
+  UNTIL_ORIGIN_CLOSED = 2,
+  UNTIL_BROWSER_CLOSED = 0,
+};
+
 // Identifies the content settings provider of a content setting.
 // GENERATED_JAVA_ENUM_PACKAGE: org.chromium.components.content_settings
 // GENERATED_JAVA_CLASS_NAME_OVERRIDE: ProviderType
diff --git a/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java b/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java
--- a/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java
+++ b/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java
@@ -386,9 +386,9 @@ public class PageInfoController
             String name,
             String nameMidSentence,
             int type,
-            @ContentSettingValues int currentSettingValue) {
+            @ContentSettingValues int currentSettingValue, boolean is_user_session) {
         mPermissionParamsListBuilder.addPermissionEntry(
-                name, nameMidSentence, type, currentSettingValue);
+                name, nameMidSentence, type, currentSettingValue, is_user_session);
     }
 
     /** Update the permissions view based on the contents of mDisplayedPermissions. */
diff --git a/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java b/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java
--- a/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java
+++ b/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java
@@ -48,8 +48,9 @@ public class PermissionParamsListBuilder {
     }
 
     public void addPermissionEntry(
-            String name, String nameMidSentence, int type, @ContentSettingValues int value) {
-        mEntries.add(new PageInfoPermissionEntry(name, nameMidSentence, type, value));
+            String name, String nameMidSentence, int type, @ContentSettingValues int value,
+            boolean is_user_session) {
+        mEntries.add(new PageInfoPermissionEntry(name, nameMidSentence, type, value, is_user_session));
     }
 
     public void clearPermissionEntries() {
@@ -85,6 +86,10 @@ public class PermissionParamsListBuilder {
                 } else {
                     warningTextResource = R.string.page_info_android_permission_blocked;
                 }
+                if (permission.is_user_session) {
+                    warningTextResource =
+                            R.string.page_info_android_permission_session_permission;
+                }
             }
         } else {
             assert permission.setting == ContentSettingValues.ASK
@@ -121,13 +126,15 @@ public class PermissionParamsListBuilder {
         public final String nameMidSentence;
         public final int type;
         public final @ContentSettingValues int setting;
+        public final boolean is_user_session;
 
         PageInfoPermissionEntry(
-                String name, String nameMidSentence, int type, @ContentSettingValues int setting) {
+                String name, String nameMidSentence, int type, @ContentSettingValues int setting, boolean is_user_session) {
             this.name = name;
             this.nameMidSentence = nameMidSentence;
             this.type = type;
             this.setting = setting;
+            this.is_user_session = is_user_session;
         }
 
         @Override
diff --git a/components/page_info/android/page_info_controller_android.cc b/components/page_info/android/page_info_controller_android.cc
--- a/components/page_info/android/page_info_controller_android.cc
+++ b/components/page_info/android/page_info_controller_android.cc
@@ -165,6 +165,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
 
   std::map<ContentSettingsType, ContentSetting>
       user_specified_settings_to_display;
+  std::map<ContentSettingsType, bool>
+      user_specified_settings_is_user_session;
 
   for (const auto& permission : permission_info_list) {
     if (base::Contains(permissions_to_display, permission.type)) {
@@ -173,6 +175,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
       if (setting_to_display) {
         user_specified_settings_to_display[permission.type] =
             *setting_to_display;
+        user_specified_settings_is_user_session[permission.type] =
+            permission.is_user_session;
       }
     }
   }
@@ -189,7 +193,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
           ConvertUTF16ToJavaString(env, setting_title),
           ConvertUTF16ToJavaString(env, setting_title_mid_sentence),
           static_cast<jint>(permission),
-          static_cast<jint>(user_specified_settings_to_display[permission]));
+          static_cast<jint>(user_specified_settings_to_display[permission]),
+          user_specified_settings_is_user_session[permission]);
     }
   }
 
@@ -202,7 +207,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
         env, controller_jobject_, ConvertUTF16ToJavaString(env, object_title),
         ConvertUTF16ToJavaString(env, object_title),
         static_cast<jint>(chosen_object->ui_info->content_settings_type),
-        static_cast<jint>(CONTENT_SETTING_ALLOW));
+        static_cast<jint>(CONTENT_SETTING_ALLOW),
+        /* is_user_session */ false);
   }
 
   Java_PageInfoController_updatePermissionDisplay(env, controller_jobject_);
diff --git a/components/page_info/page_info.cc b/components/page_info/page_info.cc
--- a/components/page_info/page_info.cc
+++ b/components/page_info/page_info.cc
@@ -1210,6 +1210,8 @@ void PageInfo::PopulatePermissionInfo(PermissionInfo& permission_info,
   permission_info.is_one_time =
       (info.metadata.session_model() ==
        content_settings::mojom::SessionModel::ONE_TIME);
+  permission_info.is_user_session =
+      (info.metadata.session_model() == content_settings::mojom::SessionModel::USER_SESSION);
 
   auto* page_specific_content_settings = GetPageSpecificContentSettings();
   if (page_specific_content_settings && setting == CONTENT_SETTING_ALLOW) {
diff --git a/components/page_info/page_info.h b/components/page_info/page_info.h
--- a/components/page_info/page_info.h
+++ b/components/page_info/page_info.h
@@ -149,6 +149,7 @@ class PageInfo : private content_settings::CookieControlsObserver,
         content_settings::SettingSource::kNone;
     // Whether the permission is a one-time grant.
     bool is_one_time = false;
+    bool is_user_session = false;
     // Only set for settings that can have multiple permissions for different
     // embedded origins.
     std::optional<url::Origin> requesting_origin;
diff --git a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java
--- a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java
+++ b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java
@@ -15,6 +15,7 @@ import org.jni_zero.NativeMethods;
 import org.chromium.build.annotations.NullMarked;
 import org.chromium.build.annotations.Nullable;
 import org.chromium.ui.base.WindowAndroid;
+import org.chromium.components.content_settings.LifetimeMode;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -66,6 +67,9 @@ public class PermissionDialogDelegate {
     // Prompt(screen) variant we want to display on the dialog.
     private @EmbeddedPromptVariant int mEmbeddedPromptVariant;
 
+    /** Lifetime option selected by the user. */
+    private int mSelectedLifetimeOption = LifetimeMode.ALWAYS;
+
     /**
      * Defines a (potentially empty) list of ranges represented as pairs of <startIndex, endIndex>,
      * which shall be used by the UI to format the specified ranges as bold text.
@@ -135,6 +139,15 @@ public class PermissionDialogDelegate {
                 .acceptThisTime(mNativeDelegatePtr, PermissionDialogDelegate.this);
     }
 
+    public void setSelectedLifetimeOption(int idx) {
+        mSelectedLifetimeOption = idx;
+    }
+
+    @CalledByNative
+    public int getSelectedLifetimeOption() {
+        return mSelectedLifetimeOption;
+    }
+
     public void onDeny() {
         assert mNativeDelegatePtr != 0;
         PermissionDialogDelegateJni.get().deny(mNativeDelegatePtr, PermissionDialogDelegate.this);
diff --git a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java
--- a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java
+++ b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java
@@ -13,6 +13,18 @@ import org.chromium.ui.UiUtils;
 import org.chromium.ui.modaldialog.ModalDialogProperties;
 import org.chromium.ui.modelutil.PropertyModel;
 
+import java.util.Arrays;
+import java.util.List;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.LinearLayout;
+import android.widget.RadioButton;
+import android.widget.RadioGroup;
+import android.widget.TextView;
+import org.chromium.base.ApiCompatibilityUtils;
+import org.chromium.ui.base.ViewUtils;
+import org.chromium.components.content_settings.ContentSettingsType;
+import org.chromium.components.content_settings.LifetimeMode;
+
 /** This class creates the model for the permission dialog. */
 @NullMarked
 class PermissionDialogModelFactory {
@@ -67,7 +79,75 @@ class PermissionDialogModelFactory {
                             ModalDialogProperties.ButtonStyles.PRIMARY_FILLED_NEGATIVE_OUTLINE)
                     .with(ModalDialogProperties.CHANGE_CUSTOM_VIEW_OR_BUTTONS, true);
         }
-        return builder.build();
+
+        PropertyModel pm = builder.build();
+        int[] types = delegate.getContentSettingsTypes();
+        if (contains(types, ContentSettingsType.GEOLOCATION) ||
+            contains(types, ContentSettingsType.MEDIASTREAM_MIC) ||
+            contains(types, ContentSettingsType.MEDIASTREAM_CAMERA))
+        {
+            LinearLayout layout = (LinearLayout) customView;
+
+            // Create a text label before the lifetime selector.
+            TextView lifetimeOptionsText = new TextView(context);
+            lifetimeOptionsText.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_title));
+            lifetimeOptionsText.setTextAppearance(
+                    lifetimeOptionsText.getContext(), R.style.TextAppearance_TextMedium_Primary);
+
+            LinearLayout.LayoutParams lifetimeOptionsTextLayoutParams =
+                    new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+            lifetimeOptionsTextLayoutParams.setMargins(0, 0, 0, ViewUtils.dpToPx(context, 8));
+            lifetimeOptionsText.setLayoutParams(lifetimeOptionsTextLayoutParams);
+            layout.addView(lifetimeOptionsText);
+
+            // Create radio buttons with lifetime options.
+            RadioGroup radioGroup = new RadioGroup(context);
+
+            RadioButton radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_only_this_this));
+            radioButton.setId(LifetimeMode.ONLY_THIS_TIME);
+            radioGroup.addView(radioButton);
+
+            radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_until_page_close));
+            radioButton.setId(LifetimeMode.UNTIL_ORIGIN_CLOSED);
+            radioGroup.addView(radioButton);
+
+            radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_until_browser_close));
+            radioButton.setId(LifetimeMode.UNTIL_BROWSER_CLOSED);
+            radioGroup.addView(radioButton);
+
+            radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_forever));
+            radioButton.setId(LifetimeMode.ALWAYS);
+            radioGroup.addView(radioButton);
+
+            radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged(RadioGroup group, int checkedId) {
+                    delegate.setSelectedLifetimeOption(checkedId);
+                }
+            });
+            radioGroup.check(1);
+            layout.addView(radioGroup);
+        }
+
+        return pm;
+    }
+
+    private static boolean contains(final int[] array, final int key) {
+        int length = array.length;
+        for(int i = 0; i < length; i++) {
+            if (array[i] == key)
+                return true;
+        }
+        return false;
     }
 
     public static ModalDialogProperties.ModalDialogButtonSpec[] getButtonSpecs(
diff --git a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc
--- a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc
+++ b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc
@@ -117,7 +117,8 @@ void EmbeddedPermissionPromptAndroid::Acknowledge() {
   delegate()->FinalizeCurrentRequests();
 }
 
-void EmbeddedPermissionPromptAndroid::AcceptThisTime() {
+void EmbeddedPermissionPromptAndroid::AcceptThisTime(
+        content_settings::mojom::LifetimeMode lifetimeOption) {
   prompt_model_->PrecalculateVariantsForMetrics();
   prompt_model_->RecordPermissionActionUKM(
       permissions::ElementAnchoredBubbleAction::kGrantedOnce);
diff --git a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h
--- a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h
+++ b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h
@@ -45,7 +45,7 @@ class EmbeddedPermissionPromptAndroid : public PermissionPromptAndroid {
       const override;
   void Closing() override;
   void Accept() override;
-  void AcceptThisTime() override;
+  void AcceptThisTime(content_settings::mojom::LifetimeMode lifetimeOption) override;
   void Acknowledge() override;
   void Deny() override;
   void Resumed() override;
diff --git a/components/permissions/android/permission_prompt/permission_dialog_delegate.cc b/components/permissions/android/permission_prompt/permission_dialog_delegate.cc
--- a/components/permissions/android/permission_prompt/permission_dialog_delegate.cc
+++ b/components/permissions/android/permission_prompt/permission_dialog_delegate.cc
@@ -139,6 +139,11 @@ void PermissionDialogJavaDelegate::UpdateDialog() {
       static_cast<int>(permission_prompt_->GetEmbeddedPromptVariant()));
 }
 
+int PermissionDialogJavaDelegate::GetSelectedLifetimeOption() {
+  JNIEnv* env = base::android::AttachCurrentThread();
+  return Java_PermissionDialogDelegate_getSelectedLifetimeOption(env, j_delegate_);
+}
+
 // static
 std::unique_ptr<PermissionDialogDelegate> PermissionDialogDelegate::Create(
     content::WebContents* web_contents,
@@ -168,6 +173,13 @@ PermissionDialogDelegate::CreateForTesting(
 void PermissionDialogDelegate::Accept(JNIEnv* env,
                                       const JavaParamRef<jobject>& obj) {
   CHECK(permission_prompt_);
+  content_settings::mojom::LifetimeMode lifetimeOption =
+    static_cast<content_settings::mojom::LifetimeMode>(
+      java_delegate_->GetSelectedLifetimeOption());
+  if (lifetimeOption != content_settings::mojom::LifetimeMode::ALWAYS) {
+    permission_prompt_->AcceptThisTime(lifetimeOption);
+    return;
+  }
   permission_prompt_->Accept();
 }
 
@@ -175,7 +187,10 @@ void PermissionDialogDelegate::AcceptThisTime(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj) {
   CHECK(permission_prompt_);
-  permission_prompt_->AcceptThisTime();
+  content_settings::mojom::LifetimeMode lifetimeOption =
+    static_cast<content_settings::mojom::LifetimeMode>(
+      java_delegate_->GetSelectedLifetimeOption());
+  permission_prompt_->AcceptThisTime(lifetimeOption);
 }
 
 void PermissionDialogDelegate::Acknowledge(JNIEnv* env,
@@ -187,6 +202,13 @@ void PermissionDialogDelegate::Acknowledge(JNIEnv* env,
 void PermissionDialogDelegate::Deny(JNIEnv* env,
                                     const JavaParamRef<jobject>& obj) {
   CHECK(permission_prompt_);
+  content_settings::mojom::LifetimeMode lifetimeOption =
+    static_cast<content_settings::mojom::LifetimeMode>(
+      java_delegate_->GetSelectedLifetimeOption());
+  if (lifetimeOption != content_settings::mojom::LifetimeMode::ALWAYS) {
+    permission_prompt_->DenyThisTime(lifetimeOption);
+    return;
+  }
   permission_prompt_->Deny();
 }
 
diff --git a/components/permissions/android/permission_prompt/permission_dialog_delegate.h b/components/permissions/android/permission_prompt/permission_dialog_delegate.h
--- a/components/permissions/android/permission_prompt/permission_dialog_delegate.h
+++ b/components/permissions/android/permission_prompt/permission_dialog_delegate.h
@@ -42,6 +42,7 @@ class PermissionDialogJavaDelegate {
       const favicon_base::FaviconRawBitmapResult& favicon_result);
 
   virtual void DismissDialog();
+  virtual int GetSelectedLifetimeOption();
 
   virtual void UpdateDialog();
 
diff --git a/components/permissions/android/permission_prompt/permission_prompt_android.cc b/components/permissions/android/permission_prompt/permission_prompt_android.cc
--- a/components/permissions/android/permission_prompt/permission_prompt_android.cc
+++ b/components/permissions/android/permission_prompt/permission_prompt_android.cc
@@ -76,8 +76,12 @@ void PermissionPromptAndroid::Accept() {
   delegate_->Accept();
 }
 
-void PermissionPromptAndroid::AcceptThisTime() {
-  delegate_->AcceptThisTime();
+void PermissionPromptAndroid::AcceptThisTime(content_settings::mojom::LifetimeMode lifetimeOption) {
+  delegate_->AcceptThisTime(lifetimeOption);
+}
+
+void PermissionPromptAndroid::DenyThisTime(content_settings::mojom::LifetimeMode lifetimeOption) {
+  delegate_->DenyThisTime(lifetimeOption);
 }
 
 void PermissionPromptAndroid::Deny() {
diff --git a/components/permissions/android/permission_prompt/permission_prompt_android.h b/components/permissions/android/permission_prompt/permission_prompt_android.h
--- a/components/permissions/android/permission_prompt/permission_prompt_android.h
+++ b/components/permissions/android/permission_prompt/permission_prompt_android.h
@@ -54,9 +54,10 @@ class PermissionPromptAndroid : public PermissionPrompt {
       const;
   virtual void Closing();
   virtual void Accept();
-  virtual void AcceptThisTime();
+  virtual void AcceptThisTime(content_settings::mojom::LifetimeMode lifetimeOption);
   virtual void Acknowledge() {}
   virtual void Deny();
+  virtual void DenyThisTime(content_settings::mojom::LifetimeMode lifetimeOption);
   virtual void Resumed() {}
   virtual void SystemSettingsShown() {}
   virtual void SystemPermissionResolved(bool accepted) {}
diff --git a/components/permissions/android/permissions_android_strings.grd b/components/permissions/android/permissions_android_strings.grd
--- a/components/permissions/android/permissions_android_strings.grd
+++ b/components/permissions/android/permissions_android_strings.grd
@@ -267,6 +267,23 @@
         Unknown or unsupported device (<ph name="DEVICE_ID">%1$s<ex>A1:B2:C3:D4:E5:F6</ex></ph>)
       </message>
 
+      <!-- Session permissions -->
+      <message name="IDS_SESSION_PERMISSIONS_TITLE" desc="Title for the session section in the permission request">
+        Remeber my decision
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_ONLY_THIS_THIS" desc="Message indicating that the permission is only for this time">
+        Only this time
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_UNTIL_PAGE_CLOSE" desc="Message indicating that the permission is deleted after navigating away from the page">
+        Until all pages of this origin are closed
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_UNTIL_BROWSER_CLOSE" desc="Message indicating that the permission is for the session only">
+        Until Bromite is closed
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_FOREVER" desc="Message indicating that the permission is for all sessions">
+        Forever
+      </message>
+
       <!-- Item Chooser UI strings -->
       <message name="IDS_ITEM_CHOOSER_ITEM_NAME_WITH_ID" desc="To distinguish items with the same name, the item chooser shows the item name with id.">
         <ph name="ITEM_NAME">%1$s<ex>item_name</ex></ph> (<ph name="ITEM_ID">%2$s<ex>item id</ex></ph>)
diff --git a/components/permissions/contexts/geolocation_permission_context_android.cc b/components/permissions/contexts/geolocation_permission_context_android.cc
--- a/components/permissions/contexts/geolocation_permission_context_android.cc
+++ b/components/permissions/contexts/geolocation_permission_context_android.cc
@@ -168,7 +168,20 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
     bool is_one_time,
     bool is_final_decision) {
   DCHECK(is_final_decision);
+  NotifyPermissionSetWithLifetime(id, requesting_origin, embedding_origin,
+    std::move(callback), persist, content_setting, is_one_time, is_final_decision,
+    content_settings::mojom::LifetimeMode::ALWAYS);
+}
 
+void GeolocationPermissionContextAndroid::NotifyPermissionSetWithLifetime(
+    const PermissionRequestID& id,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin,
+    BrowserPermissionCallback callback,
+    bool persist,
+    ContentSetting content_setting,
+    bool is_one_time, bool is_final_decision,
+    content_settings::mojom::LifetimeMode lifetime_option) {
   bool is_default_search = IsRequestingOriginDSE(requesting_origin);
   if (content_setting == CONTENT_SETTING_ALLOW &&
       !location_settings_->IsSystemLocationSettingEnabled()) {
@@ -181,7 +194,8 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
     if (IsInLocationSettingsBackOff(is_default_search)) {
       FinishNotifyPermissionSet(id, requesting_origin, embedding_origin,
                                 std::move(callback), false /* persist */,
-                                CONTENT_SETTING_BLOCK, is_one_time);
+                                CONTENT_SETTING_BLOCK,
+                                is_one_time, lifetime_option);
       return;
     }
 
@@ -199,7 +213,8 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
         !location_settings_dialog_callback_.is_null()) {
       FinishNotifyPermissionSet(id, requesting_origin, embedding_origin,
                                 std::move(callback), false /* persist */,
-                                CONTENT_SETTING_BLOCK, is_one_time);
+                                CONTENT_SETTING_BLOCK,
+                                is_one_time, lifetime_option);
       return;
     }
 
@@ -211,13 +226,13 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
         base::BindOnce(
             &GeolocationPermissionContextAndroid::OnLocationSettingsDialogShown,
             weak_factory_.GetWeakPtr(), requesting_origin, embedding_origin,
-            persist, content_setting, is_one_time));
+            persist, content_setting, is_one_time, lifetime_option));
     return;
   }
 
   FinishNotifyPermissionSet(id, requesting_origin, embedding_origin,
                             std::move(callback), persist, content_setting,
-                            is_one_time);
+                            is_one_time, lifetime_option);
 }
 
 content::PermissionResult
@@ -390,7 +405,7 @@ void GeolocationPermissionContextAndroid::OnLocationSettingsDialogShown(
     const GURL& embedding_origin,
     bool persist,
     ContentSetting content_setting,
-    bool is_one_time,
+    bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option,
     LocationSettingsDialogOutcome prompt_outcome) {
   bool is_default_search = IsRequestingOriginDSE(requesting_origin);
   if (prompt_outcome == GRANTED) {
@@ -409,7 +424,8 @@ void GeolocationPermissionContextAndroid::OnLocationSettingsDialogShown(
   FinishNotifyPermissionSet(location_settings_dialog_request_id_,
                             requesting_origin, embedding_origin,
                             std::move(location_settings_dialog_callback_),
-                            persist, content_setting, is_one_time);
+                            persist, content_setting, is_one_time,
+                            lifetime_option);
 
   location_settings_dialog_request_id_ =
       PermissionRequestID(content::GlobalRenderFrameHostId(0, 0),
@@ -423,10 +439,10 @@ void GeolocationPermissionContextAndroid::FinishNotifyPermissionSet(
     BrowserPermissionCallback callback,
     bool persist,
     ContentSetting content_setting,
-    bool is_one_time) {
-  GeolocationPermissionContext::NotifyPermissionSet(
+    bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option) {
+  GeolocationPermissionContext::NotifyPermissionSetWithLifetime(
       id, requesting_origin, embedding_origin, std::move(callback), persist,
-      content_setting, is_one_time, /*is_final_decision=*/true);
+      content_setting, is_one_time, /*is_final_decision=*/true, lifetime_option);
 }
 
 void GeolocationPermissionContextAndroid::SetLocationSettingsForTesting(
diff --git a/components/permissions/contexts/geolocation_permission_context_android.h b/components/permissions/contexts/geolocation_permission_context_android.h
--- a/components/permissions/contexts/geolocation_permission_context_android.h
+++ b/components/permissions/contexts/geolocation_permission_context_android.h
@@ -89,6 +89,15 @@ class GeolocationPermissionContextAndroid
                            ContentSetting content_setting,
                            bool is_one_time,
                            bool is_final_decision) override;
+  void NotifyPermissionSetWithLifetime(const PermissionRequestID& id,
+                           const GURL& requesting_origin,
+                           const GURL& embedding_origin,
+                           BrowserPermissionCallback callback,
+                           bool persist,
+                           ContentSetting content_setting,
+                           bool is_one_time,
+                           bool is_final_decision,
+                           content_settings::mojom::LifetimeMode lifetime_option) override;
   content::PermissionResult UpdatePermissionStatusWithDeviceStatus(
       content::WebContents* web_contents,
       content::PermissionResult result,
@@ -134,6 +143,7 @@ class GeolocationPermissionContextAndroid
       bool persist,
       ContentSetting content_setting,
       bool is_one_time,
+      content_settings::mojom::LifetimeMode lifetime_option,
       LocationSettingsDialogOutcome prompt_outcome);
 
   void FinishNotifyPermissionSet(const PermissionRequestID& id,
@@ -142,7 +152,8 @@ class GeolocationPermissionContextAndroid
                                  BrowserPermissionCallback callback,
                                  bool persist,
                                  ContentSetting content_setting,
-                                 bool is_one_time);
+                                 bool is_one_time,
+                                 content_settings::mojom::LifetimeMode lifetime_option);
 
   std::unique_ptr<LocationSettings> location_settings_;
 
diff --git a/components/permissions/embedded_permission_prompt_flow_model.cc b/components/permissions/embedded_permission_prompt_flow_model.cc
--- a/components/permissions/embedded_permission_prompt_flow_model.cc
+++ b/components/permissions/embedded_permission_prompt_flow_model.cc
@@ -295,7 +295,7 @@ void EmbeddedPermissionPromptFlowModel::SetDelegateAction(
       delegate_->Accept();
       break;
     case DelegateAction::kAllowThisTime:
-      delegate_->AcceptThisTime();
+      delegate_->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       break;
     case DelegateAction::kDeny:
       delegate_->Deny();
diff --git a/components/permissions/permission_context_base.cc b/components/permissions/permission_context_base.cc
--- a/components/permissions/permission_context_base.cc
+++ b/components/permissions/permission_context_base.cc
@@ -271,6 +271,17 @@ GURL PermissionContextBase::GetEffectiveEmbedderOrigin(
   return PermissionUtil::GetLastCommittedOriginAsURL(rfh->GetMainFrame());
 }
 
+std::unique_ptr<PermissionRequest>
+PermissionContextBase::CreatePermissionRequest(
+    content::WebContents* web_contents,
+    PermissionRequestData request_data,
+    PermissionRequest::PermissionDecidedCallbackWithLifetime permission_decided_callback,
+    base::OnceClosure delete_callback) const {
+  return std::make_unique<PermissionRequest>(
+      std::move(request_data), std::move(permission_decided_callback),
+      std::move(delete_callback));
+}
+
 content::PermissionResult PermissionContextBase::GetPermissionStatus(
     content::RenderFrameHost* render_frame_host,
     const GURL& requesting_origin,
@@ -530,7 +541,8 @@ void PermissionContextBase::PermissionDecided(const PermissionRequestID& id,
                                               const GURL& embedding_origin,
                                               ContentSetting content_setting,
                                               bool is_one_time,
-                                              bool is_final_decision) {
+                                              bool is_final_decision,
+                                              content_settings::mojom::LifetimeMode lifetime_option) {
   DCHECK(content_setting == CONTENT_SETTING_ALLOW ||
          content_setting == CONTENT_SETTING_BLOCK ||
          content_setting == CONTENT_SETTING_DEFAULT);
@@ -545,13 +557,14 @@ void PermissionContextBase::PermissionDecided(const PermissionRequestID& id,
   // missing if a permission prompt was preignored and we already notified an
   // origin about it.
   if (request->second.second) {
-    NotifyPermissionSet(id, requesting_origin, embedding_origin,
+    NotifyPermissionSetWithLifetime(id, requesting_origin, embedding_origin,
                         std::move(request->second.second), persist,
-                        content_setting, is_one_time, is_final_decision);
+                        content_setting, is_one_time, is_final_decision,
+                        lifetime_option);
   } else {
-    NotifyPermissionSet(id, requesting_origin, embedding_origin,
+    NotifyPermissionSetWithLifetime(id, requesting_origin, embedding_origin,
                         base::DoNothing(), persist, content_setting,
-                        is_one_time, is_final_decision);
+                        is_one_time, is_final_decision, lifetime_option);
   }
 }
 
@@ -632,11 +645,27 @@ void PermissionContextBase::NotifyPermissionSet(
     ContentSetting content_setting,
     bool is_one_time,
     bool is_final_decision) {
+  DCHECK(is_one_time == false);
+  NotifyPermissionSetWithLifetime(id, requesting_origin, embedding_origin, std::move(callback),
+     persist, content_setting, is_one_time, is_final_decision,
+     content_settings::mojom::LifetimeMode::ALWAYS);
+}
+
+void PermissionContextBase::NotifyPermissionSetWithLifetime(
+    const PermissionRequestID& id,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin,
+    BrowserPermissionCallback callback,
+    bool persist,
+    ContentSetting content_setting,
+    bool is_one_time,
+    bool is_final_decision,
+    content_settings::mojom::LifetimeMode lifetime_option) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   if (persist) {
     UpdateContentSetting(requesting_origin, embedding_origin, content_setting,
-                         is_one_time);
+                         is_one_time, lifetime_option);
   }
 
   if (is_final_decision) {
@@ -677,6 +706,15 @@ void PermissionContextBase::UpdateContentSetting(const GURL& requesting_origin,
                                                  const GURL& embedding_origin,
                                                  ContentSetting content_setting,
                                                  bool is_one_time) {
+  UpdateContentSetting(requesting_origin, embedding_origin, content_setting,
+    is_one_time, content_settings::mojom::LifetimeMode::ALWAYS);
+}
+
+void PermissionContextBase::UpdateContentSetting(const GURL& requesting_origin,
+                                                 const GURL& embedding_origin,
+                                                 ContentSetting content_setting,
+                                                 bool is_one_time,
+                                                 content_settings::mojom::LifetimeMode lifetime_option) {
   DCHECK_EQ(requesting_origin, requesting_origin.DeprecatedGetOriginAsURL());
   DCHECK_EQ(embedding_origin, embedding_origin.DeprecatedGetOriginAsURL());
   DCHECK(content_setting == CONTENT_SETTING_ALLOW ||
@@ -686,6 +724,8 @@ void PermissionContextBase::UpdateContentSetting(const GURL& requesting_origin,
   constraints.set_session_model(
       is_one_time ? content_settings::mojom::SessionModel::ONE_TIME
                   : content_settings::mojom::SessionModel::DURABLE);
+  if (is_one_time)
+    constraints = content_settings::GetConstraintSessionExpiration(lifetime_option);
 
   // The Permissions module in Safety check will revoke permissions after
   // a finite amount of time if the permission can be revoked.
diff --git a/components/permissions/permission_context_base.h b/components/permissions/permission_context_base.h
--- a/components/permissions/permission_context_base.h
+++ b/components/permissions/permission_context_base.h
@@ -166,6 +166,15 @@ class PermissionContextBase : public content_settings::Observer {
 
   // Updates stored content setting if persist is set, updates tab indicators
   // and runs the callback to finish the request.
+  virtual void NotifyPermissionSetWithLifetime(const PermissionRequestID& id,
+                                   const GURL& requesting_origin,
+                                   const GURL& embedding_origin,
+                                   BrowserPermissionCallback callback,
+                                   bool persist,
+                                   ContentSetting content_setting,
+                                   bool is_one_time,
+                                   bool is_final_decision,
+                                   content_settings::mojom::LifetimeMode lifetime_option);
   virtual void NotifyPermissionSet(const PermissionRequestID& id,
                                    const GURL& requesting_origin,
                                    const GURL& embedding_origin,
@@ -187,6 +196,11 @@ class PermissionContextBase : public content_settings::Observer {
   // Store the decided permission as a content setting.
   // virtual since the permission might be stored with different restrictions
   // (for example for desktop notifications).
+  void UpdateContentSetting(const GURL& requesting_origin,
+                                    const GURL& embedding_origin,
+                                    ContentSetting content_setting,
+                                    bool is_one_time,
+                                    content_settings::mojom::LifetimeMode lifetime_option);
   virtual void UpdateContentSetting(const GURL& requesting_origin,
                                     const GURL& embedding_origin,
                                     ContentSetting content_setting,
@@ -217,6 +231,12 @@ class PermissionContextBase : public content_settings::Observer {
       PermissionRequest::PermissionDecidedCallback permission_decided_callback,
       base::OnceClosure delete_callback) const;
 
+  virtual std::unique_ptr<PermissionRequest> CreatePermissionRequest(
+      content::WebContents* web_contents,
+      PermissionRequestData request_data,
+      PermissionRequest::PermissionDecidedCallbackWithLifetime permission_decided_callback,
+      base::OnceClosure delete_callback) const;
+
   // Implementors can override this method to avoid using automatic embargo.
   virtual bool UsesAutomaticEmbargo() const;
 
@@ -253,7 +273,8 @@ class PermissionContextBase : public content_settings::Observer {
                          const GURL& embedding_origin,
                          ContentSetting content_setting,
                          bool is_one_time,
-                         bool is_final_decision);
+                         bool is_final_decision,
+                         content_settings::mojom::LifetimeMode lifetime_option);
 
   void NotifyObservers(const ContentSettingsPattern& primary_pattern,
                        const ContentSettingsPattern& secondary_pattern,
diff --git a/components/permissions/permission_prompt.h b/components/permissions/permission_prompt.h
--- a/components/permissions/permission_prompt.h
+++ b/components/permissions/permission_prompt.h
@@ -68,8 +68,9 @@ class PermissionPrompt {
     virtual GURL GetEmbeddingOrigin() const = 0;
 
     virtual void Accept() = 0;
-    virtual void AcceptThisTime() = 0;
+    virtual void AcceptThisTime(content_settings::mojom::LifetimeMode lifetime_option) = 0;
     virtual void Deny() = 0;
+    virtual void DenyThisTime(content_settings::mojom::LifetimeMode lifetime_option) = 0;
     virtual void Dismiss() = 0;
     virtual void Ignore() = 0;
 
diff --git a/components/permissions/permission_request.cc b/components/permissions/permission_request.cc
--- a/components/permissions/permission_request.cc
+++ b/components/permissions/permission_request.cc
@@ -43,6 +43,14 @@ PermissionRequest::PermissionRequest(
       delete_callback_(std::move(delete_callback)),
       uses_automatic_embargo_(uses_automatic_embargo) {}
 
+PermissionRequest::PermissionRequest(
+    PermissionRequestData request_data,
+    PermissionDecidedCallbackWithLifetime permission_decided_callback,
+    base::OnceClosure delete_callback)
+    : data_(std::move(request_data)),
+      permission_decided_callback_withlifetime_(std::move(permission_decided_callback)),
+      delete_callback_(std::move(delete_callback)) {}
+
 PermissionRequest::~PermissionRequest() {
   DCHECK(delete_callback_.is_null());
 }
@@ -423,19 +431,37 @@ bool PermissionRequest::ShouldUseTwoOriginPrompt() const {
   return request_type() == RequestType::kStorageAccess;
 }
 
-void PermissionRequest::PermissionGranted(bool is_one_time) {
+void PermissionRequest::PermissionGranted(bool is_one_time,
+                            content_settings::mojom::LifetimeMode lifetime_option) {
+  if (permission_decided_callback_withlifetime_) {
+    std::move(permission_decided_callback_withlifetime_)
+        .Run(CONTENT_SETTING_ALLOW, is_one_time, /*is_final_decision=*/true, lifetime_option);
+    return;
+  }
   std::move(permission_decided_callback_)
       .Run(CONTENT_SETTING_ALLOW, is_one_time,
            /*is_final_decision=*/true);
 }
 
-void PermissionRequest::PermissionDenied() {
+void PermissionRequest::PermissionDenied(bool is_one_time,
+                            content_settings::mojom::LifetimeMode lifetime_option) {
+  if (permission_decided_callback_withlifetime_) {
+    std::move(permission_decided_callback_withlifetime_)
+        .Run(CONTENT_SETTING_BLOCK, is_one_time, /*is_final_decision=*/true, lifetime_option);
+    return;
+  }
   std::move(permission_decided_callback_)
       .Run(CONTENT_SETTING_BLOCK, /*is_one_time=*/false,
            /*is_final_decision=*/true);
 }
 
 void PermissionRequest::Cancelled(bool is_final_decision) {
+  if (permission_decided_callback_withlifetime_) {
+    std::move(permission_decided_callback_withlifetime_)
+        .Run(CONTENT_SETTING_DEFAULT, false, is_final_decision,
+             content_settings::mojom::LifetimeMode::ALWAYS);
+    return;
+  }
   if (permission_decided_callback_) {
     permission_decided_callback_.Run(CONTENT_SETTING_DEFAULT,
                                      /*is_one_time=*/false, is_final_decision);
diff --git a/components/permissions/permission_request.h b/components/permissions/permission_request.h
--- a/components/permissions/permission_request.h
+++ b/components/permissions/permission_request.h
@@ -43,6 +43,11 @@ class PermissionRequest {
                                    bool /*is_one_time*/,
                                    bool /*is_final_decision*/)>;
 
+  using PermissionDecidedCallbackWithLifetime =
+      base::OnceCallback<void(ContentSetting /*result*/, bool /*is_one_time*/,
+        bool /*is_final_decision*/,
+        content_settings::mojom::LifetimeMode /*lifetime_option*/)>;
+
   // `permission_decided_callback` is called when the permission request is
   // resolved by the user (see comment on PermissionDecidedCallback above).
   // `delete_callback` is called when the permission request is no longer needed
@@ -63,6 +68,10 @@ class PermissionRequest {
                     base::OnceClosure delete_callback,
                     bool uses_automatic_embargo);
 
+  PermissionRequest(PermissionRequestData request_data,
+                    PermissionDecidedCallbackWithLifetime permission_decided_callback,
+                    base::OnceClosure delete_callback);
+
   PermissionRequest(const PermissionRequest&) = delete;
   PermissionRequest& operator=(const PermissionRequest&) = delete;
 
@@ -169,10 +178,10 @@ class PermissionRequest {
   // If |is_one_time| is true the permission will last until all tabs of
   // |origin| are closed or navigated away from, and then the permission will
   // automatically expire after 1 day.
-  void PermissionGranted(bool is_one_time);
+  void PermissionGranted(bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option);
 
   // Called when the user has denied the requested permission.
-  void PermissionDenied();
+  void PermissionDenied(bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option);
 
   // Called when the user has cancelled the permission request. This
   // corresponds to a denial, but is segregated in case the context needs to
@@ -228,6 +237,9 @@ class PermissionRequest {
   // Called once a decision is made about the permission.
   PermissionDecidedCallback permission_decided_callback_;
 
+  // Called once a decision is made about the permission (with lifetime option).
+  PermissionDecidedCallbackWithLifetime permission_decided_callback_withlifetime_;
+
   // Called when the request is no longer in use so it can be deleted by the
   // caller.
   base::OnceClosure delete_callback_;
diff --git a/components/permissions/permission_request_manager.cc b/components/permissions/permission_request_manager.cc
--- a/components/permissions/permission_request_manager.cc
+++ b/components/permissions/permission_request_manager.cc
@@ -171,7 +171,7 @@ void PermissionRequestManager::AddRequest(
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kDenyPermissionPrompts)) {
-    request->PermissionDenied();
+    request->PermissionDenied(/*is_one_time*/false, content_settings::mojom::LifetimeMode::ALWAYS);
     request->RequestFinished();
     return;
   }
@@ -246,7 +246,7 @@ void PermissionRequestManager::AddRequest(
 
   if (should_auto_approve_request) {
     if (should_auto_approve_request == PermissionAction::GRANTED) {
-      request->PermissionGranted(/*is_one_time=*/true);
+      request->PermissionGranted(/*is_one_time=*/true, content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED);
     }
     request->RequestFinished();
     return;
@@ -609,7 +609,8 @@ void PermissionRequestManager::Accept() {
                                 (*requests_iter)->request_type(),
                                 PermissionAction::GRANTED);
     PermissionGrantedIncludingDuplicates(*requests_iter,
-                                         /*is_one_time=*/false);
+                                         /*is_one_time=*/false,
+                                         content_settings::mojom::LifetimeMode::ALWAYS);
 
 #if !BUILDFLAG(IS_ANDROID)
     std::optional<ContentSettingsType> content_settings_type =
@@ -627,7 +628,7 @@ void PermissionRequestManager::Accept() {
   CurrentRequestsDecided(PermissionAction::GRANTED);
 }
 
-void PermissionRequestManager::AcceptThisTime() {
+void PermissionRequestManager::AcceptThisTime(content_settings::mojom::LifetimeMode mode) {
   if (ignore_callbacks_from_prompt_)
     return;
   DCHECK(view_);
@@ -640,7 +641,8 @@ void PermissionRequestManager::AcceptThisTime() {
                                 (*requests_iter)->request_type(),
                                 PermissionAction::GRANTED_ONCE);
     PermissionGrantedIncludingDuplicates(*requests_iter,
-                                         /*is_one_time=*/true);
+                                         /*is_one_time=*/true,
+                                         mode);
   }
 
   NotifyRequestDecided(PermissionAction::GRANTED_ONCE);
@@ -648,6 +650,15 @@ void PermissionRequestManager::AcceptThisTime() {
 }
 
 void PermissionRequestManager::Deny() {
+  Deny_(/*is_one_time*/ false, content_settings::mojom::LifetimeMode::ALWAYS);
+}
+
+void PermissionRequestManager::DenyThisTime(content_settings::mojom::LifetimeMode mode) {
+  Deny_(/*is_one_time*/ true, mode);
+}
+
+void PermissionRequestManager::Deny_(bool is_one_time,
+                                     content_settings::mojom::LifetimeMode lifetime_option) {
   if (ignore_callbacks_from_prompt_)
     return;
   DCHECK(view_);
@@ -670,7 +681,7 @@ void PermissionRequestManager::Deny() {
     StorePermissionActionForUMA((*requests_iter)->requesting_origin(),
                                 (*requests_iter)->request_type(),
                                 PermissionAction::DENIED);
-    PermissionDeniedIncludingDuplicates(*requests_iter);
+    PermissionDeniedIncludingDuplicates(*requests_iter, is_one_time, lifetime_option);
   }
 
   NotifyRequestDecided(PermissionAction::DENIED);
@@ -1267,32 +1278,32 @@ PermissionRequestManager::VisitDuplicateRequests(
 
 void PermissionRequestManager::PermissionGrantedIncludingDuplicates(
     PermissionRequest* request,
-    bool is_one_time) {
+    bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option) {
   DCHECK_EQ(1ul, std::ranges::count(requests_, request) +
                      pending_permission_requests_.Count(request))
       << "Only requests in [pending_permission_]requests_ can have duplicates";
-  request->PermissionGranted(is_one_time);
+  request->PermissionGranted(is_one_time, lifetime_option);
   VisitDuplicateRequests(
       base::BindRepeating(
-          [](bool is_one_time,
+          [](bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option,
              const base::WeakPtr<PermissionRequest>& weak_request) {
-            weak_request->PermissionGranted(is_one_time);
+            weak_request->PermissionGranted(is_one_time, lifetime_option);
           },
-          is_one_time),
+          is_one_time, lifetime_option),
       request);
 }
 
 void PermissionRequestManager::PermissionDeniedIncludingDuplicates(
-    PermissionRequest* request) {
+    PermissionRequest* request, bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option) {
   DCHECK_EQ(1ul, std::ranges::count(requests_, request) +
                      pending_permission_requests_.Count(request))
       << "Only requests in [pending_permission_]requests_ can have duplicates";
-  request->PermissionDenied();
+  request->PermissionDenied(is_one_time, lifetime_option);
   VisitDuplicateRequests(
       base::BindRepeating(
-          [](const base::WeakPtr<PermissionRequest>& weak_request) {
-            weak_request->PermissionDenied();
-          }),
+          [](bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option, const base::WeakPtr<PermissionRequest>& weak_request) {
+            weak_request->PermissionDenied(is_one_time, lifetime_option);
+          }, is_one_time, lifetime_option),
       request);
 }
 
@@ -1562,7 +1573,7 @@ void PermissionRequestManager::DoAutoResponseForTesting() {
   }
   switch (auto_response_for_test_) {
     case ACCEPT_ONCE:
-      AcceptThisTime();
+      AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       break;
     case ACCEPT_ALL:
       Accept();
diff --git a/components/permissions/permission_request_manager.h b/components/permissions/permission_request_manager.h
--- a/components/permissions/permission_request_manager.h
+++ b/components/permissions/permission_request_manager.h
@@ -165,8 +165,10 @@ class PermissionRequestManager
   GURL GetRequestingOrigin() const override;
   GURL GetEmbeddingOrigin() const override;
   void Accept() override;
-  void AcceptThisTime() override;
+  void AcceptThisTime(content_settings::mojom::LifetimeMode lifetime_option) override;
   void Deny() override;
+  void Deny_(bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option);
+  void DenyThisTime(content_settings::mojom::LifetimeMode lifetime_option) override;
   void Dismiss() override;
   void Ignore() override;
   void FinalizeCurrentRequests() override;
@@ -383,9 +385,12 @@ class PermissionRequestManager
 
   // Calls PermissionGranted on a request and all its duplicates.
   void PermissionGrantedIncludingDuplicates(PermissionRequest* request,
-                                            bool is_one_time);
+                                            bool is_one_time,
+                                            content_settings::mojom::LifetimeMode lifetime_option);
   // Calls PermissionDenied on a request and all its duplicates.
-  void PermissionDeniedIncludingDuplicates(PermissionRequest* request);
+  void PermissionDeniedIncludingDuplicates(PermissionRequest* request,
+                                           bool is_one_time,
+                                           content_settings::mojom::LifetimeMode lifetime_option);
   // Calls Cancelled on a request and all its duplicates.
   void CancelledIncludingDuplicates(PermissionRequest* request,
                                     bool is_final_decision = true);
-- 

