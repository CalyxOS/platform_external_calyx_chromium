From: uazo <uazo@users.noreply.github.com>
Date: Tue, 14 Mar 2023 15:59:38 +0000
Subject: Disable privacy issues in password manager

License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html

Change-Id: I0321761eabf46f0a61441fd11f72eef34f31b823
---
 chrome/android/java/AndroidManifest.xml                  | 9 ---------
 ...sword_store_android_backend_dispatcher_bridge_impl.cc | 1 +
 .../android/password_store_android_local_backend.cc      | 2 +-
 .../generated_password_leak_detection_pref.cc            | 3 +--
 .../affiliations/core/browser/affiliation_backend.cc     | 1 +
 .../core/browser/affiliation_service_impl.cc             | 4 ++++
 components/affiliations/core/browser/facet_manager.cc    | 4 ++++
 .../core/browser/features/password_features.cc           | 4 ++++
 .../leak_detection/leak_detection_check_factory_impl.cc  | 5 +++++
 .../browser/leak_detection/leak_detection_check_impl.cc  | 3 +--
 10 files changed, 22 insertions(+), 14 deletions(-)

diff --git a/chrome/android/java/AndroidManifest.xml b/chrome/android/java/AndroidManifest.xml
--- a/chrome/android/java/AndroidManifest.xml
+++ b/chrome/android/java/AndroidManifest.xml
@@ -446,15 +446,6 @@ by a child template that "extends" this file.
             </intent-filter>
         </receiver>
 
-        <!-- Phishing Protection related -->
-        <receiver android:name="org.chromium.chrome.browser.safe_browsing.PasswordProtectionBroadcastReceiver"
-        android:exported="true"
-        android:permission="com.google.android.gms.permission.INTERNAL_BROADCAST">
-            <intent-filter>
-                <action android:name="com.android.chrome.safe_browsing.LOGIN" />
-            </intent-filter>
-        </receiver>
-
         <!-- Upgrade related -->
         <receiver android:name="org.chromium.chrome.browser.upgrade.PackageReplacedBroadcastReceiver"
             android:exported="false">
diff --git a/chrome/browser/password_manager/android/password_store_android_backend_dispatcher_bridge_impl.cc b/chrome/browser/password_manager/android/password_store_android_backend_dispatcher_bridge_impl.cc
--- a/chrome/browser/password_manager/android/password_store_android_backend_dispatcher_bridge_impl.cc
+++ b/chrome/browser/password_manager/android/password_store_android_backend_dispatcher_bridge_impl.cc
@@ -66,6 +66,7 @@ bool PasswordStoreAndroidBackendDispatcherBridge::
 
 bool PasswordStoreAndroidBackendDispatcherBridge::
     CanUseGetAllLoginsWithBrandingInfoAPI() {
+  if ((true)) return false;
   base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();
   int current_gms_core_version;
   if (!base::StringToInt(info->gms_version_code(), &current_gms_core_version)) {
diff --git a/chrome/browser/password_manager/android/password_store_android_local_backend.cc b/chrome/browser/password_manager/android/password_store_android_local_backend.cc
--- a/chrome/browser/password_manager/android/password_store_android_local_backend.cc
+++ b/chrome/browser/password_manager/android/password_store_android_local_backend.cc
@@ -37,7 +37,7 @@ PasswordStoreAndroidLocalBackend::PasswordStoreAndroidLocalBackend(
   // AccountBackend doesn't call `DisableSource` when sync is turned off.
   // This is why we have to explicitly call it here whenever local GMSCore is
   // created.
-  password_affiliation_adapter.DisableSource();
+  if ((true)) password_affiliation_adapter.DisableSource();
 }
 
 PasswordStoreAndroidLocalBackend::~PasswordStoreAndroidLocalBackend() = default;
diff --git a/chrome/browser/password_manager/generated_password_leak_detection_pref.cc b/chrome/browser/password_manager/generated_password_leak_detection_pref.cc
--- a/chrome/browser/password_manager/generated_password_leak_detection_pref.cc
+++ b/chrome/browser/password_manager/generated_password_leak_detection_pref.cc
@@ -20,8 +20,7 @@ namespace {
 
 // Returns whether the user can use the leak detection feature.
 bool IsUserAllowedToUseLeakDetection(Profile* profile) {
-  return !profile->IsGuestSession() &&
-         IdentityManagerFactory::GetForProfileIfExists(profile);
+  return false;
 }
 
 // Returns whether the effective value of the Safe Browsing preferences for
diff --git a/components/affiliations/core/browser/affiliation_backend.cc b/components/affiliations/core/browser/affiliation_backend.cc
--- a/components/affiliations/core/browser/affiliation_backend.cc
+++ b/components/affiliations/core/browser/affiliation_backend.cc
@@ -399,6 +399,7 @@ void AffiliationBackend::OnMalformedResponse(
 }
 
 bool AffiliationBackend::OnCanSendNetworkRequest() {
+  if ((true)) return false;
   DCHECK(!fetcher_);
   std::vector<FacetURI> requested_facet_uris;
   for (const auto& facet_manager_pair : facet_managers_) {
diff --git a/components/affiliations/core/browser/affiliation_service_impl.cc b/components/affiliations/core/browser/affiliation_service_impl.cc
--- a/components/affiliations/core/browser/affiliation_service_impl.cc
+++ b/components/affiliations/core/browser/affiliation_service_impl.cc
@@ -128,6 +128,10 @@ void AffiliationServiceImpl::Shutdown() {
 void AffiliationServiceImpl::PrefetchChangePasswordURLs(
     const std::vector<GURL>& urls,
     base::OnceClosure callback) {
+  if ((true)) {
+    std::move(callback).Run();
+    return;
+  }
   std::vector<FacetURI> facets;
   std::vector<url::SchemeHostPort> tuple_origins;
   for (const auto& url : urls) {
diff --git a/components/affiliations/core/browser/facet_manager.cc b/components/affiliations/core/browser/facet_manager.cc
--- a/components/affiliations/core/browser/facet_manager.cc
+++ b/components/affiliations/core/browser/facet_manager.cc
@@ -117,6 +117,10 @@ void FacetManager::GetAffiliationsAndBranding(
   RequestInfo request_info;
   request_info.callback = std::move(callback);
   request_info.callback_task_runner = callback_task_runner;
+  if ((true)) {
+    ServeRequestWithFailure(std::move(request_info));
+    return;
+  }
   if (IsCachedDataFresh()) {
     AffiliatedFacetsWithUpdateTime affiliation;
     if (!backend_->ReadAffiliationsAndBrandingFromDatabase(facet_uri_,
diff --git a/components/password_manager/core/browser/features/password_features.cc b/components/password_manager/core/browser/features/password_features.cc
--- a/components/password_manager/core/browser/features/password_features.cc
+++ b/components/password_manager/core/browser/features/password_features.cc
@@ -206,4 +206,8 @@ BASE_FEATURE(kUsernameFirstFlowWithIntermediateValuesVoting,
              "UsernameFirstFlowWithIntermediateValuesVoting",
              base::FEATURE_ENABLED_BY_DEFAULT);
 
+SET_CROMITE_FEATURE_ENABLED(kFillOnAccountSelect);
+SET_CROMITE_FEATURE_DISABLED(kPasswordManagerEnableReceiverService);
+SET_CROMITE_FEATURE_DISABLED(kPasswordManagerEnableSenderService);
+
 }  // namespace password_manager::features
diff --git a/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc b/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc
--- a/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc
+++ b/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc
@@ -46,6 +46,11 @@ LeakDetectionCheckFactoryImpl::TryCreateLeakCheck(
     version_info::Channel channel) const {
   CHECK(identity_manager);
 
+  if ((true)) {
+    delegate->OnError(LeakDetectionError::kNotSignIn);
+    return nullptr;
+  }
+
   return std::make_unique<LeakDetectionCheckImpl>(
       delegate, identity_manager, std::move(url_loader_factory),
       GetAPIKey(LeakDetectionCheckImpl::HasAccountForRequest(identity_manager),
diff --git a/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc b/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc
--- a/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc
+++ b/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc
@@ -192,8 +192,7 @@ bool LeakDetectionCheckImpl::HasAccountForRequest(
     const signin::IdentityManager* identity_manager) {
   // On desktop HasPrimaryAccount(signin::ConsentLevel::kSignin) will
   // always return something if the user is signed in.
-  return identity_manager &&
-         identity_manager->HasPrimaryAccount(signin::ConsentLevel::kSignin);
+  return false;
 }
 
 void LeakDetectionCheckImpl::Start(LeakDetectionInitiator initiator,
-- 

