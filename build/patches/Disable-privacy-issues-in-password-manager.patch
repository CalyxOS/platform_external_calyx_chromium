From: uazo <uazo@users.noreply.github.com>
Date: Tue, 14 Mar 2023 15:59:38 +0000
Subject: Disable privacy issues in password manager

Need: Add-cromite-flags-support.patch
License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html

Change-Id: I0321761eabf46f0a61441fd11f72eef34f31b823
---
 chrome/android/java/AndroidManifest.xml                  | 9 ---------
 .../password_store_android_backend_bridge_helper_impl.cc | 1 +
 .../android/password_store_android_local_backend.cc      | 2 +-
 .../generated_password_leak_detection_pref.cc            | 3 +--
 .../password_receiver_service_factory.cc                 | 2 +-
 .../password_manager/password_sender_service_factory.cc  | 2 +-
 .../affiliations/core/browser/affiliation_backend.cc     | 1 +
 .../core/browser/affiliation_service_impl.cc             | 4 ++++
 components/affiliations/core/browser/facet_manager.cc    | 4 ++++
 .../leak_detection/leak_detection_check_factory_impl.cc  | 5 +++++
 .../browser/leak_detection/leak_detection_check_impl.cc  | 3 +--
 .../Disable-privacy-issues-in-password-manager.inc       | 1 +
 12 files changed, 21 insertions(+), 16 deletions(-)
 create mode 100644 cromite_flags/components/password_manager/core/browser/features/password_features_cc/Disable-privacy-issues-in-password-manager.inc

diff --git a/chrome/android/java/AndroidManifest.xml b/chrome/android/java/AndroidManifest.xml
--- a/chrome/android/java/AndroidManifest.xml
+++ b/chrome/android/java/AndroidManifest.xml
@@ -456,15 +456,6 @@ by a child template that "extends" this file.
             </intent-filter>
         </receiver>
 
-        <!-- Phishing Protection related -->
-        <receiver android:name="org.chromium.chrome.browser.safe_browsing.PasswordProtectionBroadcastReceiver"
-        android:exported="true"
-        android:permission="com.google.android.gms.permission.INTERNAL_BROADCAST">
-            <intent-filter>
-                <action android:name="com.android.chrome.safe_browsing.LOGIN" />
-            </intent-filter>
-        </receiver>
-
         <!-- Upgrade related -->
         <receiver android:name="org.chromium.chrome.browser.upgrade.PackageReplacedBroadcastReceiver"
             android:exported="false">
diff --git a/chrome/browser/password_manager/android/password_store_android_backend_bridge_helper_impl.cc b/chrome/browser/password_manager/android/password_store_android_backend_bridge_helper_impl.cc
--- a/chrome/browser/password_manager/android/password_store_android_backend_bridge_helper_impl.cc
+++ b/chrome/browser/password_manager/android/password_store_android_backend_bridge_helper_impl.cc
@@ -102,6 +102,7 @@ bool PasswordStoreAndroidBackendBridgeHelperImpl::
 
 bool PasswordStoreAndroidBackendBridgeHelperImpl::
     CanUseGetAllLoginsWithBrandingInfoAPI() {
+  if ((true)) return false;
   base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();
   int current_gms_core_version;
   if (!base::StringToInt(info->gms_version_code(), &current_gms_core_version)) {
diff --git a/chrome/browser/password_manager/android/password_store_android_local_backend.cc b/chrome/browser/password_manager/android/password_store_android_local_backend.cc
--- a/chrome/browser/password_manager/android/password_store_android_local_backend.cc
+++ b/chrome/browser/password_manager/android/password_store_android_local_backend.cc
@@ -37,7 +37,7 @@ PasswordStoreAndroidLocalBackend::PasswordStoreAndroidLocalBackend(
   // AccountBackend doesn't call `DisableSource` when sync is turned off.
   // This is why we have to explicitly call it here whenever local GMSCore is
   // created.
-  password_affiliation_adapter.DisableSource();
+  if ((true)) password_affiliation_adapter.DisableSource();
 }
 
 PasswordStoreAndroidLocalBackend::~PasswordStoreAndroidLocalBackend() = default;
diff --git a/chrome/browser/password_manager/generated_password_leak_detection_pref.cc b/chrome/browser/password_manager/generated_password_leak_detection_pref.cc
--- a/chrome/browser/password_manager/generated_password_leak_detection_pref.cc
+++ b/chrome/browser/password_manager/generated_password_leak_detection_pref.cc
@@ -22,8 +22,7 @@ namespace {
 
 // Returns whether the user can use the leak detection feature.
 bool IsUserAllowedToUseLeakDetection(Profile* profile) {
-  return !profile->IsGuestSession() &&
-         IdentityManagerFactory::GetForProfileIfExists(profile);
+  return false;
 }
 
 // Returns whether the effective value of the Safe Browsing preferences for
diff --git a/chrome/browser/password_manager/password_receiver_service_factory.cc b/chrome/browser/password_manager/password_receiver_service_factory.cc
--- a/chrome/browser/password_manager/password_receiver_service_factory.cc
+++ b/chrome/browser/password_manager/password_receiver_service_factory.cc
@@ -55,7 +55,7 @@ PasswordReceiverServiceFactory::BuildServiceInstanceForBrowserContext(
     content::BrowserContext* context) const {
 // Password receiving on Android is handled in GMSCore, and hence no service
 // should be instantiated.
-#if BUILDFLAG(IS_ANDROID)
+#if true
   return nullptr;
 #else
 
diff --git a/chrome/browser/password_manager/password_sender_service_factory.cc b/chrome/browser/password_manager/password_sender_service_factory.cc
--- a/chrome/browser/password_manager/password_sender_service_factory.cc
+++ b/chrome/browser/password_manager/password_sender_service_factory.cc
@@ -50,7 +50,7 @@ PasswordSenderServiceFactory::BuildServiceInstanceForBrowserContext(
     content::BrowserContext* context) const {
 // Password sending on Android is handled in GMSCore, and hence no service
 // should be instantiated.
-#if BUILDFLAG(IS_ANDROID)
+#if true
   return nullptr;
 #else
 
diff --git a/components/affiliations/core/browser/affiliation_backend.cc b/components/affiliations/core/browser/affiliation_backend.cc
--- a/components/affiliations/core/browser/affiliation_backend.cc
+++ b/components/affiliations/core/browser/affiliation_backend.cc
@@ -399,6 +399,7 @@ void AffiliationBackend::OnMalformedResponse(
 }
 
 bool AffiliationBackend::OnCanSendNetworkRequest() {
+  if ((true)) return false;
   DCHECK(!fetcher_);
   std::vector<FacetURI> requested_facet_uris;
   for (const auto& facet_manager_pair : facet_managers_) {
diff --git a/components/affiliations/core/browser/affiliation_service_impl.cc b/components/affiliations/core/browser/affiliation_service_impl.cc
--- a/components/affiliations/core/browser/affiliation_service_impl.cc
+++ b/components/affiliations/core/browser/affiliation_service_impl.cc
@@ -128,6 +128,10 @@ void AffiliationServiceImpl::Shutdown() {
 void AffiliationServiceImpl::PrefetchChangePasswordURLs(
     const std::vector<GURL>& urls,
     base::OnceClosure callback) {
+  if ((true)) {
+    std::move(callback).Run();
+    return;
+  }
   std::vector<FacetURI> facets;
   std::vector<url::SchemeHostPort> tuple_origins;
   for (const auto& url : urls) {
diff --git a/components/affiliations/core/browser/facet_manager.cc b/components/affiliations/core/browser/facet_manager.cc
--- a/components/affiliations/core/browser/facet_manager.cc
+++ b/components/affiliations/core/browser/facet_manager.cc
@@ -117,6 +117,10 @@ void FacetManager::GetAffiliationsAndBranding(
   RequestInfo request_info;
   request_info.callback = std::move(callback);
   request_info.callback_task_runner = callback_task_runner;
+  if ((true)) {
+    ServeRequestWithFailure(std::move(request_info));
+    return;
+  }
   if (IsCachedDataFresh()) {
     AffiliatedFacetsWithUpdateTime affiliation;
     if (!backend_->ReadAffiliationsAndBrandingFromDatabase(facet_uri_,
diff --git a/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc b/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc
--- a/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc
+++ b/components/password_manager/core/browser/leak_detection/leak_detection_check_factory_impl.cc
@@ -41,6 +41,11 @@ LeakDetectionCheckFactoryImpl::TryCreateLeakCheck(
     version_info::Channel channel) const {
   CHECK(identity_manager);
 
+  if ((true)) {
+    delegate->OnError(LeakDetectionError::kNotSignIn);
+    return nullptr;
+  }
+
   return std::make_unique<LeakDetectionCheckImpl>(
       delegate, identity_manager, std::move(url_loader_factory),
       GetAPIKey(LeakDetectionCheckImpl::HasAccountForRequest(identity_manager),
diff --git a/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc b/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc
--- a/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc
+++ b/components/password_manager/core/browser/leak_detection/leak_detection_check_impl.cc
@@ -194,8 +194,7 @@ bool LeakDetectionCheckImpl::HasAccountForRequest(
     const signin::IdentityManager* identity_manager) {
   // On desktop HasPrimaryAccount(signin::ConsentLevel::kSignin) will
   // always return something if the user is signed in.
-  return identity_manager &&
-         identity_manager->HasPrimaryAccount(signin::ConsentLevel::kSignin);
+  return false;
 }
 
 void LeakDetectionCheckImpl::Start(LeakDetectionInitiator initiator,
diff --git a/cromite_flags/components/password_manager/core/browser/features/password_features_cc/Disable-privacy-issues-in-password-manager.inc b/cromite_flags/components/password_manager/core/browser/features/password_features_cc/Disable-privacy-issues-in-password-manager.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/components/password_manager/core/browser/features/password_features_cc/Disable-privacy-issues-in-password-manager.inc
@@ -0,0 +1 @@
+SET_CROMITE_FEATURE_ENABLED(kFillOnAccountSelect);
-- 

