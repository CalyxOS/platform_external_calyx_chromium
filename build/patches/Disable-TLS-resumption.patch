From: uazo <uazo@users.noreply.github.com>
Date: Thu, 24 Mar 2022 10:08:00 +0000
Subject: Disable TLS resumption

Disable resumption feature for all HTTPS and QUIC connections;
the feature could be used to track users even without cookies.

Sessions are not currently saved to disk in Chromium (although
there is support for it) but are long enough to constitute a
privacy risk (2h for TLS 1.2 and 7 days for TLS 1.3) if user
does not frequently close the browser.

Since session information is not kept in the HTTP cache it is
not cleared when deleting navigation data (although it is possible
to clear it by selecting "passwords").

Two new user configurable flags are introduced:
* kDisableTLSResumption, active by default
* kLogTLSResumption, that would allow to find in logcat reused
  sessions in lines matching "SSL Log:"

See also:
* https://arxiv.org/abs/1810.07304

Original License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html
---
 chrome/browser/about_flags.cc            |  6 ++
 net/base/features.cc                     |  8 +++
 net/base/features.cc.rej                 | 17 +++++
 net/base/features.h                      |  6 ++
 net/base/features.h.rej                  | 15 ++++
 net/http/http_network_session.cc         |  1 +
 net/http/http_network_session.cc.rej     | 10 +++
 net/quic/quic_stream_factory.cc          | 35 ++++++++-
 net/quic/quic_stream_factory.cc.rej      | 58 +++++++++++++++
 net/socket/ssl_client_socket_impl.cc     | 59 ++++++++++++++++
 net/socket/ssl_client_socket_impl.cc.rej | 90 ++++++++++++++++++++++++
 net/socket/ssl_client_socket_impl.h      |  2 +
 net/socket/ssl_client_socket_impl.h.rej  | 11 +++
 13 files changed, 317 insertions(+), 1 deletion(-)
 create mode 100644 net/base/features.cc.rej
 create mode 100644 net/base/features.h.rej
 create mode 100644 net/http/http_network_session.cc.rej
 create mode 100644 net/quic/quic_stream_factory.cc.rej
 create mode 100644 net/socket/ssl_client_socket_impl.cc.rej
 create mode 100644 net/socket/ssl_client_socket_impl.h.rej

diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -4659,6 +4659,12 @@ const FeatureEntry kFeatureEntries[] = {
     {"enable-tls13-early-data", flag_descriptions::kEnableTLS13EarlyDataName,
      flag_descriptions::kEnableTLS13EarlyDataDescription, kOsAll,
      FEATURE_VALUE_TYPE(net::features::kEnableTLS13EarlyData)},
+    {"disable-tls-resumption", flag_descriptions::kDisableTLSResumptionName,
+     flag_descriptions::kDisableTLSResumptionDescription, kOsAll,
+     FEATURE_VALUE_TYPE(net::features::kDisableTLSResumption)},
+    {"log-tls-resumption", flag_descriptions::kLogTLSResumptionName,
+     flag_descriptions::kLogTLSResumptionDescription, kOsAll,
+     FEATURE_VALUE_TYPE(net::features::kLogTLSResumption)},
     {"post-quantum-cecpq2", flag_descriptions::kPostQuantumCECPQ2Name,
      flag_descriptions::kPostQuantumCECPQ2Description, kOsAll,
      FEATURE_VALUE_TYPE(net::features::kPostQuantumCECPQ2)},
diff --git a/net/base/features.cc b/net/base/features.cc
--- a/net/base/features.cc
+++ b/net/base/features.cc
@@ -61,6 +61,14 @@ const base::FeatureParam<base::TimeDelta> kUseDnsHttpsSvcbSecureExtraTimeMin{
     &kUseDnsHttpsSvcb, "UseDnsHttpsSvcbSecureExtraTimeMin",
     base::Milliseconds(5)};
 
+BASE_FEATURE(kDisableTLSResumption,
+             "DisableTLSResumption",
+             base::FEATURE_ENABLED_BY_DEFAULT);
+
+BASE_FEATURE(kLogTLSResumption,
+             "LogTLSResumption",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+
 BASE_FEATURE(kUseDnsHttpsSvcbAlpn,
              "UseDnsHttpsSvcbAlpn",
              base::FEATURE_DISABLED_BY_DEFAULT);
diff --git a/net/base/features.cc.rej b/net/base/features.cc.rej
new file mode 100644
index 0000000000000000000000000000000000000000..66c2a95b4f014c7cecd131bc53f4a578e528d25c
--- /dev/null
+++ b/net/base/features.cc.rej
@@ -0,0 +1,17 @@
+--- net/base/features.cc
++++ net/base/features.cc
+@@ -61,6 +61,14 @@ const base::FeatureParam<base::TimeDelta> kUseDnsHttpsSvcbSecureExtraTimeMin{
+     &kUseDnsHttpsSvcb, "UseDnsHttpsSvcbSecureExtraTimeMin",
+     base::Milliseconds(5)};
+ 
++BASE_FEATURE(kDisableTLSResumption,
++             "DisableTLSResumption",
++             base::FEATURE_ENABLED_BY_DEFAULT);
++
++BASE_FEATURE(kLogTLSResumption,
++             "LogTLSResumption",
++             base::FEATURE_DISABLED_BY_DEFAULT);
++
+ BASE_FEATURE(kUseDnsHttpsSvcbAlpn,
+              "UseDnsHttpsSvcbAlpn",
+              base::FEATURE_DISABLED_BY_DEFAULT);
diff --git a/net/base/features.h b/net/base/features.h
--- a/net/base/features.h
+++ b/net/base/features.h
@@ -89,6 +89,12 @@ NET_EXPORT BASE_DECLARE_FEATURE(kUseDnsHttpsSvcbAlpn);
 // Enables TLS 1.3 early data.
 NET_EXPORT BASE_DECLARE_FEATURE(kEnableTLS13EarlyData);
 
+// Disables TLS resumption.
+NET_EXPORT BASE_DECLARE_FEATURE(kDisableTLSResumption);
+
+// Log TLS resumption.
+NET_EXPORT BASE_DECLARE_FEATURE(kLogTLSResumption);
+
 // Enables the TLS Encrypted ClientHello feature.
 // https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-13
 NET_EXPORT BASE_DECLARE_FEATURE(kEncryptedClientHello);
diff --git a/net/base/features.h.rej b/net/base/features.h.rej
new file mode 100644
index 0000000000000000000000000000000000000000..68f2589daad651de89586df3cb2360982c8a5a5c
--- /dev/null
+++ b/net/base/features.h.rej
@@ -0,0 +1,15 @@
+--- net/base/features.h
++++ net/base/features.h
+@@ -89,6 +89,12 @@ NET_EXPORT BASE_DECLARE_FEATURE(kUseDnsHttpsSvcbAlpn);
+ // Enables TLS 1.3 early data.
+ NET_EXPORT BASE_DECLARE_FEATURE(kEnableTLS13EarlyData);
+ 
++// Disables TLS resumption.
++NET_EXPORT BASE_DECLARE_FEATURE(kDisableTLSResumption);
++
++// Log TLS resumption.
++NET_EXPORT BASE_DECLARE_FEATURE(kLogTLSResumption);
++
+ // Enables the TLS Encrypted ClientHello feature.
+ // https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-13
+ NET_EXPORT BASE_DECLARE_FEATURE(kEncryptedClientHello);
diff --git a/net/http/http_network_session.cc b/net/http/http_network_session.cc
--- a/net/http/http_network_session.cc
+++ b/net/http/http_network_session.cc
@@ -211,6 +211,7 @@ HttpNetworkSession::HttpNetworkSession(const HttpNetworkSessionParams& params,
 
   next_protos_.push_back(kProtoHTTP11);
 
+  DCHECK(context.quic_context->params()->max_server_configs_stored_in_properties == 0);
   http_server_properties_->SetMaxServerConfigsStoredInProperties(
       context.quic_context->params()->max_server_configs_stored_in_properties);
   http_server_properties_->SetBrokenAlternativeServicesDelayParams(
diff --git a/net/http/http_network_session.cc.rej b/net/http/http_network_session.cc.rej
new file mode 100644
index 0000000000000000000000000000000000000000..529b322f822345e6a624bb55dfd6850449ae92c5
--- /dev/null
+++ b/net/http/http_network_session.cc.rej
@@ -0,0 +1,10 @@
+--- net/http/http_network_session.cc
++++ net/http/http_network_session.cc
+@@ -211,6 +211,7 @@ HttpNetworkSession::HttpNetworkSession(const HttpNetworkSessionParams& params,
+ 
+   next_protos_.push_back(kProtoHTTP11);
+ 
++  DCHECK(context.quic_context->params()->max_server_configs_stored_in_properties == 0);
+   http_server_properties_->SetMaxServerConfigsStoredInProperties(
+       context.quic_context->params()->max_server_configs_stored_in_properties);
+   http_server_properties_->SetBrokenAlternativeServicesDelayParams(
diff --git a/net/quic/quic_stream_factory.cc b/net/quic/quic_stream_factory.cc
--- a/net/quic/quic_stream_factory.cc
+++ b/net/quic/quic_stream_factory.cc
@@ -71,6 +71,7 @@
 #include "net/third_party/quiche/src/quiche/quic/core/quic_utils.h"
 #include "net/third_party/quiche/src/quiche/quic/platform/api/quic_flags.h"
 #include "third_party/boringssl/src/include/openssl/aead.h"
+#include "third_party/boringssl/src/include/openssl/ssl.h"
 #include "url/gurl.h"
 #include "url/scheme_host_port.h"
 #include "url/url_constants.h"
@@ -236,6 +237,38 @@ quic::ParsedQuicVersion SelectQuicVersion(
 
 }  // namespace
 
+class BromiteSessionCache : public quic::QuicClientSessionCache {
+ public:
+  BromiteSessionCache() = default;
+  ~BromiteSessionCache() override = default;
+
+  void Insert(const quic::QuicServerId& server_id,
+              bssl::UniquePtr<SSL_SESSION> session,
+              const quic::TransportParameters& params,
+              const quic::ApplicationState* application_state) override {
+    if (base::FeatureList::IsEnabled(net::features::kDisableTLSResumption))
+      SSL_SESSION_set_timeout(session.get(), 0);
+    if (base::FeatureList::IsEnabled(net::features::kLogTLSResumption)) {
+      LOG(INFO) << "SSL Log: new quic session created "
+                << server_id.host();
+    }
+    quic::QuicClientSessionCache::Insert(server_id,
+      std::move(session), params, application_state);
+  }
+
+  std::unique_ptr<quic::QuicResumptionState> Lookup(
+        const quic::QuicServerId& server_id, quic::QuicWallTime now,
+        const SSL_CTX* ctx) override {
+    auto value = quic::QuicClientSessionCache::Lookup(server_id, now, ctx);
+    if (value != nullptr &&
+        base::FeatureList::IsEnabled(net::features::kLogTLSResumption)) {
+      LOG(INFO) << "SSL Log: QUIC session resumed "
+                << server_id.host();
+    }
+    return value;
+  }
+};
+
 // Refcounted class that owns quic::QuicCryptoClientConfig and tracks how many
 // consumers are using it currently. When the last reference is freed, the
 // QuicCryptoClientConfigHandle informs the owning QuicStreamFactory, moves it
@@ -2351,7 +2384,7 @@ QuicStreamFactory::CreateCryptoConfigHandle(
               sct_auditing_delegate_,
               HostsFromOrigins(params_.origins_to_force_quic_on),
               actual_network_anonymization_key),
-          std::make_unique<quic::QuicClientSessionCache>(), this);
+          std::make_unique<BromiteSessionCache>(), this);
 
   quic::QuicCryptoClientConfig* crypto_config = crypto_config_owner->config();
   crypto_config->set_user_agent_id(params_.user_agent_id);
diff --git a/net/quic/quic_stream_factory.cc.rej b/net/quic/quic_stream_factory.cc.rej
new file mode 100644
index 0000000000000000000000000000000000000000..78e1b9cacce1a7852aa7391bc86ee24b03097fb9
--- /dev/null
+++ b/net/quic/quic_stream_factory.cc.rej
@@ -0,0 +1,58 @@
+--- net/quic/quic_stream_factory.cc
++++ net/quic/quic_stream_factory.cc
+@@ -71,6 +71,7 @@
+ #include "net/third_party/quiche/src/quiche/quic/core/quic_utils.h"
+ #include "net/third_party/quiche/src/quiche/quic/platform/api/quic_flags.h"
+ #include "third_party/boringssl/src/include/openssl/aead.h"
++#include "third_party/boringssl/src/include/openssl/ssl.h"
+ #include "url/gurl.h"
+ #include "url/scheme_host_port.h"
+ #include "url/url_constants.h"
+@@ -236,6 +237,38 @@ quic::ParsedQuicVersion SelectQuicVersion(
+ 
+ }  // namespace
+ 
++class BromiteSessionCache : public quic::QuicClientSessionCache {
++ public:
++  BromiteSessionCache() = default;
++  ~BromiteSessionCache() override = default;
++
++  void Insert(const quic::QuicServerId& server_id,
++              bssl::UniquePtr<SSL_SESSION> session,
++              const quic::TransportParameters& params,
++              const quic::ApplicationState* application_state) override {
++    if (base::FeatureList::IsEnabled(net::features::kDisableTLSResumption))
++      SSL_SESSION_set_timeout(session.get(), 0);
++    if (base::FeatureList::IsEnabled(net::features::kLogTLSResumption)) {
++      LOG(INFO) << "SSL Log: new quic session created "
++                << server_id.host();
++    }
++    quic::QuicClientSessionCache::Insert(server_id,
++      std::move(session), params, application_state);
++  }
++
++  std::unique_ptr<quic::QuicResumptionState> Lookup(
++        const quic::QuicServerId& server_id, quic::QuicWallTime now,
++        const SSL_CTX* ctx) override {
++    auto value = quic::QuicClientSessionCache::Lookup(server_id, now, ctx);
++    if (value != nullptr &&
++        base::FeatureList::IsEnabled(net::features::kLogTLSResumption)) {
++      LOG(INFO) << "SSL Log: QUIC session resumed "
++                << server_id.host();
++    }
++    return value;
++  }
++};
++
+ // Refcounted class that owns quic::QuicCryptoClientConfig and tracks how many
+ // consumers are using it currently. When the last reference is freed, the
+ // QuicCryptoClientConfigHandle informs the owning QuicStreamFactory, moves it
+@@ -2351,7 +2384,7 @@ QuicStreamFactory::CreateCryptoConfigHandle(
+               sct_auditing_delegate_,
+               HostsFromOrigins(params_.origins_to_force_quic_on),
+               actual_network_anonymization_key),
+-          std::make_unique<quic::QuicClientSessionCache>(), this);
++          std::make_unique<BromiteSessionCache>(), this);
+ 
+   quic::QuicCryptoClientConfig* crypto_config = crypto_config_owner->config();
+   crypto_config->set_user_agent_id(params_.user_agent_id);
diff --git a/net/socket/ssl_client_socket_impl.cc b/net/socket/ssl_client_socket_impl.cc
--- a/net/socket/ssl_client_socket_impl.cc
+++ b/net/socket/ssl_client_socket_impl.cc
@@ -392,7 +392,33 @@ SSLClientSocketImpl::SSLClientSocketImpl(
   CHECK(context_);
 }
 
+void SSLClientSocketImpl::Log_ssl_session_data(const std::string& tag, SSL_SESSION* session) {
+  if (session == NULL) {
+    LOG(INFO) << "SSL Log: "
+              << tag
+              << " host: " << host_and_port_.ToString()
+              << " NIK: " << ssl_config_.network_anonymization_key.ToDebugString();
+    return;
+  }
+
+  unsigned len;
+  auto* session_id = SSL_SESSION_get_id(session, &len);
+
+  const uint8_t *ticket;
+  size_t ticklen;
+  SSL_SESSION_get0_ticket(session, &ticket, &ticklen);
+
+  LOG(INFO) << "SSL Log: "
+            << tag
+            << " host: " << host_and_port_.ToString()
+            << " NIK: " << ssl_config_.network_anonymization_key.ToDebugString()
+            << " sessionid: " << base::HexEncode(session_id, len)
+            << (ticklen > 0 ? " ticket:" + base::HexEncode(ticket, ticklen) : "");
+}
+
 SSLClientSocketImpl::~SSLClientSocketImpl() {
+  if (base::FeatureList::IsEnabled(net::features::kLogTLSResumption))
+    Log_ssl_session_data("Disconnect", NULL);
   Disconnect();
 }
 
@@ -786,6 +812,8 @@ int SSLClientSocketImpl::Init() {
     }
     if (session)
       SSL_set_session(ssl_.get(), session.get());
+    if (session && base::FeatureList::IsEnabled(net::features::kLogTLSResumption))
+      Log_ssl_session_data("Old session resumed", session.get());
   }
 
   transport_adapter_ = std::make_unique<SocketBIOAdapter>(
@@ -1077,6 +1105,35 @@ int SSLClientSocketImpl::DoHandshakeComplete(int result) {
                     : SSLHandshakeDetails::kTLS13Full;
     }
   }
+  if (base::FeatureList::IsEnabled(net::features::kLogTLSResumption)) {
+    switch(details)
+    {
+      case SSLHandshakeDetails::kTLS13Early:
+        Log_ssl_session_data("SSL Log: session reused: kTLS13Early mode", NULL);
+        break;
+      case SSLHandshakeDetails::kTLS13ResumeWithHelloRetryRequest:
+        Log_ssl_session_data("SSL Log: session reused: kTLS13ResumeWithHelloRetryRequest mode", NULL);
+        break;
+      case SSLHandshakeDetails::kTLS13Resume:
+        Log_ssl_session_data("SSL Log: session reused: kTLS13Resume mode", NULL);
+        break;
+      case SSLHandshakeDetails::kTLS12Resume:
+        Log_ssl_session_data("SSL Log: session reused: kTLS12Resume mode", NULL);
+        break;
+      case SSLHandshakeDetails::kTLS12Full:
+        Log_ssl_session_data("SSL Log: session reused: kTLS12Full mode", NULL);
+        break;
+      case SSLHandshakeDetails::kTLS12FalseStart:
+        Log_ssl_session_data("SSL Log: session reused: kTLS12FalseStart mode", NULL);
+        break;
+      case SSLHandshakeDetails::kTLS13Full:
+        Log_ssl_session_data("SSL Log: session reused: kTLS13Full mode", NULL);
+        break;
+      case SSLHandshakeDetails::kTLS13FullWithHelloRetryRequest:
+        Log_ssl_session_data("SSL Log: session reused: kTLS13FullWithHelloRetryRequest mode", NULL);
+        break;
+    }
+  }
   UMA_HISTOGRAM_ENUMERATION("Net.SSLHandshakeDetails", details);
 
   // Measure TLS connections that implement the renegotiation_info extension.
@@ -1759,6 +1816,8 @@ bool SSLClientSocketImpl::IsRenegotiationAllowed() const {
 }
 
 bool SSLClientSocketImpl::IsCachingEnabled() const {
+  if (base::FeatureList::IsEnabled(net::features::kDisableTLSResumption))
+    return false;
   return context_->ssl_client_session_cache() != nullptr;
 }
 
diff --git a/net/socket/ssl_client_socket_impl.cc.rej b/net/socket/ssl_client_socket_impl.cc.rej
new file mode 100644
index 0000000000000000000000000000000000000000..f5bbddf1429e8a63237987a0021495ffd985542a
--- /dev/null
+++ b/net/socket/ssl_client_socket_impl.cc.rej
@@ -0,0 +1,90 @@
+--- net/socket/ssl_client_socket_impl.cc
++++ net/socket/ssl_client_socket_impl.cc
+@@ -392,7 +392,33 @@ SSLClientSocketImpl::SSLClientSocketImpl(
+   CHECK(context_);
+ }
+ 
++void SSLClientSocketImpl::Log_ssl_session_data(const std::string& tag, SSL_SESSION* session) {
++  if (session == NULL) {
++    LOG(INFO) << "SSL Log: "
++              << tag
++              << " host: " << host_and_port_.ToString()
++              << " NIK: " << ssl_config_.network_anonymization_key.ToDebugString();
++    return;
++  }
++
++  unsigned len;
++  auto* session_id = SSL_SESSION_get_id(session, &len);
++
++  const uint8_t *ticket;
++  size_t ticklen;
++  SSL_SESSION_get0_ticket(session, &ticket, &ticklen);
++
++  LOG(INFO) << "SSL Log: "
++            << tag
++            << " host: " << host_and_port_.ToString()
++            << " NIK: " << ssl_config_.network_anonymization_key.ToDebugString()
++            << " sessionid: " << base::HexEncode(session_id, len)
++            << (ticklen > 0 ? " ticket:" + base::HexEncode(ticket, ticklen) : "");
++}
++
+ SSLClientSocketImpl::~SSLClientSocketImpl() {
++  if (base::FeatureList::IsEnabled(net::features::kLogTLSResumption))
++    Log_ssl_session_data("Disconnect", NULL);
+   Disconnect();
+ }
+ 
+@@ -786,6 +812,8 @@ int SSLClientSocketImpl::Init() {
+     }
+     if (session)
+       SSL_set_session(ssl_.get(), session.get());
++    if (session && base::FeatureList::IsEnabled(net::features::kLogTLSResumption))
++      Log_ssl_session_data("Old session resumed", session.get());
+   }
+ 
+   transport_adapter_ = std::make_unique<SocketBIOAdapter>(
+@@ -1077,6 +1105,35 @@ int SSLClientSocketImpl::DoHandshakeComplete(int result) {
+                     : SSLHandshakeDetails::kTLS13Full;
+     }
+   }
++  if (base::FeatureList::IsEnabled(net::features::kLogTLSResumption)) {
++    switch(details)
++    {
++      case SSLHandshakeDetails::kTLS13Early:
++        Log_ssl_session_data("SSL Log: session reused: kTLS13Early mode", NULL);
++        break;
++      case SSLHandshakeDetails::kTLS13ResumeWithHelloRetryRequest:
++        Log_ssl_session_data("SSL Log: session reused: kTLS13ResumeWithHelloRetryRequest mode", NULL);
++        break;
++      case SSLHandshakeDetails::kTLS13Resume:
++        Log_ssl_session_data("SSL Log: session reused: kTLS13Resume mode", NULL);
++        break;
++      case SSLHandshakeDetails::kTLS12Resume:
++        Log_ssl_session_data("SSL Log: session reused: kTLS12Resume mode", NULL);
++        break;
++      case SSLHandshakeDetails::kTLS12Full:
++        Log_ssl_session_data("SSL Log: session reused: kTLS12Full mode", NULL);
++        break;
++      case SSLHandshakeDetails::kTLS12FalseStart:
++        Log_ssl_session_data("SSL Log: session reused: kTLS12FalseStart mode", NULL);
++        break;
++      case SSLHandshakeDetails::kTLS13Full:
++        Log_ssl_session_data("SSL Log: session reused: kTLS13Full mode", NULL);
++        break;
++      case SSLHandshakeDetails::kTLS13FullWithHelloRetryRequest:
++        Log_ssl_session_data("SSL Log: session reused: kTLS13FullWithHelloRetryRequest mode", NULL);
++        break;
++    }
++  }
+   UMA_HISTOGRAM_ENUMERATION("Net.SSLHandshakeDetails", details);
+ 
+   // Measure TLS connections that implement the renegotiation_info extension.
+@@ -1759,6 +1816,8 @@ bool SSLClientSocketImpl::IsRenegotiationAllowed() const {
+ }
+ 
+ bool SSLClientSocketImpl::IsCachingEnabled() const {
++  if (base::FeatureList::IsEnabled(net::features::kDisableTLSResumption))
++    return false;
+   return context_->ssl_client_session_cache() != nullptr;
+ }
+ 
diff --git a/net/socket/ssl_client_socket_impl.h b/net/socket/ssl_client_socket_impl.h
--- a/net/socket/ssl_client_socket_impl.h
+++ b/net/socket/ssl_client_socket_impl.h
@@ -127,6 +127,8 @@ class SSLClientSocketImpl : public SSLClientSocket,
   friend class SSLClientSocket;
   friend class SSLContext;
 
+  void Log_ssl_session_data(const std::string& tag, SSL_SESSION* session);
+
   int Init();
   void DoReadCallback(int result);
   void DoWriteCallback(int result);
diff --git a/net/socket/ssl_client_socket_impl.h.rej b/net/socket/ssl_client_socket_impl.h.rej
new file mode 100644
index 0000000000000000000000000000000000000000..a05f69567423cda250a9149d28ee7c2b8b3369d1
--- /dev/null
+++ b/net/socket/ssl_client_socket_impl.h.rej
@@ -0,0 +1,11 @@
+--- net/socket/ssl_client_socket_impl.h
++++ net/socket/ssl_client_socket_impl.h
+@@ -127,6 +127,8 @@ class SSLClientSocketImpl : public SSLClientSocket,
+   friend class SSLClientSocket;
+   friend class SSLContext;
+ 
++  void Log_ssl_session_data(const std::string& tag, SSL_SESSION* session);
++
+   int Init();
+   void DoReadCallback(int result);
+   void DoWriteCallback(int result);
-- 
2.39.1

