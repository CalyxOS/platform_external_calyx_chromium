From: csagan5 <32685696+csagan5@users.noreply.github.com>
Date: Sat, 2 Oct 2021 13:20:36 +0200
Subject: Add an always-incognito mode

Add a preference that causes all new tabs and all clicked links to launch in incognito.
Make sure initial incognito status is correctly recognized.
Enable incognito custom tabs and fix crashes for incognito/custom tab intents
Use a native flag to correctly start new tabs on app startup

Add history, recents, offlinepages and send to home screen support for always incognito.
History, recent tabs and offline pages require the INCOGNITO_TAB_HISTORY_ENABLED
flag turned on.
IncognitoPlaceholder is also deactivated, both in the phone and tablet version.
The relative tests are also present.

based on the original work by Ryan Archer <ryan.bradley.archer@gmail.com>
Major contributions by uazo.
See also: https://github.com/bromite/bromite/pull/1427

License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html

Change-Id: I9c35d6d686f8091e4dcd96c1906ff3f8cbed1a58
---
 chrome/android/chrome_java_resources.gni      |   1 +
 chrome/android/chrome_java_sources.gni        |   2 +
 .../java/res/xml/incognito_preferences.xml    |  37 ++++
 .../java/res/xml/privacy_preferences.xml      |   5 +
 .../AlwaysIncognitoLinkInterceptor.java       |  54 ++++++
 .../chrome/browser/ChromeTabbedActivity.java  |  28 ++-
 .../chrome/browser/app/ChromeActivity.java    |   4 +
 .../AppMenuPropertiesDelegateImpl.java        |  28 ++-
 .../ChromeContextMenuPopulator.java           |   7 +-
 .../CustomTabActivityLifecycleUmaTracker.java |  39 -----
 .../CustomTabAppMenuPropertiesDelegate.java   |   4 +
 .../CustomTabIntentDataProvider.java          |  10 ++
 .../browser/download/DownloadUtils.java       |  16 +-
 .../history/HistoryContentManager.java        |   7 +-
 .../browser/history/HistoryManager.java       |  27 ++-
 .../chrome/browser/history/HistoryPage.java   |  16 ++
 .../native_page/NativePageFactory.java        |   4 +-
 .../chrome/browser/ntp/RecentTabsManager.java |  28 ++-
 .../privacy/settings/IncognitoSettings.java   | 162 ++++++++++++++++++
 .../settings/FragmentDependencyProvider.java  |   4 +
 .../HistoricalTabModelObserver.java           |   5 +-
 .../tab/tab_restore/HistoricalTabSaver.java   |   2 +-
 .../tab_restore/HistoricalTabSaverImpl.java   |  17 +-
 .../tabbed_mode/TabbedRootUiCoordinator.java  |   4 +-
 .../browser/tabmodel/ChromeTabCreator.java    |   5 +-
 .../tabmodel/TabModelSelectorImpl.java        |   3 +
 .../browser/tabmodel/TabPersistentStore.java  |   9 +
 .../browser/toolbar/ToolbarManager.java       |   3 +-
 .../webapps/WebappIntentDataProvider.java     |  15 ++
 .../browser/android/historical_tab_saver.cc   |  24 ++-
 .../chrome_autocomplete_provider_client.cc    |   9 +
 .../chrome_autocomplete_provider_client.h     |   1 +
 .../remote_suggestions_service_factory.cc     |   5 +
 .../host_content_settings_map_factory.cc      |  22 ++-
 chrome/browser/history/history_tab_helper.cc  |  20 +++
 chrome/browser/history/history_tab_helper.h   |  10 +-
 .../android/offline_page_bridge.cc            |  11 +-
 .../android/offline_page_model_factory.cc     |  20 ++-
 .../android/request_coordinator_factory.cc    |  33 +++-
 .../offline_page_model_factory.h              |   1 +
 .../offline_pages/recent_tab_helper.cc        |  31 +++-
 .../browser/offline_pages/recent_tab_helper.h |   5 +
 .../request_coordinator_factory.h             |   4 +-
 chrome/browser/prefs/browser_prefs.cc         |   5 +
 chrome/browser/profiles/profile_selections.cc |  10 ++
 chrome/browser/profiles/profile_selections.h  |   7 +-
 .../browser/ui/android/native_page/BUILD.gn   |   2 +
 .../browser/ui/native_page/NativePage.java    |  22 ++-
 .../strings/android_chrome_strings.grd        |  25 +++
 .../browser/toolbar/LocationBarModel.java     |   5 +-
 chrome/browser/ui/messages/android/BUILD.gn   |   1 +
 .../snackbar/INeedSnackbarManager.java        |  28 +++
 chrome/common/pref_names.h                    |   6 +
 .../browser/content_settings_pref_provider.cc |   6 +-
 .../browser/content_settings_pref_provider.h  |   2 +
 .../core/browser/host_content_settings_map.cc |   4 +-
 .../core/browser/host_content_settings_map.h  |   3 +
 .../browser/autocomplete_provider_client.cc   |   4 +
 .../browser/autocomplete_provider_client.h    |   1 +
 .../omnibox/browser/base_search_provider.cc   |   2 +-
 components/omnibox/browser/search_provider.cc |   4 +-
 .../add-an-always-incognito-mode.inc          |  13 ++
 .../add-an-always-incognito-mode.inc          |   1 +
 .../add-an-always-incognito-mode.inc          |   3 +
 .../add-an-always-incognito-mode.inc          |   1 +
 65 files changed, 785 insertions(+), 112 deletions(-)
 create mode 100644 chrome/android/java/res/xml/incognito_preferences.xml
 create mode 100644 chrome/android/java/src/org/chromium/chrome/browser/AlwaysIncognitoLinkInterceptor.java
 create mode 100644 chrome/android/java/src/org/chromium/chrome/browser/privacy/settings/IncognitoSettings.java
 create mode 100644 chrome/browser/ui/messages/android/java/src/org/chromium/chrome/browser/ui/messages/snackbar/INeedSnackbarManager.java
 create mode 100644 cromite_flags/chrome/browser/about_flags_cc/add-an-always-incognito-mode.inc
 create mode 100644 cromite_flags/chrome/browser/flags/android/chrome_feature_list_cc/add-an-always-incognito-mode.inc
 create mode 100644 cromite_flags/components/offline_pages/core/offline_page_feature_cc/add-an-always-incognito-mode.inc
 create mode 100644 cromite_flags/components/offline_pages/core/offline_page_feature_h/add-an-always-incognito-mode.inc

diff --git a/chrome/android/chrome_java_resources.gni b/chrome/android/chrome_java_resources.gni
--- a/chrome/android/chrome_java_resources.gni
+++ b/chrome/android/chrome_java_resources.gni
@@ -626,6 +626,7 @@ chrome_java_resources = [
   "java/res/xml/main_preferences_legacy.xml",
   "java/res/xml/manage_sync_preferences.xml",
   "java/res/xml/personalize_google_services_preferences.xml",
+  "java/res/xml/incognito_preferences.xml",
   "java/res/xml/privacy_preferences.xml",
   "java/res/xml/search_widget_info.xml",
   "java/res/xml/tracing_preferences.xml",
diff --git a/chrome/android/chrome_java_sources.gni b/chrome/android/chrome_java_sources.gni
--- a/chrome/android/chrome_java_sources.gni
+++ b/chrome/android/chrome_java_sources.gni
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 chrome_java_sources = [
+  "java/src/org/chromium/chrome/browser/AlwaysIncognitoLinkInterceptor.java",
   "java/src/com/google/android/apps/chrome/appwidget/bookmarks/BookmarkThumbnailWidgetProvider.java",
   "java/src/org/chromium/chrome/browser/ActivityTabProvider.java",
   "java/src/org/chromium/chrome/browser/ActivityUtils.java",
@@ -953,6 +954,7 @@ chrome_java_sources = [
   "java/src/org/chromium/chrome/browser/privacy/settings/IncognitoLockSettings.java",
   "java/src/org/chromium/chrome/browser/privacy/settings/PrivacyPreferencesManagerImpl.java",
   "java/src/org/chromium/chrome/browser/privacy/settings/PrivacySettings.java",
+  "java/src/org/chromium/chrome/browser/privacy/settings/IncognitoSettings.java",
   "java/src/org/chromium/chrome/browser/privacy_sandbox/CctHandler.java",
   "java/src/org/chromium/chrome/browser/privacy_sandbox/ChromeTrackingProtectionDelegate.java",
   "java/src/org/chromium/chrome/browser/privacy_sandbox/PrivacySandboxSurveyController.java",
diff --git a/chrome/android/java/res/xml/incognito_preferences.xml b/chrome/android/java/res/xml/incognito_preferences.xml
new file mode 100644
--- /dev/null
+++ b/chrome/android/java/res/xml/incognito_preferences.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    This file is part of Bromite.
+
+    Bromite is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Bromite is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Bromite. If not, see <https://www.gnu.org/licenses/>.
+-->
+
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <org.chromium.components.browser_ui.settings.ChromeSwitchPreference
+        android:key="always_incognito"
+        android:title="@string/always_incognito_title"
+        android:summary="@string/always_incognito_summary"
+        android:defaultValue="false" />
+    <org.chromium.components.browser_ui.settings.ChromeSwitchPreference
+        android:key="incognito_history"
+        android:title="@string/incognito_history_enabled_title"
+        android:summary="@string/incognito_history_enabled_summary"
+        android:defaultValue="false" />
+    <org.chromium.components.browser_ui.settings.ChromeSwitchPreference
+        android:key="incognito_save_site_setting"
+        android:title="@string/incognito_save_site_setting_enabled_title"
+        android:summary="@string/incognito_save_site_setting_enabled_summary"
+        android:defaultValue="false" />
+</PreferenceScreen>
diff --git a/chrome/android/java/res/xml/privacy_preferences.xml b/chrome/android/java/res/xml/privacy_preferences.xml
--- a/chrome/android/java/res/xml/privacy_preferences.xml
+++ b/chrome/android/java/res/xml/privacy_preferences.xml
@@ -86,6 +86,11 @@ found in the LICENSE file.
         android:key="secure_dns"
         android:title="@string/settings_secure_dns_title"
         android:fragment="org.chromium.chrome.browser.privacy.secure_dns.SecureDnsSettings" />
+    <Preference
+        android:key="incognito_settings"
+        android:title="@string/incognito_settings_title"
+        android:summary="@string/incognito_settings_summary"
+        android:fragment="org.chromium.chrome.browser.privacy.settings.IncognitoSettings"/>
     <PreferenceCategory
         android:key="services_category"
         android:title="@string/services_category_title">
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/AlwaysIncognitoLinkInterceptor.java b/chrome/android/java/src/org/chromium/chrome/browser/AlwaysIncognitoLinkInterceptor.java
new file mode 100644
--- /dev/null
+++ b/chrome/android/java/src/org/chromium/chrome/browser/AlwaysIncognitoLinkInterceptor.java
@@ -0,0 +1,54 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.chromium.chrome.browser;
+
+import android.content.SharedPreferences;
+import org.chromium.base.ContextUtils;
+
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.base.Log;
+
+import androidx.annotation.Nullable;
+
+/**
+ * A {@link TabObserver} that implements the always-incognito preference behavior for links.
+ */
+public class AlwaysIncognitoLinkInterceptor {
+
+    private static final String TAG = "AlwaysIncognito";
+    public static final String PREF_ALWAYS_INCOGNITO = "always_incognito";
+
+    private static @Nullable Boolean cachedIsAlwaysIncognito = null;
+
+    public static boolean isAlwaysIncognito() {
+        if (cachedIsAlwaysIncognito != null) return cachedIsAlwaysIncognito;
+        cachedIsAlwaysIncognito = ContextUtils.getAppSharedPreferences()
+                                    .getBoolean(PREF_ALWAYS_INCOGNITO, false);
+        return cachedIsAlwaysIncognito;
+    }
+
+    public static void setAlwaysIncognito(boolean enabled) {
+        UserPrefs.get(ProfileManager.getLastUsedRegularProfile())
+            .setBoolean(Pref.ALWAYS_INCOGNITO_ENABLED, enabled);
+
+        SharedPreferences.Editor sharedPreferenceEditor = ContextUtils.getAppSharedPreferences().edit();
+        sharedPreferenceEditor.putBoolean("always_incognito", enabled);
+        sharedPreferenceEditor.apply();
+    }
+
+    public static void migrateSettingToNative() {
+        if (isAlwaysIncognito()) {
+            PrefService prefService = UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+            if (!prefService.getBoolean(Pref.ALWAYS_INCOGNITO_ENABLED)) {
+                Log.i(TAG, "Pref migration from java to native");
+                prefService.setBoolean(Pref.ALWAYS_INCOGNITO_ENABLED, true);
+            }
+        }
+    }
+}
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java
@@ -72,6 +72,10 @@ import org.chromium.base.task.TaskTraits;
 import org.chromium.build.annotations.UsedByReflection;
 import org.chromium.cc.input.BrowserControlsState;
 import org.chromium.chrome.R;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.IntentHandler.TabOpenType;
 import org.chromium.chrome.browser.app.ChromeActivity;
 import org.chromium.chrome.browser.app.metrics.LaunchCauseMetrics;
@@ -686,14 +690,19 @@ public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent
 
             Profile profile = mTabModelSelector.getCurrentModel().getProfile();
             // For saving non-incognito tab closures for Recent Tabs.
-            mHistoricalTabModelObserver =
-                    new HistoricalTabModelObserver(
-                            mTabModelSelector
+            boolean alwaysIncognito = AlwaysIncognitoLinkInterceptor.isAlwaysIncognito();
+            PrefService prefService = UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+            boolean historyEnabledInIncognito =
+                prefService.getBoolean(Pref.INCOGNITO_TAB_HISTORY_ENABLED);
+            if ((alwaysIncognito && historyEnabledInIncognito) || !alwaysIncognito) {
+                mHistoricalTabModelObserver =
+                        new HistoricalTabModelObserver(
+                                mTabModelSelector
                                     .getTabGroupModelFilterProvider()
-                                    .getTabGroupModelFilter(false));
-            mHistoricalTabModelObserver.addSecodaryTabModelSupplier(
-                    ArchivedTabModelOrchestrator.getForProfile(profile)::getTabModel);
-
+                                    .getTabGroupModelFilter(alwaysIncognito));
+                mHistoricalTabModelObserver.addSecodaryTabModelSupplier(
+                        ArchivedTabModelOrchestrator.getForProfile(profile)::getTabModel);
+            }
             // Defer creation of this helper so it triggers after TabGroupModelFilter observers.
             mUndoRefocusHelper =
                     new UndoRefocusHelper(
@@ -2383,8 +2392,9 @@ public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent
 
         // We determine the model as soon as possible so every systems get initialized coherently.
         boolean startIncognito =
-                savedInstanceState != null
-                        && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false);
+                AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()
+                || (savedInstanceState != null
+                        && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false));
 
         mNextTabPolicySupplier = new ChromeNextTabPolicySupplier(mLayoutStateProviderSupplier);
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/app/ChromeActivity.java b/chrome/android/java/src/org/chromium/chrome/browser/app/ChromeActivity.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/app/ChromeActivity.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/app/ChromeActivity.java
@@ -94,6 +94,7 @@ import org.chromium.chrome.browser.compositor.layouts.SceneChangeObserver;
 import org.chromium.chrome.browser.compositor.layouts.content.TabContentManagerHandler;
 import org.chromium.chrome.browser.contextualsearch.ContextualSearchManager;
 import org.chromium.chrome.browser.dependency_injection.ChromeActivityCommonsModule;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.dependency_injection.ChromeActivityComponent;
 import org.chromium.chrome.browser.dependency_injection.ModuleFactoryOverrides;
 import org.chromium.chrome.browser.device.DeviceClassManager;
@@ -1981,6 +1982,9 @@ public abstract class ChromeActivity<C extends ChromeActivityComponent>
             throw new IllegalStateException(
                     "Attempting to access TabCreator before initialization");
         }
+        if (AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) {
+            incognito = true;
+        }
         return mTabCreatorManagerSupplier.get().getTabCreator(incognito);
     }
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/app/appmenu/AppMenuPropertiesDelegateImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/app/appmenu/AppMenuPropertiesDelegateImpl.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/app/appmenu/AppMenuPropertiesDelegateImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/app/appmenu/AppMenuPropertiesDelegateImpl.java
@@ -38,6 +38,8 @@ import org.chromium.base.supplier.Supplier;
 import org.chromium.build.BuildConfig;
 import org.chromium.chrome.R;
 import org.chromium.chrome.browser.ActivityTabProvider;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+import org.chromium.chrome.browser.profiles.ProfileManager;
 import org.chromium.chrome.browser.bookmarks.BookmarkModel;
 import org.chromium.chrome.browser.bookmarks.PowerBookmarkUtils;
 import org.chromium.chrome.browser.commerce.ShoppingServiceFactory;
@@ -100,6 +102,10 @@ import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.chrome.browser.preferences.Pref;
+
 /**
  * Base implementation of {@link AppMenuPropertiesDelegate} that handles hiding and showing menu
  * items based on activity state.
@@ -584,6 +590,13 @@ public class AppMenuPropertiesDelegateImpl implements AppMenuPropertiesDelegate
     }
 
     private void prepareCommonMenuItems(Menu menu, @MenuGroup int menuGroup, boolean isIncognito) {
+        boolean always_incognito = AlwaysIncognitoLinkInterceptor.isAlwaysIncognito();
+        if (always_incognito) {
+            final MenuItem newTabOption = menu.findItem(R.id.new_tab_menu_id);
+            if (newTabOption != null)
+                newTabOption.setVisible(false);
+        }
+
         // We have to iterate all menu items since same menu item ID may be associated with more
         // than one menu items.
         boolean isOverviewModeMenu = menuGroup == MenuGroup.OVERVIEW_MODE_MENU;
@@ -647,7 +660,15 @@ public class AppMenuPropertiesDelegateImpl implements AppMenuPropertiesDelegate
             }
 
             if (item.getItemId() == R.id.recent_tabs_menu_id) {
-                item.setVisible(!isIncognito);
+                if (always_incognito) {
+                    PrefService prefService =
+                        UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+                    boolean historyEnabledInIncognito =
+                        prefService.getBoolean(Pref.INCOGNITO_TAB_HISTORY_ENABLED);
+                    item.setVisible(historyEnabledInIncognito);
+                }
+                else
+                    item.setVisible(!isIncognito);
             }
             if (item.getItemId() == R.id.menu_select_tabs) {
                 item.setVisible(isMenuSelectTabsVisible);
@@ -861,8 +882,9 @@ public class AppMenuPropertiesDelegateImpl implements AppMenuPropertiesDelegate
                 && !isNativePage
                 && !isFileScheme
                 && !isContentScheme
-                && !isIncognito
-                && !url.isEmpty();
+                && !url.isEmpty()
+                && (!isIncognito ||
+                    AlwaysIncognitoLinkInterceptor.isAlwaysIncognito());
     }
 
     /**
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java b/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/contextmenu/ChromeContextMenuPopulator.java
@@ -30,6 +30,7 @@ import org.chromium.base.ContextUtils;
 import org.chromium.base.shared_preferences.SharedPreferencesManager;
 import org.chromium.base.supplier.Supplier;
 import org.chromium.chrome.R;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.contextmenu.ChromeContextMenuItem.Item;
 import org.chromium.chrome.browser.contextmenu.ContextMenuCoordinator.ListItemType;
 import org.chromium.chrome.browser.download.DownloadUtils;
@@ -271,6 +272,9 @@ public class ChromeContextMenuPopulator implements ContextMenuPopulator {
     public List<Pair<Integer, ModelList>> buildContextMenu() {
         mShowEphemeralTabNewLabel = null;
 
+        boolean always_incognito =
+            AlwaysIncognitoLinkInterceptor.isAlwaysIncognito();
+
         List<Pair<Integer, ModelList>> groupedItems = new ArrayList<>();
 
         if (mParams.isAnchor()) {
@@ -281,6 +285,7 @@ public class ChromeContextMenuPopulator implements ContextMenuPopulator {
                 if (mMode == ContextMenuMode.NORMAL) {
                     linkGroup.add(createListItem(Item.OPEN_IN_NEW_TAB_IN_GROUP));
                     linkGroup.add(createListItem(Item.OPEN_IN_NEW_TAB));
+
                     if (!mItemDelegate.isIncognito() && mItemDelegate.isIncognitoSupported()) {
                         linkGroup.add(createListItem(Item.OPEN_IN_INCOGNITO_TAB));
                     }
@@ -305,7 +310,7 @@ public class ChromeContextMenuPopulator implements ContextMenuPopulator {
                 }
             }
             if (FirstRunStatus.getFirstRunFlowComplete()) {
-                if (!mItemDelegate.isIncognito()
+                if ((always_incognito || !mItemDelegate.isIncognito())
                         && UrlUtilities.isDownloadableScheme(mParams.getLinkUrl())) {
                     linkGroup.add(
                             createListItem(
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabActivityLifecycleUmaTracker.java b/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabActivityLifecycleUmaTracker.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabActivityLifecycleUmaTracker.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabActivityLifecycleUmaTracker.java
@@ -71,45 +71,6 @@ public class CustomTabActivityLifecycleUmaTracker
     private boolean mIsInitialResume = true;
 
     private void recordIncognitoLaunchReason() {
-        // TODO(crbug.com/352525607): Separate Ephemeral and Incognito CCT metrics.
-        @IntentHandler.IncognitoCCTCallerId int incognitoCCTCallerId;
-        if (mIntentDataProvider.getCustomTabMode() == CustomTabProfileType.INCOGNITO) {
-            incognitoCCTCallerId =
-                    ((IncognitoCustomTabIntentDataProvider) mIntentDataProvider)
-                            .getFeatureIdForMetricsCollection();
-        } else {
-            incognitoCCTCallerId =
-                    ((EphemeralCustomTabIntentDataProvider) mIntentDataProvider)
-                            .getFeatureIdForMetricsCollection();
-        }
-
-        RecordHistogram.recordEnumeratedHistogram(
-                "CustomTabs.IncognitoCCTCallerId",
-                incognitoCCTCallerId,
-                IntentHandler.IncognitoCCTCallerId.NUM_ENTRIES);
-
-        // Record which 1P app launched Incognito CCT.
-        if (incognitoCCTCallerId == IntentHandler.IncognitoCCTCallerId.GOOGLE_APPS) {
-            String sendersPackageName = mIntentDataProvider.getClientPackageName();
-            @IntentHandler.ExternalAppId
-            int externalId = IntentHandler.mapPackageToExternalAppId(sendersPackageName);
-            if (externalId != IntentHandler.ExternalAppId.OTHER) {
-                RecordHistogram.recordEnumeratedHistogram(
-                        "CustomTabs.ClientAppId.Incognito",
-                        externalId,
-                        IntentHandler.ExternalAppId.NUM_ENTRIES);
-            } else {
-                // Using package name didn't give any meaningful insight on who launched the
-                // Incognito CCT, falling back to check if they provided EXTRA_APPLICATION_ID.
-                externalId =
-                        IntentHandler.determineExternalIntentSource(
-                                mIntentDataProvider.getIntent(), mActivity);
-                RecordHistogram.recordEnumeratedHistogram(
-                        "CustomTabs.ClientAppId.Incognito",
-                        externalId,
-                        IntentHandler.ExternalAppId.NUM_ENTRIES);
-            }
-        }
     }
 
     private void recordUserAction() {
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabAppMenuPropertiesDelegate.java b/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabAppMenuPropertiesDelegate.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabAppMenuPropertiesDelegate.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabAppMenuPropertiesDelegate.java
@@ -22,6 +22,7 @@ import org.chromium.base.supplier.ObservableSupplier;
 import org.chromium.base.supplier.Supplier;
 import org.chromium.chrome.R;
 import org.chromium.chrome.browser.ActivityTabProvider;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.DefaultBrowserInfo;
 import org.chromium.chrome.browser.app.appmenu.AppMenuPropertiesDelegateImpl;
 import org.chromium.chrome.browser.app.appmenu.DividerLineMenuItemViewBinder;
@@ -213,6 +214,9 @@ public class CustomTabAppMenuPropertiesDelegate extends AppMenuPropertiesDelegat
                 openInChromeItemVisible = false;
                 tryAddingReadAloud = false;
             }
+            if (AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) {
+                downloadItemVisible = true;
+            }
 
             boolean isNativePage =
                     url.getScheme().equals(UrlConstants.CHROME_SCHEME)
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabIntentDataProvider.java b/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabIntentDataProvider.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabIntentDataProvider.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/customtabs/CustomTabIntentDataProvider.java
@@ -88,6 +88,9 @@ import org.chromium.components.embedder_support.util.UrlConstants;
 import org.chromium.device.mojom.ScreenOrientationLockType;
 import org.chromium.net.NetId;
 
+import org.chromium.base.ContextUtils;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -1222,6 +1225,13 @@ public class CustomTabIntentDataProvider extends BrowserServicesIntentDataProvid
         return getInitialActivityWidth() > 0;
     }
 
+    @Override
+    public @CustomTabProfileType int getCustomTabMode() {
+        return AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()
+                ? CustomTabProfileType.INCOGNITO
+                : CustomTabProfileType.REGULAR;
+    }
+
     @Override
     public boolean isPartialCustomTab() {
         return isPartialHeightCustomTab() || isPartialWidthCustomTab();
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/download/DownloadUtils.java b/chrome/android/java/src/org/chromium/chrome/browser/download/DownloadUtils.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/download/DownloadUtils.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/download/DownloadUtils.java
@@ -35,6 +35,7 @@ import org.chromium.base.FileUtils;
 import org.chromium.base.IntentUtils;
 import org.chromium.base.Log;
 import org.chromium.chrome.R;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.ChromeTabbedActivity;
 import org.chromium.chrome.browser.IntentHandler;
 import org.chromium.chrome.browser.app.download.home.DownloadActivityLauncher;
@@ -76,6 +77,10 @@ import org.chromium.url.GURL;
 
 import java.io.File;
 
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.chrome.browser.preferences.Pref;
+
 /** A class containing some utility static methods. */
 public class DownloadUtils {
     private static final String TAG = "download";
@@ -297,7 +302,16 @@ public class DownloadUtils {
         // Offline pages isn't supported in Incognito. This should be checked before calling
         // OfflinePageBridge.getForProfile because OfflinePageBridge instance will not be found
         // for incognito profile.
-        if (tab.isIncognito()) return false;
+        boolean always_incognito = AlwaysIncognitoLinkInterceptor.isAlwaysIncognito();
+        if (always_incognito) {
+            PrefService prefService = UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+            boolean historyEnabledInIncognito =
+                prefService.getBoolean(Pref.INCOGNITO_TAB_HISTORY_ENABLED);
+            if (historyEnabledInIncognito == false)
+                return false;
+        } else {
+            if (tab.isIncognito()) return false;
+        }
 
         // Check if the page url is supported for saving. Only HTTP and HTTPS pages are allowed.
         if (!OfflinePageBridge.canSavePage(tab.getUrl())) return false;
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryContentManager.java b/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryContentManager.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryContentManager.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryContentManager.java
@@ -271,7 +271,9 @@ public class HistoryContentManager implements SignInStateObserver, PrefObserver
         mHistoryAdapter.generateFooterItems();
 
         // Listen to changes in sign in state.
-        IdentityServicesProvider.get().getSigninManager(profile).addSignInStateObserver(this);
+        // getSigninManager is null in incognito
+        if (IdentityServicesProvider.get().getSigninManager(profile) != null)
+            IdentityServicesProvider.get().getSigninManager(profile).addSignInStateObserver(this);
 
         // Create PrefChangeRegistrar to receive notifications on preference changes.
         mPrefChangeRegistrar = new PrefChangeRegistrar();
@@ -347,7 +349,8 @@ public class HistoryContentManager implements SignInStateObserver, PrefObserver
         mHistoryAdapter.onDestroyed();
         mLargeIconBridge.destroy();
         mLargeIconBridge = null;
-        IdentityServicesProvider.get().getSigninManager(mProfile).removeSignInStateObserver(this);
+        if (IdentityServicesProvider.get().getSigninManager(mProfile) != null)
+            IdentityServicesProvider.get().getSigninManager(mProfile).removeSignInStateObserver(this);
         mPrefChangeRegistrar.destroy();
     }
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryManager.java b/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryManager.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryManager.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryManager.java
@@ -55,6 +55,14 @@ import org.chromium.ui.base.Clipboard;
 
 import java.util.List;
 
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.base.ContextUtils;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.chrome.browser.preferences.Pref;
+
 /** Combines and manages the different UI components of browsing history. */
 public class HistoryManager
         implements OnMenuItemClickListener,
@@ -154,7 +162,7 @@ public class HistoryManager
 
         mUmaRecorder.recordOpenHistory();
         // If incognito placeholder is shown, we don't need to create History UI elements.
-        if (mIsIncognito) {
+        if (shouldShowIncognitoPlaceholder()) {
             mSelectableListLayout = null;
             mRootView = getIncognitoHistoryPlaceholderView();
             return;
@@ -421,9 +429,22 @@ public class HistoryManager
         onBackPressStateChanged();
     }
 
+    public boolean isIncognito() { return mIsIncognito; }
+
+    public boolean shouldShowIncognitoPlaceholder() {
+        if (mIsIncognito &&
+                AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) {
+            PrefService prefService = UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+            boolean historyEnabledInIncognito =
+                prefService.getBoolean(Pref.INCOGNITO_TAB_HISTORY_ENABLED);
+            if (historyEnabledInIncognito) return false;
+        }
+        return mIsIncognito;
+    }
+
     /** Called when the activity/native page is destroyed. */
     public void onDestroyed() {
-        if (mIsIncognito) {
+        if (shouldShowIncognitoPlaceholder()) {
             // If Incognito placeholder is shown no need to call any destroy method.
             return;
         }
@@ -483,7 +504,7 @@ public class HistoryManager
      * @return True if manager handles this event, false if it decides to ignore.
      */
     private boolean onBackPressed() {
-        if (mIsIncognito || mSelectableListLayout == null) {
+        if (shouldShowIncognitoPlaceholder() || mSelectableListLayout == null) {
             // If Incognito placeholder is shown, the back press should handled by HistoryActivity.
             return false;
         }
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryPage.java b/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryPage.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryPage.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/history/HistoryPage.java
@@ -17,6 +17,14 @@ import org.chromium.chrome.browser.ui.native_page.NativePageHost;
 import org.chromium.components.browser_ui.bottomsheet.BottomSheetController;
 import org.chromium.components.embedder_support.util.UrlConstants;
 
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.base.ContextUtils;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.chrome.browser.preferences.Pref;
+
 /** Native page for managing browsing history. */
 public class HistoryPage extends BasicNativePage {
     private HistoryManager mHistoryManager;
@@ -45,6 +53,14 @@ public class HistoryPage extends BasicNativePage {
             String url) {
         super(host);
 
+        if (profile.isOffTheRecord() &&
+                AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) {
+            PrefService prefService = UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+            boolean historyEnabledInIncognito =
+                prefService.getBoolean(Pref.INCOGNITO_TAB_HISTORY_ENABLED);
+            if (historyEnabledInIncognito == true) profile = profile.getOriginalProfile();
+        }
+
         Uri uri = Uri.parse(url);
         assert uri.getHost().equals(UrlConstants.HISTORY_HOST);
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/native_page/NativePageFactory.java b/chrome/android/java/src/org/chromium/chrome/browser/native_page/NativePageFactory.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/native_page/NativePageFactory.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/native_page/NativePageFactory.java
@@ -18,6 +18,7 @@ import org.chromium.base.supplier.ObservableSupplier;
 import org.chromium.base.supplier.OneshotSupplier;
 import org.chromium.base.supplier.Supplier;
 import org.chromium.chrome.R;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.app.ChromeActivity;
 import org.chromium.chrome.browser.app.download.home.DownloadPage;
 import org.chromium.chrome.browser.bookmarks.BookmarkPage;
@@ -316,7 +317,8 @@ public class NativePageFactory {
             String url, NativePage candidatePage, Tab tab, boolean isIncognito, PdfInfo pdfInfo) {
         NativePage page;
 
-        switch (NativePage.nativePageType(url, candidatePage, isIncognito, pdfInfo != null)) {
+        boolean isAlwaysIncognito = AlwaysIncognitoLinkInterceptor.isAlwaysIncognito();
+        switch (NativePage.nativePageType(url, candidatePage, isIncognito, pdfInfo != null, isAlwaysIncognito)) {
             case NativePageType.NONE:
                 return null;
             case NativePageType.CANDIDATE:
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ntp/RecentTabsManager.java b/chrome/android/java/src/org/chromium/chrome/browser/ntp/RecentTabsManager.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/ntp/RecentTabsManager.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ntp/RecentTabsManager.java
@@ -39,6 +39,15 @@ import org.chromium.components.signin.metrics.SigninAccessPoint;
 import org.chromium.components.sync.SyncService;
 import org.chromium.url.GURL;
 
+import android.content.Intent;
+import android.provider.Browser;
+import android.net.Uri;
+import org.chromium.base.ContextUtils;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+import org.chromium.chrome.browser.IntentHandler;
+import org.chromium.ui.mojom.WindowOpenDisposition;
+import org.chromium.components.embedder_support.util.UrlUtilities;
+
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -105,7 +114,8 @@ public class RecentTabsManager
             Profile profile,
             Context context,
             Runnable showHistoryManager) {
-        mProfile = profile;
+        mProfile = profile.getOriginalProfile();
+        profile = mProfile;
         mActiveTab = tab;
         mTabModelSelector = tabModelSelector;
         mShowHistoryManager = showHistoryManager;
@@ -273,6 +283,22 @@ public class RecentTabsManager
      */
     public void openRecentlyClosedTab(RecentlyClosedTab tab, int windowDisposition) {
         if (mIsDestroyed) return;
+        if (AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) {
+            // allow only http/https urls
+            if (!UrlUtilities.isHttpOrHttps(tab.getUrl())) return;
+
+            Context context = ContextUtils.getApplicationContext();
+            Intent intent = new Intent(Intent.ACTION_VIEW,
+                Uri.parse(tab.getUrl().getSpec()));
+            intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());
+            if (windowDisposition != WindowOpenDisposition.CURRENT_TAB) {
+                intent.putExtra(IntentHandler.EXTRA_OPEN_NEW_INCOGNITO_TAB, true);
+            }
+            intent.setPackage(context.getPackageName());
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            IntentHandler.startActivityForTrustedIntent(intent);
+            return;
+        }
         mTabSessionIdsRestored.put(tab.getSessionId(), true);
         RecordUserAction.record("MobileRecentTabManagerRecentTabOpened");
         // Window disposition will select which tab to open.
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/privacy/settings/IncognitoSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/privacy/settings/IncognitoSettings.java
new file mode 100644
--- /dev/null
+++ b/chrome/android/java/src/org/chromium/chrome/browser/privacy/settings/IncognitoSettings.java
@@ -0,0 +1,162 @@
+/*
+    This file is part of Bromite.
+
+    Bromite is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Bromite is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Bromite. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+package org.chromium.chrome.browser.privacy.settings;
+
+import android.os.Bundle;
+import android.content.Context;
+import android.content.Intent;
+import android.provider.Browser;
+import android.net.Uri;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+
+import androidx.preference.Preference;
+import androidx.preference.PreferenceFragmentCompat;
+import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;
+
+import org.chromium.base.supplier.Supplier;
+import org.chromium.chrome.R;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+import org.chromium.chrome.browser.ui.messages.snackbar.SnackbarManager;
+import org.chromium.chrome.browser.ui.messages.snackbar.INeedSnackbarManager;
+import org.chromium.chrome.browser.ui.messages.snackbar.Snackbar;
+import org.chromium.chrome.browser.lifetime.ApplicationLifetime;
+import org.chromium.components.browser_ui.settings.ChromeSwitchPreference;
+import org.chromium.components.browser_ui.settings.SettingsUtils;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.user_prefs.UserPrefs;
+
+/**
+ * Fragment to keep track of the all the always incognito related preferences.
+ */
+public class IncognitoSettings
+        extends PreferenceFragmentCompat implements Preference.OnPreferenceChangeListener,
+                                                    INeedSnackbarManager {
+    private Supplier<SnackbarManager> mSnackbarManagerSupplier;
+    private Snackbar mSnackbar;
+
+    private static final String PREF_ALWAYS_INCOGNITO = "always_incognito";
+    private static final String PREF_INCOGNITO_TAB_HISTORY = "incognito_history";
+    private static final String PREF_INCOGNITO_SAVE_SITE_SETTING = "incognito_save_site_setting";
+
+    private final PrefService prefService = UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+
+    @Override
+    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
+        PrivacyPreferencesManagerImpl privacyPrefManager =
+                PrivacyPreferencesManagerImpl.getInstance();
+        SettingsUtils.addPreferencesFromResource(this, R.xml.incognito_preferences);
+        getActivity().setTitle(R.string.incognito_settings_title);
+
+        setHasOptionsMenu(true);
+
+        updatePreferences();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        updatePreferences();
+    }
+
+    public void updatePreferences() {
+        ChromeSwitchPreference alwaysIncognitoPref =
+                (ChromeSwitchPreference) findPreference(PREF_ALWAYS_INCOGNITO);
+        alwaysIncognitoPref.setChecked(
+                prefService.getBoolean(Pref.ALWAYS_INCOGNITO_ENABLED));
+        alwaysIncognitoPref.setOnPreferenceChangeListener(this);
+
+        mSnackbar = Snackbar.make(getActivity().getString(R.string.ui_relaunch_notice),
+                new SnackbarManager.SnackbarController() {
+                        @Override
+                        public void onDismissNoAction(Object actionData) { }
+
+                        @Override
+                        public void onAction(Object actionData) {
+                                ApplicationLifetime.terminate(true);
+                        }
+                }, Snackbar.TYPE_NOTIFICATION, Snackbar.UMA_UNKNOWN)
+                .setSingleLine(false)
+                .setAction(getActivity().getString(R.string.relaunch),
+                        /*actionData*/null)
+                .setDuration(/*durationMs*/70000);
+
+        ChromeSwitchPreference historyInIncognitoPref =
+                (ChromeSwitchPreference) findPreference(PREF_INCOGNITO_TAB_HISTORY);
+        historyInIncognitoPref.setChecked(
+                prefService.getBoolean(Pref.INCOGNITO_TAB_HISTORY_ENABLED));
+        historyInIncognitoPref.setOnPreferenceChangeListener(this);
+
+        ChromeSwitchPreference saveSiteSettingsPref =
+                (ChromeSwitchPreference) findPreference(PREF_INCOGNITO_SAVE_SITE_SETTING);
+        saveSiteSettingsPref.setChecked(
+                prefService.getBoolean(Pref.INCOGNITO_SAVE_SITE_SETTING_ENABLED));
+        saveSiteSettingsPref.setOnPreferenceChangeListener(this);
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        String key = preference.getKey();
+        if (PREF_ALWAYS_INCOGNITO.equals(key)) {
+            AlwaysIncognitoLinkInterceptor.setAlwaysIncognito((boolean) newValue);
+        } else if (PREF_INCOGNITO_TAB_HISTORY.equals(key)) {
+            prefService.setBoolean(Pref.INCOGNITO_TAB_HISTORY_ENABLED, (boolean) newValue);
+        } else if (PREF_INCOGNITO_SAVE_SITE_SETTING.equals(key)) {
+            prefService.setBoolean(Pref.INCOGNITO_SAVE_SITE_SETTING_ENABLED, (boolean) newValue);
+        }
+        if (!mSnackbarManagerSupplier.get().isShowing()) {
+            mSnackbarManagerSupplier.get().showSnackbar(mSnackbar);
+        }
+        return true;
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.clear();
+        MenuItem help =
+                menu.add(Menu.NONE, R.id.menu_id_targeted_help, Menu.NONE, R.string.menu_help);
+        help.setIcon(VectorDrawableCompat.create(
+                getResources(), R.drawable.ic_help_and_feedback, getActivity().getTheme()));
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.getItemId() == R.id.menu_id_targeted_help) {
+            Context context = getContext();
+
+            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/bromite/bromite/wiki/AlwaysIncognito"));
+            // Let Chromium know that this intent is from Chromium, so that it does not close the app when
+            // the user presses 'back' button.
+            intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName());
+            intent.putExtra(Browser.EXTRA_CREATE_NEW_TAB, true);
+            intent.setPackage(context.getPackageName());
+            context.startActivity(intent);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void setSnackbarManagerSupplier(Supplier<SnackbarManager> manager) {
+        mSnackbarManagerSupplier = manager;
+    }
+}
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java b/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java
@@ -58,6 +58,7 @@ import org.chromium.chrome.browser.sync.settings.AccountManagementFragment;
 import org.chromium.chrome.browser.sync.settings.GoogleServicesSettings;
 import org.chromium.chrome.browser.sync.settings.ManageSyncSettings;
 import org.chromium.chrome.browser.ui.messages.snackbar.SnackbarManager;
+import org.chromium.chrome.browser.ui.messages.snackbar.INeedSnackbarManager;
 import org.chromium.components.browser_ui.bottomsheet.BottomSheetController;
 import org.chromium.components.browser_ui.settings.FragmentSettingsNavigation;
 import org.chromium.components.browser_ui.site_settings.BaseSiteSettingsFragment;
@@ -271,6 +272,9 @@ public class FragmentDependencyProvider extends FragmentManager.FragmentLifecycl
             safetyHubFragment.setCustomTabIntentHelper(
                     LaunchIntentDispatcher::createCustomTabActivityIntent);
         }
+        if (fragment instanceof INeedSnackbarManager) {
+            ((INeedSnackbarManager)fragment).setSnackbarManagerSupplier(mSnackbarManagerSupplier);
+        }
         if (fragment instanceof AccountManagementFragment) {
             ((AccountManagementFragment) fragment)
                     .setSnackbarManagerSupplier(mSnackbarManagerSupplier);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabModelObserver.java b/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabModelObserver.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabModelObserver.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabModelObserver.java
@@ -23,6 +23,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Set;
 
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+
 /** A tab model observer for managing bulk closures. */
 public class HistoricalTabModelObserver implements TabModelObserver {
     private final TabGroupModelFilter mTabGroupModelFilter;
@@ -71,9 +73,10 @@ public class HistoricalTabModelObserver implements TabModelObserver {
         if (tabs.isEmpty() || !canRestore) return;
 
         if (tabs.size() == 1) {
+            boolean is_always_incognito = AlwaysIncognitoLinkInterceptor.isAlwaysIncognito();
             Tab tab = tabs.get(0);
             if (!isTabGroupWithOneTab(tab)) {
-                mHistoricalTabSaver.createHistoricalTab(tab);
+                mHistoricalTabSaver.createHistoricalTab(tab, is_always_incognito);
                 return;
             }
         }
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaver.java b/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaver.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaver.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaver.java
@@ -32,7 +32,7 @@ public interface HistoricalTabSaver {
      *
      * @param tab The {@link Tab} to create an entry for.
      */
-    void createHistoricalTab(Tab tab);
+    void createHistoricalTab(Tab tab, boolean is_always_incognito);
 
     /**
      * Creates a Group or Tab entry in TabRestoreService.
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaverImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaverImpl.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaverImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tab/tab_restore/HistoricalTabSaverImpl.java
@@ -29,6 +29,8 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+
 /** Creates historical entries in TabRestoreService. */
 @JNINamespace("historical_tab_saver")
 public class HistoricalTabSaverImpl implements HistoricalTabSaver {
@@ -85,10 +87,10 @@ public class HistoricalTabSaverImpl implements HistoricalTabSaver {
     }
 
     @Override
-    public void createHistoricalTab(Tab tab) {
+    public void createHistoricalTab(Tab tab, boolean is_always_incognito) {
         if (!shouldSave(tab)) return;
 
-        createHistoricalTabInternal(tab);
+        createHistoricalTabInternal(tab, is_always_incognito);
     }
 
     @Override
@@ -149,7 +151,7 @@ public class HistoricalTabSaverImpl implements HistoricalTabSaver {
 
         // If there is only a single valid tab remaining save it individually.
         if (validEntries.size() == 1 && validEntries.get(0).isSingleTab()) {
-            createHistoricalTabInternal(allTabs.get(0));
+            createHistoricalTabInternal(allTabs.get(0), false);
             return;
         }
 
@@ -190,14 +192,15 @@ public class HistoricalTabSaverImpl implements HistoricalTabSaver {
                         CollectionUtil.integerCollectionToIntArray(savedStateVersions));
     }
 
-    private void createHistoricalTabInternal(Tab tab) {
+    private void createHistoricalTabInternal(Tab tab, boolean is_always_incognito) {
         RecordHistogram.recordEnumeratedHistogram(
                 "Tabs.RecentlyClosed.HistoricalSaverCloseType",
                 HistoricalSaverCloseType.TAB,
                 HistoricalSaverCloseType.COUNT);
         HistoricalTabSaverImplJni.get()
                 .createHistoricalTab(
-                        tab, getWebContentsState(tab).buffer(), getWebContentsState(tab).version());
+                        tab, getWebContentsState(tab).buffer(), getWebContentsState(tab).version(),
+                is_always_incognito);
     }
 
     /**
@@ -205,7 +208,7 @@ public class HistoricalTabSaverImpl implements HistoricalTabSaver {
      * internal Chrome scheme, about:blank, or a native page and it cannot be incognito.
      */
     private boolean shouldSave(Tab tab) {
-        if (tab.isIncognito()) return false;
+        if (tab.isIncognito() && !AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) return false;
         // Check the secondary tab model to see if the tab was moved instead of deleted.
         if (tabIdExistsInSecondaryModel(tab.getId())) return false;
 
@@ -295,7 +298,7 @@ public class HistoricalTabSaverImpl implements HistoricalTabSaver {
 
     @NativeMethods
     interface Natives {
-        void createHistoricalTab(Tab tab, ByteBuffer state, int savedStateVersion);
+        void createHistoricalTab(Tab tab, ByteBuffer state, int savedStateVersion, boolean is_always_incognito);
 
         void createHistoricalGroup(
                 TabModel model,
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedRootUiCoordinator.java b/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedRootUiCoordinator.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedRootUiCoordinator.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabbed_mode/TabbedRootUiCoordinator.java
@@ -158,6 +158,8 @@ import org.chromium.ui.InsetObserver;
 import org.chromium.ui.UiUtils;
 import org.chromium.ui.base.ActivityWindowAndroid;
 import org.chromium.ui.base.DeviceFormFactor;
+import org.chromium.base.ContextUtils;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.ui.base.IntentRequestTracker;
 import org.chromium.ui.base.LocalizationUtils;
 import org.chromium.ui.dragdrop.DragDropGlobalState;
@@ -1017,7 +1019,7 @@ public class TabbedRootUiCoordinator extends RootUiCoordinator {
                             () -> {
                                 mTabCreatorManagerSupplier
                                         .get()
-                                        .getTabCreator(/* incognito= */ false)
+                                        .getTabCreator(AlwaysIncognitoLinkInterceptor.isAlwaysIncognito())
                                         .launchUrl(
                                                 NewTabPageUtils.encodeNtpUrl(
                                                         NewTabPageLaunchOrigin.WEB_FEED),
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/ChromeTabCreator.java
@@ -47,6 +47,10 @@ import org.chromium.ui.base.PageTransition;
 import org.chromium.ui.base.WindowAndroid;
 import org.chromium.url.GURL;
 
+import org.chromium.base.ContextUtils;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+import org.chromium.chrome.browser.tab.TabObserver;
+
 /** This class creates various kinds of new tabs and adds them to the right {@link TabModel}. */
 public class ChromeTabCreator extends TabCreator {
     private final Activity mActivity;
@@ -507,7 +511,6 @@ public class ChromeTabCreator extends TabCreator {
     // TODO(crbug.com/40691614): Clean up the launches from SearchActivity/Chrome.
     public Tab launchUrlFromExternalApp(
             LoadUrlParams loadUrlParams, String appId, boolean forceNewTab, Intent intent) {
-        assert !mIncognito;
         // Don't re-use tabs for intents from Chrome. Note that this can be spoofed so shouldn't be
         // relied on for anything security sensitive.
         boolean isLaunchedFromChrome = TextUtils.equals(appId, mActivity.getPackageName());
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelSelectorImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelSelectorImpl.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelSelectorImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabModelSelectorImpl.java
@@ -10,6 +10,7 @@ import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 
 import org.chromium.base.supplier.OneshotSupplier;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.flags.ActivityType;
 import org.chromium.chrome.browser.ntp.RecentlyClosedBridge;
 import org.chromium.chrome.browser.profiles.ProfileProvider;
@@ -106,6 +107,8 @@ public class TabModelSelectorImpl extends TabModelSelectorBase implements TabMod
         ProfileProvider profileProvider = mProfileProviderSupplier.get();
         assert profileProvider != null;
 
+        AlwaysIncognitoLinkInterceptor.migrateSettingToNative();
+
         ChromeTabCreator regularTabCreator =
                 (ChromeTabCreator) getTabCreatorManager().getTabCreator(false);
         ChromeTabCreator incognitoTabCreator =
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabPersistentStore.java b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabPersistentStore.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabPersistentStore.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tabmodel/TabPersistentStore.java
@@ -49,6 +49,8 @@ import org.chromium.chrome.browser.tabpersistence.TabStateFileManager;
 import org.chromium.components.embedder_support.util.UrlUtilities;
 import org.chromium.content_public.browser.LoadUrlParams;
 
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayInputStream;
@@ -815,6 +817,13 @@ public class TabPersistentStore {
                 }
             }
         }
+        if (AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) {
+            if (!isIncognito) {
+                Log.w(TAG, "Failed to restore tab: not in incognito mode.");
+                return;
+            }
+        }
+
         TabModel model = mTabModelSelector.getModel(isIncognito);
 
         if (model.isIncognito() != isIncognito) {
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/toolbar/ToolbarManager.java b/chrome/android/java/src/org/chromium/chrome/browser/toolbar/ToolbarManager.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/toolbar/ToolbarManager.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/toolbar/ToolbarManager.java
@@ -44,6 +44,7 @@ import org.chromium.base.supplier.Supplier;
 import org.chromium.cc.input.BrowserControlsState;
 import org.chromium.chrome.R;
 import org.chromium.chrome.browser.ActivityTabProvider;
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
 import org.chromium.chrome.browser.IntentHandler;
 import org.chromium.chrome.browser.app.tabmodel.TabWindowManagerSingleton;
 import org.chromium.chrome.browser.back_press.BackPressManager;
@@ -670,7 +671,7 @@ public class ToolbarManager
                                 TraceEvent.end("isOfflinePage");
                                 return ret;
                             }
-                        });
+                        }, AlwaysIncognitoLinkInterceptor.isAlwaysIncognito());
         mControlContainer = controlContainer;
         mToolbarHairline = mControlContainer.findViewById(R.id.toolbar_hairline);
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebappIntentDataProvider.java b/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebappIntentDataProvider.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebappIntentDataProvider.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/webapps/WebappIntentDataProvider.java
@@ -33,6 +33,8 @@ import org.chromium.components.browser_ui.widget.TintedDrawable;
 import org.chromium.device.mojom.ScreenOrientationLockType;
 import org.chromium.ui.util.ColorUtils;
 
+import org.chromium.chrome.browser.AlwaysIncognitoLinkInterceptor;
+
 /** Stores info about a web app. */
 public class WebappIntentDataProvider extends BrowserServicesIntentDataProvider {
     private final Drawable mCloseButtonIcon;
@@ -45,6 +47,8 @@ public class WebappIntentDataProvider extends BrowserServicesIntentDataProvider
     private final ColorProviderImpl mColorProvider;
     private final ColorProviderImpl mDarkColorProvider;
 
+    private boolean mIsIncognito = false;
+
     /** Returns the toolbar color to use if a custom color is not specified by the webapp. */
     public static int getDefaultToolbarColor() {
         return Color.WHITE;
@@ -80,6 +84,10 @@ public class WebappIntentDataProvider extends BrowserServicesIntentDataProvider
         mWebappExtras = webappExtras;
         mWebApkExtras = webApkExtras;
         mActivityType = (webApkExtras != null) ? ActivityType.WEB_APK : ActivityType.WEBAPP;
+
+        if (AlwaysIncognitoLinkInterceptor.isAlwaysIncognito()) {
+            mIsIncognito = true;
+        }
     }
 
     @Override
@@ -175,6 +183,13 @@ public class WebappIntentDataProvider extends BrowserServicesIntentDataProvider
         return mWebApkExtras;
     }
 
+    @Override
+    public @CustomTabProfileType int getCustomTabMode() {
+        return mIsIncognito
+                ? CustomTabProfileType.INCOGNITO
+                : CustomTabProfileType.REGULAR;
+    }
+
     @Override
     public @ScreenOrientationLockType.EnumType int getDefaultOrientation() {
         return mWebappExtras.orientation;
diff --git a/chrome/browser/android/historical_tab_saver.cc b/chrome/browser/android/historical_tab_saver.cc
--- a/chrome/browser/android/historical_tab_saver.cc
+++ b/chrome/browser/android/historical_tab_saver.cc
@@ -33,6 +33,11 @@
 // Must come after all headers that specialize FromJniType() / ToJniType().
 #include "chrome/android/chrome_jni_headers/HistoricalTabSaverImpl_jni.h"
 
+#include "chrome/common/pref_names.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
+#include "historical_tab_saver.h"
+
 using base::android::JavaParamRef;
 using base::android::JavaRef;
 using base::android::ScopedJavaLocalRef;
@@ -107,7 +112,8 @@ std::vector<std::optional<base::Uuid>> StringsToUuids(
 
 void CreateHistoricalTab(
     TabAndroid* tab_android,
-    WebContentsStateByteBuffer web_contents_state_byte_buffer) {
+    WebContentsStateByteBuffer web_contents_state_byte_buffer,
+    bool is_always_incognito) {
   if (!tab_android) {
     return;
   }
@@ -118,9 +124,14 @@ void CreateHistoricalTab(
     return;
   }
 
+  auto* profile = Profile::FromBrowserContext(scoped_web_contents->web_contents()->GetBrowserContext());
+  if (is_always_incognito) {
+    if (profile->GetOriginalProfile()->GetPrefs()->GetBoolean(prefs::kIncognitoTabHistoryEnabled))
+      profile = profile->GetOriginalProfile();
+  }
+
   sessions::TabRestoreService* service =
-      TabRestoreServiceFactory::GetForProfile(Profile::FromBrowserContext(
-          scoped_web_contents->web_contents()->GetBrowserContext()));
+      TabRestoreServiceFactory::GetForProfile(profile);
   if (!service) {
     return;
   }
@@ -186,7 +197,7 @@ void CreateHistoricalBulkClosure(
     std::vector<int> per_tab_root_id,
     std::vector<raw_ptr<TabAndroid, VectorExperimental>> tabs,
     std::vector<WebContentsStateByteBuffer> web_contents_state) {
-  DCHECK(model);
+  if (!model) return;
   DCHECK_EQ(root_ids.size(), group_titles.size());
   DCHECK_EQ(root_ids.size(), group_colors.size());
   DCHECK_EQ(root_ids.size(), optional_tab_group_ids.size());
@@ -319,11 +330,12 @@ static void JNI_HistoricalTabSaverImpl_CreateHistoricalTab(
     JNIEnv* env,
     const JavaParamRef<jobject>& jtab_android,
     const JavaParamRef<jobject>& state,
-    jint saved_state_version) {
+    jint saved_state_version,
+    jboolean is_always_incognito) {
   WebContentsStateByteBuffer web_contents_state = WebContentsStateByteBuffer(
       ScopedJavaLocalRef<jobject>(state), (int)saved_state_version);
   CreateHistoricalTab(TabAndroid::GetNativeTab(env, jtab_android),
-                      std::move(web_contents_state));
+                      std::move(web_contents_state), is_always_incognito);
 }
 
 static void JNI_HistoricalTabSaverImpl_CreateHistoricalGroup(
diff --git a/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc b/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc
--- a/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc
+++ b/chrome/browser/autocomplete/chrome_autocomplete_provider_client.cc
@@ -359,6 +359,15 @@ ChromeAutocompleteProviderClient::GetProviderStateService() const {
   return ProviderStateServiceFactory::GetForProfile(profile_);
 }
 
+bool ChromeAutocompleteProviderClient::IsAlwaysIncognitoEnabled() const {
+#if BUILDFLAG(IS_ANDROID)
+  if (profile_->GetPrefs()->GetBoolean(prefs::kAlwaysIncognitoEnabled)) {
+    return true;
+  }
+#endif
+  return false;
+}
+
 bool ChromeAutocompleteProviderClient::IsOffTheRecord() const {
   return profile_->IsOffTheRecord();
 }
diff --git a/chrome/browser/autocomplete/chrome_autocomplete_provider_client.h b/chrome/browser/autocomplete/chrome_autocomplete_provider_client.h
--- a/chrome/browser/autocomplete/chrome_autocomplete_provider_client.h
+++ b/chrome/browser/autocomplete/chrome_autocomplete_provider_client.h
@@ -85,6 +85,7 @@ class ChromeAutocompleteProviderClient : public AutocompleteProviderClient {
   OnDeviceTailModelService* GetOnDeviceTailModelService() const override;
   ProviderStateService* GetProviderStateService() const override;
   bool IsOffTheRecord() const override;
+  bool IsAlwaysIncognitoEnabled() const override;
   bool IsIncognitoProfile() const override;
   bool IsGuestSession() const override;
   bool SearchSuggestEnabled() const override;
diff --git a/chrome/browser/autocomplete/remote_suggestions_service_factory.cc b/chrome/browser/autocomplete/remote_suggestions_service_factory.cc
--- a/chrome/browser/autocomplete/remote_suggestions_service_factory.cc
+++ b/chrome/browser/autocomplete/remote_suggestions_service_factory.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/autocomplete/remote_suggestions_service_factory.h"
 
+#include "build/build_config.h"
 #include "base/no_destructor.h"
 #include "chrome/browser/autocomplete/document_suggestions_service_factory.h"
 #include "chrome/browser/profiles/profile.h"
@@ -40,9 +41,13 @@ RemoteSuggestionsServiceFactory::RemoteSuggestionsServiceFactory()
     : ProfileKeyedServiceFactory(
           "RemoteSuggestionsService",
           ProfileSelections::Builder()
+#if BUILDFLAG(IS_ANDROID)
+              .WithRegular(ProfileSelection::kOriginalOnlyAndAlwaysIncognito)
+#else
               // Service is needed in OTR profiles (Incognito and Guest).
               .WithRegular(ProfileSelection::kOwnInstance)
               .WithGuest(ProfileSelection::kOwnInstance)
+#endif
               // TODO(crbug.com/41488885): Check if this service is needed for
               // Ash Internals.
               .WithAshInternals(ProfileSelection::kOriginalOnly)
diff --git a/chrome/browser/content_settings/host_content_settings_map_factory.cc b/chrome/browser/content_settings/host_content_settings_map_factory.cc
--- a/chrome/browser/content_settings/host_content_settings_map_factory.cc
+++ b/chrome/browser/content_settings/host_content_settings_map_factory.cc
@@ -18,6 +18,7 @@
 #include "chrome/browser/search_engines/template_url_service_factory.h"
 #include "chrome/browser/supervised_user/supervised_user_settings_service_factory.h"
 #include "chrome/common/buildflags.h"
+#include "chrome/common/pref_names.h"
 #include "components/content_settings/core/browser/content_settings_pref_provider.h"
 #include "components/content_settings/core/browser/host_content_settings_map.h"
 #include "components/permissions/features.h"
@@ -104,9 +105,25 @@ scoped_refptr<RefcountedKeyedService>
   if (profile->IsOffTheRecord() && !profile->IsGuestSession())
     GetForProfile(original_profile);
 
+  bool always_incognito_enabled = false;
+  bool force_save_site_settings = false;
+
+#if BUILDFLAG(IS_ANDROID)
+  PrefService* prefService = original_profile->GetPrefs();
+  if (prefService->GetBoolean(prefs::kAlwaysIncognitoEnabled)) {
+    always_incognito_enabled = true;
+  }
+
+  if (prefService->GetBoolean(prefs::kIncognitoSaveSiteSettingEnabled)) {
+    profile = original_profile;
+    force_save_site_settings = true;
+  }
+#endif
+
   scoped_refptr<HostContentSettingsMap> settings_map(new HostContentSettingsMap(
       profile->GetPrefs(),
-      profile->IsOffTheRecord() || profile->IsGuestSession(),
+      !force_save_site_settings && (profile->IsOffTheRecord() || profile->IsGuestSession()),
+      force_save_site_settings,
       /*store_last_modified=*/true, profile->ShouldRestoreOldSessionCookies(),
       profiles::IsRegularUserProfile(profile)));
 
@@ -115,6 +132,9 @@ scoped_refptr<RefcountedKeyedService>
   settings_map->RegisterProvider(ProviderType::kWebuiAllowlistProvider,
                                  std::move(allowlist_provider));
 
+  if (always_incognito_enabled)
+    return settings_map;
+
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   // These must be registered before before the HostSettings are passed over to
   // the IOThread.  Simplest to do this on construction.
diff --git a/chrome/browser/history/history_tab_helper.cc b/chrome/browser/history/history_tab_helper.cc
--- a/chrome/browser/history/history_tab_helper.cc
+++ b/chrome/browser/history/history_tab_helper.cc
@@ -44,6 +44,9 @@
 #include "components/feed/core/v2/public/feed_api.h"      // nogncheck
 #include "components/feed/core/v2/public/feed_service.h"  // nogncheck
 #include "content/public/browser/web_contents.h"
+#include "chrome/common/pref_names.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
 #else
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -488,6 +491,13 @@ void HistoryTabHelper::TitleWasSet(NavigationEntry* entry) {
 history::HistoryService* HistoryTabHelper::GetHistoryService() {
   Profile* profile =
       Profile::FromBrowserContext(web_contents()->GetBrowserContext());
+
+#if BUILDFLAG(IS_ANDROID)
+  if (profile->GetOriginalProfile()->GetPrefs()->GetBoolean(prefs::kIncognitoTabHistoryEnabled)) {
+    return HistoryServiceFactory::GetForProfile(profile, ServiceAccessType::IMPLICIT_ACCESS);
+  }
+#endif
+
   if (profile->IsOffTheRecord())
     return nullptr;
 
@@ -495,6 +505,16 @@ history::HistoryService* HistoryTabHelper::GetHistoryService() {
       profile, ServiceAccessType::IMPLICIT_ACCESS);
 }
 
+// static
+void HistoryTabHelper::RegisterProfilePrefs(PrefRegistrySimple* registry) {
+#if BUILDFLAG(IS_ANDROID)
+  registry->RegisterBooleanPref(prefs::kIncognitoTabHistoryEnabled,
+                                /*default_value=*/false);
+  registry->RegisterBooleanPref(prefs::kIncognitoSaveSiteSettingEnabled,
+                                /*default_value=*/false);
+#endif
+}
+
 void HistoryTabHelper::WebContentsDestroyed() {
   translate_observation_.Reset();
 
diff --git a/chrome/browser/history/history_tab_helper.h b/chrome/browser/history/history_tab_helper.h
--- a/chrome/browser/history/history_tab_helper.h
+++ b/chrome/browser/history/history_tab_helper.h
@@ -15,6 +15,8 @@
 #include "components/translate/core/browser/translate_driver.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
 
 namespace history {
 struct HistoryAddPageArgs;
@@ -54,6 +56,11 @@ class HistoryTabHelper
   void SetAppId(const std::string& app_id) { app_id_ = app_id; }
 #endif
 
+  static void RegisterProfilePrefs(PrefRegistrySimple* registry);
+
+  // Helper function to return the history service.  May return null.
+  history::HistoryService* GetHistoryService();
+
  private:
   explicit HistoryTabHelper(content::WebContents* web_contents);
   friend class content::WebContentsUserData<HistoryTabHelper>;
@@ -89,9 +96,6 @@ class HistoryTabHelper
   void OnLanguageDetermined(
       const translate::LanguageDetectionDetails& details) override;
 
-  // Helper function to return the history service.  May return null.
-  history::HistoryService* GetHistoryService();
-
   // Returns true if our observed web contents is an eligible tab.
   bool IsEligibleTab(const history::HistoryAddPageArgs& add_page_args) const;
 
diff --git a/chrome/browser/offline_pages/android/offline_page_bridge.cc b/chrome/browser/offline_pages/android/offline_page_bridge.cc
--- a/chrome/browser/offline_pages/android/offline_page_bridge.cc
+++ b/chrome/browser/offline_pages/android/offline_page_bridge.cc
@@ -45,6 +45,9 @@
 #include "content/public/browser/web_contents.h"
 #include "net/base/filename_util.h"
 #include "url/android/gurl_android.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
+#include "chrome/common/pref_names.h"
 
 // Must come after all headers that specialize FromJniType() / ToJniType().
 #include "chrome/android/chrome_jni_headers/OfflinePageBridge_jni.h"
@@ -758,9 +761,15 @@ void OfflinePageBridge::GetPageByOfflineIdDone(
   }
 
   if (offline_page_model_->IsArchiveInInternalDir(offline_page->file_path)) {
+    bool is_trusted = true;
+    // in always incognito, never trust input file (show file name in url)
+    ProfileKey* profile_key = ProfileKey::FromSimpleFactoryKey(key_);
+    if (profile_key->GetPrefs()->GetBoolean(prefs::kIncognitoTabHistoryEnabled))
+      is_trusted = false;
+
     ValidateFileCallback(launch_location, j_callback_obj,
                          offline_page->offline_id, offline_page->url,
-                         offline_page->file_path, true /* is_trusted*/);
+                         offline_page->file_path, is_trusted);
     return;
   }
 
diff --git a/chrome/browser/offline_pages/android/offline_page_model_factory.cc b/chrome/browser/offline_pages/android/offline_page_model_factory.cc
--- a/chrome/browser/offline_pages/android/offline_page_model_factory.cc
+++ b/chrome/browser/offline_pages/android/offline_page_model_factory.cc
@@ -24,6 +24,9 @@
 #include "components/keyed_service/core/simple_dependency_manager.h"
 #include "components/offline_pages/core/model/offline_page_model_taskified.h"
 #include "components/offline_pages/core/offline_page_metadata_store.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
+#include "chrome/common/pref_names.h"
 
 namespace offline_pages {
 
@@ -55,13 +58,15 @@ std::unique_ptr<KeyedService> OfflinePageModelFactory::BuildServiceInstanceFor(
   scoped_refptr<base::SequencedTaskRunner> background_task_runner =
       base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()});
 
+  ProfileKey* profile_key = ProfileKey::FromSimpleFactoryKey(key)->GetOriginalKey();
+
   base::FilePath store_path =
-      key->GetPath().Append(chrome::kOfflinePageMetadataDirname);
+      profile_key->GetPath().Append(chrome::kOfflinePageMetadataDirname);
   std::unique_ptr<OfflinePageMetadataStore> metadata_store(
       new OfflinePageMetadataStore(background_task_runner, store_path));
 
   base::FilePath persistent_archives_dir =
-      key->GetPath().Append(chrome::kOfflinePageArchivesDirname);
+      profile_key->GetPath().Append(chrome::kOfflinePageArchivesDirname);
   // If base::PathService::Get returns false, the temporary_archives_dir will be
   // empty, and no temporary pages will be saved during this chrome lifecycle.
   base::FilePath temporary_archives_dir;
@@ -70,7 +75,6 @@ std::unique_ptr<KeyedService> OfflinePageModelFactory::BuildServiceInstanceFor(
         temporary_archives_dir.Append(chrome::kOfflinePageArchivesDirname);
   }
 
-  ProfileKey* profile_key = ProfileKey::FromSimpleFactoryKey(key);
   auto archive_manager = std::make_unique<DownloadArchiveManager>(
       temporary_archives_dir, persistent_archives_dir,
       DownloadPrefs::GetDefaultDownloadDirectory(), background_task_runner,
@@ -88,4 +92,14 @@ std::unique_ptr<KeyedService> OfflinePageModelFactory::BuildServiceInstanceFor(
   return model;
 }
 
+SimpleFactoryKey* OfflinePageModelFactory::GetKeyToUse(
+    SimpleFactoryKey* key) const {
+  ProfileKey* profile_key = ProfileKey::FromSimpleFactoryKey(key);
+  if (profile_key->GetPrefs()->GetBoolean(prefs::kIncognitoTabHistoryEnabled) == false) {
+    return SimpleKeyedServiceFactory::GetKeyToUse(key);
+  }
+
+  return profile_key->GetOriginalKey();
+}
+
 }  // namespace offline_pages
diff --git a/chrome/browser/offline_pages/android/request_coordinator_factory.cc b/chrome/browser/offline_pages/android/request_coordinator_factory.cc
--- a/chrome/browser/offline_pages/android/request_coordinator_factory.cc
+++ b/chrome/browser/offline_pages/android/request_coordinator_factory.cc
@@ -19,6 +19,7 @@
 #include "chrome/browser/ui/android/tab_model/tab_model.h"
 #include "chrome/browser/ui/android/tab_model/tab_model_list.h"
 #include "chrome/common/chrome_constants.h"
+#include "components/keyed_service/content/browser_context_dependency_manager.h"
 #include "components/offline_pages/core/background/offliner.h"
 #include "components/offline_pages/core/background/offliner_policy.h"
 #include "components/offline_pages/core/background/request_coordinator.h"
@@ -28,6 +29,11 @@
 #include "components/offline_pages/core/offline_page_feature.h"
 #include "content/public/browser/web_contents.h"
 
+#include "chrome/browser/profiles/incognito_helpers.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
+#include "chrome/common/pref_names.h"
+
 namespace network {
 class NetworkQualityTracker;
 }
@@ -65,14 +71,9 @@ class ActiveTabInfo : public RequestCoordinator::ActiveTabInfo {
 }  // namespace
 
 RequestCoordinatorFactory::RequestCoordinatorFactory()
-    : ProfileKeyedServiceFactory(
+    : BrowserContextKeyedServiceFactory(
           "OfflineRequestCoordinator",
-          ProfileSelections::Builder()
-              .WithRegular(ProfileSelection::kOriginalOnly)
-              // TODO(crbug.com/40257657): Check if this service is needed in
-              // Guest mode.
-              .WithGuest(ProfileSelection::kOriginalOnly)
-              .Build()) {
+          BrowserContextDependencyManager::GetInstance()) {
   // Depends on OfflinePageModelFactory in SimpleDependencyManager.
 }
 
@@ -92,6 +93,12 @@ RequestCoordinator* RequestCoordinatorFactory::GetForBrowserContext(
 std::unique_ptr<KeyedService>
 RequestCoordinatorFactory::BuildServiceInstanceForBrowserContext(
     content::BrowserContext* context) const {
+  if (context->IsOffTheRecord() &&
+      Profile::FromBrowserContext(context)->GetOriginalProfile()
+        ->GetPrefs()->GetBoolean(prefs::kIncognitoTabHistoryEnabled) == false) {
+    // do not track history in incognito mode if preference is disabled
+    return nullptr;
+  }
   std::unique_ptr<OfflinerPolicy> policy(new OfflinerPolicy());
   std::unique_ptr<Offliner> offliner;
   OfflinePageModel* model =
@@ -122,4 +129,16 @@ RequestCoordinatorFactory::BuildServiceInstanceForBrowserContext(
       std::make_unique<ActiveTabInfo>(profile));
 }
 
+content::BrowserContext*
+RequestCoordinatorFactory::GetBrowserContextToUse(
+    content::BrowserContext* context) const {
+  if (Profile::FromBrowserContext(context)->GetOriginalProfile()
+        ->GetPrefs()->GetBoolean(prefs::kIncognitoTabHistoryEnabled) == false) {
+    return BrowserContextKeyedServiceFactory::GetBrowserContextToUse(context);
+  }
+
+  return chrome::GetBrowserContextRedirectedInIncognito(context);
+}
+
+
 }  // namespace offline_pages
diff --git a/chrome/browser/offline_pages/offline_page_model_factory.h b/chrome/browser/offline_pages/offline_page_model_factory.h
--- a/chrome/browser/offline_pages/offline_page_model_factory.h
+++ b/chrome/browser/offline_pages/offline_page_model_factory.h
@@ -48,6 +48,7 @@ class OfflinePageModelFactory : public SimpleKeyedServiceFactory {
 
   std::unique_ptr<KeyedService> BuildServiceInstanceFor(
       SimpleFactoryKey* key) const override;
+  SimpleFactoryKey* GetKeyToUse(SimpleFactoryKey* key) const override;
 };
 
 }  // namespace offline_pages
diff --git a/chrome/browser/offline_pages/recent_tab_helper.cc b/chrome/browser/offline_pages/recent_tab_helper.cc
--- a/chrome/browser/offline_pages/recent_tab_helper.cc
+++ b/chrome/browser/offline_pages/recent_tab_helper.cc
@@ -28,6 +28,11 @@
 #include "content/public/browser/navigation_entry.h"
 #include "content/public/browser/navigation_handle.h"
 
+#include "chrome/browser/profiles/profile.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
+#include "chrome/common/pref_names.h"
+
 namespace {
 class DefaultRecentTabHelperDelegate
     : public offline_pages::RecentTabHelper::Delegate {
@@ -180,6 +185,14 @@ bool RecentTabHelper::EnsureInitialized() {
   // WebContents with its origin as well.
   snapshots_enabled_ = !tab_id_.empty() &&
                        !web_contents()->GetBrowserContext()->IsOffTheRecord();
+  if (!tab_id_.empty() && web_contents()->GetBrowserContext()->IsOffTheRecord()) {
+    if (Profile::FromBrowserContext(web_contents()->GetBrowserContext())
+          ->GetOriginalProfile()
+          ->GetPrefs()->GetBoolean(prefs::kIncognitoTabHistoryEnabled)) {
+      snapshots_enabled_ = true;
+      incognito_tab_history_enabled_ = true;
+    }
+  }
 
   if (snapshots_enabled_) {
     page_model_ = OfflinePageModelFactory::GetForBrowserContext(
@@ -339,7 +352,8 @@ void RecentTabHelper::WebContentsWasHidden() {
       GetRecentPagesClientId(),
       base::BindOnce(&RecentTabHelper::ContinueSnapshotWithIdsToPurge,
                      weak_ptr_factory_.GetWeakPtr(),
-                     last_n_ongoing_snapshot_info_.get()));
+                     last_n_ongoing_snapshot_info_.get(),
+                     /*user_requested*/ false));
 
   last_n_latest_saved_snapshot_info_.reset();
 }
@@ -403,11 +417,12 @@ void RecentTabHelper::SaveSnapshotForDownloads(bool replace_latest) {
         downloads_latest_saved_snapshot_info_->request_id,
         downloads_latest_saved_snapshot_info_->origin);
     std::vector<int64_t> ids{downloads_latest_saved_snapshot_info_->request_id};
-    ContinueSnapshotWithIdsToPurge(downloads_ongoing_snapshot_info_.get(), ids);
+    ContinueSnapshotWithIdsToPurge(downloads_ongoing_snapshot_info_.get(), /*user_requested*/ true, ids);
   } else {
     // Otherwise go straight to saving the page.
     DCHECK(downloads_ongoing_snapshot_info_);
     ContinueSnapshotAfterPurge(downloads_ongoing_snapshot_info_.get(),
+                               /*user_requested*/ true,
                                OfflinePageModel::DeletePageResult::SUCCESS);
   }
 }
@@ -424,6 +439,7 @@ void RecentTabHelper::SaveSnapshotForDownloads(bool replace_latest) {
 // for early termination in case of errors.
 void RecentTabHelper::ContinueSnapshotWithIdsToPurge(
     SnapshotProgressInfo* snapshot_info,
+    bool user_requested,
     const std::vector<int64_t>& page_ids) {
   DCHECK(snapshot_info);
 
@@ -433,13 +449,20 @@ void RecentTabHelper::ContinueSnapshotWithIdsToPurge(
   criteria.offline_ids = page_ids;
   page_model_->DeletePagesWithCriteria(
       criteria, base::BindOnce(&RecentTabHelper::ContinueSnapshotAfterPurge,
-                               weak_ptr_factory_.GetWeakPtr(), snapshot_info));
+                               weak_ptr_factory_.GetWeakPtr(), snapshot_info,
+                               user_requested));
 }
 
 void RecentTabHelper::ContinueSnapshotAfterPurge(
     SnapshotProgressInfo* snapshot_info,
+    bool user_requested,
     OfflinePageModel::DeletePageResult result) {
-  if (result != OfflinePageModel::DeletePageResult::SUCCESS) {
+  // remove snapshot save of recent tab if always incognito mode is active
+  // so recents tab list is empty at every startup
+  // the user can choose to disable the feature
+  if ((incognito_tab_history_enabled_ || !base::FeatureList::IsEnabled(offline_pages::kOfflinePagesAutoSaveFeature)
+         || result != OfflinePageModel::DeletePageResult::SUCCESS)
+       && !user_requested) {
     ReportSnapshotCompleted(snapshot_info, false);
     return;
   }
diff --git a/chrome/browser/offline_pages/recent_tab_helper.h b/chrome/browser/offline_pages/recent_tab_helper.h
--- a/chrome/browser/offline_pages/recent_tab_helper.h
+++ b/chrome/browser/offline_pages/recent_tab_helper.h
@@ -106,8 +106,10 @@ class RecentTabHelper
 
   bool EnsureInitialized();
   void ContinueSnapshotWithIdsToPurge(SnapshotProgressInfo* snapshot_info,
+                                      bool user_requested,
                                       const std::vector<int64_t>& page_ids);
   void ContinueSnapshotAfterPurge(SnapshotProgressInfo* snapshot_info,
+                                  bool user_requested,
                                   OfflinePageModel::DeletePageResult result);
   void SavePageCallback(SnapshotProgressInfo* snapshot_info,
                         OfflinePageModel::SavePageResult result,
@@ -129,6 +131,9 @@ class RecentTabHelper
   // Not page-specific.
   bool snapshots_enabled_ = false;
 
+  // If true, tab history in incognito mode is enabled
+  bool incognito_tab_history_enabled_ = false;
+
   // Snapshot progress information for an ongoing snapshot requested by
   // downloads. Null if there's no ongoing request.
   std::unique_ptr<SnapshotProgressInfo> downloads_ongoing_snapshot_info_;
diff --git a/chrome/browser/offline_pages/request_coordinator_factory.h b/chrome/browser/offline_pages/request_coordinator_factory.h
--- a/chrome/browser/offline_pages/request_coordinator_factory.h
+++ b/chrome/browser/offline_pages/request_coordinator_factory.h
@@ -18,7 +18,7 @@ namespace offline_pages {
 class RequestCoordinator;
 
 // A factory to create one unique RequestCoordinator.
-class RequestCoordinatorFactory : public ProfileKeyedServiceFactory {
+class RequestCoordinatorFactory : public BrowserContextKeyedServiceFactory {
  public:
   static RequestCoordinatorFactory* GetInstance();
   static RequestCoordinator* GetForBrowserContext(
@@ -36,6 +36,8 @@ class RequestCoordinatorFactory : public ProfileKeyedServiceFactory {
 
   std::unique_ptr<KeyedService> BuildServiceInstanceForBrowserContext(
       content::BrowserContext* context) const override;
+  content::BrowserContext* GetBrowserContextToUse(
+      content::BrowserContext* context) const override;
 };
 
 }  // namespace offline_pages
diff --git a/chrome/browser/prefs/browser_prefs.cc b/chrome/browser/prefs/browser_prefs.cc
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -251,6 +251,7 @@
 
 #if BUILDFLAG(IS_ANDROID)
 #include "chrome/browser/accessibility/accessibility_prefs/android/accessibility_prefs_controller.h"
+#include "chrome/browser/history/history_tab_helper.h"
 #include "chrome/browser/android/bookmarks/partner_bookmarks_shim.h"
 #include "chrome/browser/android/ntp/recent_tabs_page_prefs.h"
 #include "chrome/browser/android/oom_intervention/oom_intervention_decider.h"
@@ -2105,6 +2106,10 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry,
   usage_stats::UsageStatsBridge::RegisterProfilePrefs(registry);
   variations::VariationsService::RegisterProfilePrefs(registry);
   webapps::InstallPromptPrefs::RegisterProfilePrefs(registry);
+  // register incognito pref
+  registry->RegisterBooleanPref(prefs::kAlwaysIncognitoEnabled,
+                              /*default_value=*/false);
+  HistoryTabHelper::RegisterProfilePrefs(registry);
 #else  // BUILDFLAG(IS_ANDROID)
   bookmarks_webui::RegisterProfilePrefs(registry);
   browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
diff --git a/chrome/browser/profiles/profile_selections.cc b/chrome/browser/profiles/profile_selections.cc
--- a/chrome/browser/profiles/profile_selections.cc
+++ b/chrome/browser/profiles/profile_selections.cc
@@ -5,6 +5,9 @@
 #include "chrome/browser/profiles/profile_selections.h"
 
 #include "base/memory/ptr_util.h"
+#include "components/prefs/pref_registry_simple.h"
+#include "components/prefs/pref_service.h"
+#include "chrome/common/pref_names.h"
 #include "chrome/browser/profiles/profile.h"
 #include "components/profile_metrics/browser_profile_type.h"
 
@@ -112,6 +115,13 @@ Profile* ProfileSelections::ApplyProfileSelection(Profile* profile) const {
       return nullptr;
     case ProfileSelection::kOriginalOnly:
       return profile->IsOffTheRecord() ? nullptr : profile;
+#if BUILDFLAG(IS_ANDROID)
+    case ProfileSelection::kOriginalOnlyAndAlwaysIncognito:
+      return profile->IsOffTheRecord() &&
+             !(profile->GetOriginalProfile()
+              ->GetPrefs()
+              ->GetBoolean(prefs::kAlwaysIncognitoEnabled)) ? nullptr : profile;
+#endif
     case ProfileSelection::kOwnInstance:
       return profile;
     case ProfileSelection::kRedirectedToOriginal:
diff --git a/chrome/browser/profiles/profile_selections.h b/chrome/browser/profiles/profile_selections.h
--- a/chrome/browser/profiles/profile_selections.h
+++ b/chrome/browser/profiles/profile_selections.h
@@ -6,7 +6,7 @@
 #define CHROME_BROWSER_PROFILES_PROFILE_SELECTIONS_H_
 
 #include <memory>
-
+#include "build/build_config.h"
 class Profile;
 
 // A helper function that checks whether Keyed Services should be created for
@@ -25,6 +25,11 @@ bool AreKeyedServicesDisabledForProfileByDefault(const Profile* profile);
 enum class ProfileSelection {
   kNone,                  // Original: No Profile  --  OTR: No Profile
   kOriginalOnly,          // Original: Self        --  OTR: No Profile
+#if BUILDFLAG(IS_ANDROID)
+  kOriginalOnlyAndAlwaysIncognito,
+                          // Original: Self        --  OTR: Self (with AlwaysIncognito ON)
+                          //                       --  OTR: No Profile (with AlwaysIncognito OFF)
+#endif
   kOwnInstance,           // Original: Self        --  OTR: Self
   kRedirectedToOriginal,  // Original: Self        --  OTR: Original
   kOffTheRecordOnly       // Original: No Profile  --  OTR: Self
diff --git a/chrome/browser/ui/android/native_page/BUILD.gn b/chrome/browser/ui/android/native_page/BUILD.gn
--- a/chrome/browser/ui/android/native_page/BUILD.gn
+++ b/chrome/browser/ui/android/native_page/BUILD.gn
@@ -30,6 +30,8 @@ robolectric_library("junit") {
 
   deps = [
     ":java",
+    "//base:base_java",
+    "//components/embedder_support/android:util_java",
     "//base:base_junit_test_support",
     "//third_party/android_deps:org_mockito_mockito_core_java",
     "//third_party/junit",
diff --git a/chrome/browser/ui/android/native_page/java/src/org/chromium/chrome/browser/ui/native_page/NativePage.java b/chrome/browser/ui/android/native_page/java/src/org/chromium/chrome/browser/ui/native_page/NativePage.java
--- a/chrome/browser/ui/android/native_page/java/src/org/chromium/chrome/browser/ui/native_page/NativePage.java
+++ b/chrome/browser/ui/android/native_page/java/src/org/chromium/chrome/browser/ui/native_page/NativePage.java
@@ -15,6 +15,8 @@ import org.chromium.url.GURL;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
+import org.chromium.base.ContextUtils;
+
 /** An interface for pages that will be using Android views instead of html/rendered Web content. */
 public interface NativePage {
 
@@ -176,7 +178,8 @@ public interface NativePage {
      */
     static boolean isNativePageUrl(GURL url, boolean isIncognito, boolean hasPdfDownload) {
         return url != null
-                && nativePageType(url, null, isIncognito, hasPdfDownload) != NativePageType.NONE;
+                && nativePageType(url, null, isIncognito, hasPdfDownload, /*isAlwaysIncognito*/ false)
+                        != NativePageType.NONE;
     }
 
     /**
@@ -186,7 +189,7 @@ public interface NativePage {
      *     not have chrome or chrome-native scheme.
      */
     static boolean isChromePageUrl(GURL url, boolean isIncognito) {
-        return url != null && chromePageType(url, null, isIncognito) != NativePageType.NONE;
+        return url != null && chromePageType(url, null, isIncognito, /*isAlwaysIncognito*/false) != NativePageType.NONE;
     }
 
     /**
@@ -198,11 +201,12 @@ public interface NativePage {
      */
     // TODO(crbug.com/40549331) - Convert to using GURL.
     static @NativePageType int nativePageType(
-            String url, NativePage candidatePage, boolean isIncognito, boolean hasPdfDownload) {
+            String url, NativePage candidatePage, boolean isIncognito, boolean hasPdfDownload,
+            boolean isAlwaysIncognito) {
         if (url == null) return NativePageType.NONE;
 
         GURL gurl = new GURL(url);
-        return nativePageType(gurl, candidatePage, isIncognito, hasPdfDownload);
+        return nativePageType(gurl, candidatePage, isIncognito, hasPdfDownload, isAlwaysIncognito);
     }
 
     /**
@@ -213,7 +217,8 @@ public interface NativePage {
      * @return Type of the native page defined in {@link NativePageType}.
      */
     private static @NativePageType int nativePageType(
-            GURL url, NativePage candidatePage, boolean isIncognito, boolean hasPdfDownload) {
+            GURL url, NativePage candidatePage, boolean isIncognito, boolean hasPdfDownload,
+            boolean isAlwaysIncognito) {
         if (hasPdfDownload) {
             // For navigation with associated pdf download (e.g. open a pdf link), pdf page should
             // be created.
@@ -231,7 +236,7 @@ public interface NativePage {
             // created after the pdf document is re-downloaded in other parts of the code.
             return NativePageType.NONE;
         } else {
-            return chromePageType(url, candidatePage, isIncognito);
+            return chromePageType(url, candidatePage, isIncognito, isAlwaysIncognito);
         }
     }
 
@@ -243,7 +248,7 @@ public interface NativePage {
      *     which do not have chrome or chrome-native scheme.
      */
     private static @NativePageType int chromePageType(
-            GURL url, NativePage candidatePage, boolean isIncognito) {
+            GURL url, NativePage candidatePage, boolean isIncognito, boolean isAlwaysIncognito) {
         String host = url.getHost();
         String scheme = url.getScheme();
         if (!UrlConstants.CHROME_NATIVE_SCHEME.equals(scheme)
@@ -263,7 +268,8 @@ public interface NativePage {
             return NativePageType.DOWNLOADS;
         } else if (UrlConstants.HISTORY_HOST.equals(host)) {
             return NativePageType.HISTORY;
-        } else if (UrlConstants.RECENT_TABS_HOST.equals(host) && !isIncognito) {
+        } else if (UrlConstants.RECENT_TABS_HOST.equals(host) &&
+                  (!isIncognito || isAlwaysIncognito)) {
             return NativePageType.RECENT_TABS;
         } else if (UrlConstants.EXPLORE_HOST.equals(host)) {
             return NativePageType.EXPLORE;
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings.grd b/chrome/browser/ui/android/strings/android_chrome_strings.grd
--- a/chrome/browser/ui/android/strings/android_chrome_strings.grd
+++ b/chrome/browser/ui/android/strings/android_chrome_strings.grd
@@ -1419,6 +1419,31 @@ Your Google account may have other forms of browsing history like searches and a
       <message name="IDS_CLEAR_BROWSING_HISTORY_SUMMARY_SYNCED_NO_LINK" desc="A text for the basic tab explaining browsing history for users with history sync. This version is shown when the link to MyActivity is displayed separately.">
         Deletes history from all synced devices
       </message>
+      <!-- always incognito -->
+      <message name="IDS_INCOGNITO_SETTINGS_TITLE" desc="Title for incognito mode settings">
+        Always incognito mode
+      </message>
+      <message name="IDS_INCOGNITO_SETTINGS_SUMMARY" desc="Summary for incognito mode settings">
+        Incognito navigation settings
+      </message>
+      <message name="IDS_ALWAYS_INCOGNITO_TITLE" desc="Title for always incognito mode">
+        Always open links in incognito
+      </message>
+      <message name="IDS_ALWAYS_INCOGNITO_SUMMARY" desc="Summary for always incognito mode">
+        Opens links in incognito tabs when you click on new tab or on a link
+      </message>
+      <message name="IDS_INCOGNITO_HISTORY_ENABLED_TITLE" desc="Title for enabled history in incognito mode">
+        Enable history
+      </message>
+      <message name="IDS_INCOGNITO_HISTORY_ENABLED_SUMMARY" desc="Summary for enable history in incognito mode">
+        Record history even in incognito mode
+      </message>
+      <message name="IDS_INCOGNITO_SAVE_SITE_SETTING_ENABLED_TITLE" desc="Title for save site setting flag in incognito mode">
+        Remember site settings
+      </message>
+      <message name="IDS_INCOGNITO_SAVE_SITE_SETTING_ENABLED_SUMMARY" desc="Summary for save site setting flag in incognito mode">
+        Remember site settings changes in incognito mode
+      </message>
       <message name="IDS_CLEAR_SEARCH_HISTORY_LINK" desc="Text informing the user that they can clear search history and other data using MyActivity.">
         <ph name="BEGIN_LINK1">&lt;link1&gt;</ph>Search history<ph name="END_LINK1">&lt;/link1&gt;</ph> and <ph name="BEGIN_LINK2">&lt;link2&gt;</ph>other forms of activity<ph name="END_LINK2">&lt;/link2&gt;</ph> may be saved in your Google Account when youre signed in. You can delete them anytime.
       </message>
diff --git a/chrome/browser/ui/android/toolbar/java/src/org/chromium/chrome/browser/toolbar/LocationBarModel.java b/chrome/browser/ui/android/toolbar/java/src/org/chromium/chrome/browser/toolbar/LocationBarModel.java
--- a/chrome/browser/ui/android/toolbar/java/src/org/chromium/chrome/browser/toolbar/LocationBarModel.java
+++ b/chrome/browser/ui/android/toolbar/java/src/org/chromium/chrome/browser/toolbar/LocationBarModel.java
@@ -162,6 +162,7 @@ public class LocationBarModel implements ToolbarDataProvider, LocationBarDataPro
     protected String mFormattedFullUrl;
     protected String mUrlForDisplay;
     private boolean mOmniboxUpdatedConnectionSecurityIndicatorsEnabled;
+    private boolean mIsAlwaysIncognito;
 
     // notifyUrlChanged and notifySecurityStateChanged are usually called 3 times across a same
     // document navigation. The first call is usually necessary, which updates the UrlBar to reflect
@@ -185,7 +186,9 @@ public class LocationBarModel implements ToolbarDataProvider, LocationBarDataPro
             Context context,
             NewTabPageDelegate newTabPageDelegate,
             @NonNull UrlFormatter urlFormatter,
-            @NonNull OfflineStatus offlineStatus) {
+            @NonNull OfflineStatus offlineStatus,
+            boolean isAlwaysIncognito) {
+        mIsAlwaysIncognito = isAlwaysIncognito; // (uazo) to do, check
         mContext = context;
         mNtpDelegate = newTabPageDelegate;
         mUrlFormatter = urlFormatter;
diff --git a/chrome/browser/ui/messages/android/BUILD.gn b/chrome/browser/ui/messages/android/BUILD.gn
--- a/chrome/browser/ui/messages/android/BUILD.gn
+++ b/chrome/browser/ui/messages/android/BUILD.gn
@@ -25,6 +25,7 @@ android_library("java") {
   srcjar_deps = [ ":jni_headers" ]
   sources = [
     "java/src/org/chromium/chrome/browser/ui/messages/infobar/SimpleConfirmInfoBarBuilder.java",
+    "java/src/org/chromium/chrome/browser/ui/messages/snackbar/INeedSnackbarManager.java",
     "java/src/org/chromium/chrome/browser/ui/messages/snackbar/Snackbar.java",
     "java/src/org/chromium/chrome/browser/ui/messages/snackbar/SnackbarCollection.java",
     "java/src/org/chromium/chrome/browser/ui/messages/snackbar/SnackbarManager.java",
diff --git a/chrome/browser/ui/messages/android/java/src/org/chromium/chrome/browser/ui/messages/snackbar/INeedSnackbarManager.java b/chrome/browser/ui/messages/android/java/src/org/chromium/chrome/browser/ui/messages/snackbar/INeedSnackbarManager.java
new file mode 100644
--- /dev/null
+++ b/chrome/browser/ui/messages/android/java/src/org/chromium/chrome/browser/ui/messages/snackbar/INeedSnackbarManager.java
@@ -0,0 +1,28 @@
+/*
+    This file is part of Bromite.
+
+    Bromite is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Bromite is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Bromite. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+package org.chromium.chrome.browser.ui.messages.snackbar;
+
+import org.chromium.base.supplier.Supplier;
+import org.chromium.chrome.browser.ui.messages.snackbar.SnackbarManager;
+
+/**
+ * An interface that allows using snackbars in the settings
+ */
+public interface INeedSnackbarManager {
+    void setSnackbarManagerSupplier(Supplier<SnackbarManager> manager);
+}
diff --git a/chrome/common/pref_names.h b/chrome/common/pref_names.h
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -4211,6 +4211,12 @@ inline constexpr char kOutOfProcessSystemDnsResolutionEnabled[] =
     "net.out_of_process_system_dns_resolution_enabled";
 #endif  // BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_LINUX)
 
+#if BUILDFLAG(IS_ANDROID)
+inline constexpr char kAlwaysIncognitoEnabled[] = "always_incognito_enabled";
+inline constexpr char kIncognitoSaveSiteSettingEnabled[] = "incognito_tab_history_enabled";
+inline constexpr char kIncognitoTabHistoryEnabled[] = "incognito_site_setting_enabled";
+#endif
+
 // A list of hostnames to disable HTTPS Upgrades / HTTPS-First Mode warnings on.
 inline constexpr char kHttpAllowlist[] = "https_upgrades.policy.http_allowlist";
 
diff --git a/components/content_settings/core/browser/content_settings_pref_provider.cc b/components/content_settings/core/browser/content_settings_pref_provider.cc
--- a/components/content_settings/core/browser/content_settings_pref_provider.cc
+++ b/components/content_settings/core/browser/content_settings_pref_provider.cc
@@ -114,10 +114,12 @@ void PrefProvider::RegisterProfilePrefs(
 
 PrefProvider::PrefProvider(PrefService* prefs,
                            bool off_the_record,
+                           bool force_save_site_settings,
                            bool store_last_modified,
                            bool restore_session)
     : prefs_(prefs),
       off_the_record_(off_the_record),
+      force_save_site_settings_(force_save_site_settings),
       store_last_modified_(store_last_modified),
       clock_(base::DefaultClock::GetInstance()) {
   TRACE_EVENT_BEGIN("startup", "PrefProvider::PrefProvider");
@@ -140,11 +142,13 @@ PrefProvider::PrefProvider(PrefService* prefs,
   WebsiteSettingsRegistry* website_settings =
       WebsiteSettingsRegistry::GetInstance();
   for (const WebsiteSettingsInfo* info : *website_settings) {
+    bool save_site_settings = force_save_site_settings_ &&
+      info->incognito_behavior() == WebsiteSettingsInfo::INHERIT_IN_INCOGNITO;
     content_settings_prefs_.insert(std::make_pair(
         info->type(),
         std::make_unique<ContentSettingsPref>(
             info->type(), prefs_, &pref_change_registrar_, info->pref_name(),
-            info->partitioned_pref_name(), off_the_record_, restore_session,
+            info->partitioned_pref_name(), off_the_record_ && !save_site_settings, restore_session,
             base::BindRepeating(&PrefProvider::Notify,
                                 base::Unretained(this)))));
   }
diff --git a/components/content_settings/core/browser/content_settings_pref_provider.h b/components/content_settings/core/browser/content_settings_pref_provider.h
--- a/components/content_settings/core/browser/content_settings_pref_provider.h
+++ b/components/content_settings/core/browser/content_settings_pref_provider.h
@@ -38,6 +38,7 @@ class PrefProvider : public UserModifiableProvider {
 
   PrefProvider(PrefService* prefs,
                bool off_the_record,
+               bool force_save_site_settings,
                bool store_last_modified,
                bool restore_session);
 
@@ -127,6 +128,7 @@ class PrefProvider : public UserModifiableProvider {
   raw_ptr<PrefService> prefs_;
 
   const bool off_the_record_;
+  const bool force_save_site_settings_;
 
   bool store_last_modified_;
 
diff --git a/components/content_settings/core/browser/host_content_settings_map.cc b/components/content_settings/core/browser/host_content_settings_map.cc
--- a/components/content_settings/core/browser/host_content_settings_map.cc
+++ b/components/content_settings/core/browser/host_content_settings_map.cc
@@ -263,6 +263,7 @@ struct ContentSettingEntry {
 
 HostContentSettingsMap::HostContentSettingsMap(PrefService* prefs,
                                                bool is_off_the_record,
+                                               bool force_save_site_settings,
                                                bool store_last_modified,
                                                bool restore_session,
                                                bool should_record_metrics)
@@ -272,6 +273,7 @@ HostContentSettingsMap::HostContentSettingsMap(PrefService* prefs,
 #endif
       prefs_(prefs),
       is_off_the_record_(is_off_the_record),
+      force_save_site_settings_(force_save_site_settings),
       store_last_modified_(store_last_modified),
       allow_invalid_secondary_pattern_for_testing_(false),
       clock_(base::DefaultClock::GetInstance()) {
@@ -285,7 +287,7 @@ HostContentSettingsMap::HostContentSettingsMap(PrefService* prefs,
   policy_provider->AddObserver(this);
 
   auto pref_provider_ptr = std::make_unique<content_settings::PrefProvider>(
-      prefs_, is_off_the_record_, store_last_modified_, restore_session);
+      prefs_, is_off_the_record_, force_save_site_settings_, store_last_modified_, restore_session);
   pref_provider_ = pref_provider_ptr.get();
   content_settings_providers_[ProviderType::kPrefProvider] =
       std::move(pref_provider_ptr);
diff --git a/components/content_settings/core/browser/host_content_settings_map.h b/components/content_settings/core/browser/host_content_settings_map.h
--- a/components/content_settings/core/browser/host_content_settings_map.h
+++ b/components/content_settings/core/browser/host_content_settings_map.h
@@ -83,6 +83,7 @@ class HostContentSettingsMap : public content_settings::Observer,
   // profile or a guest session.
   HostContentSettingsMap(PrefService* prefs,
                          bool is_off_the_record,
+                         bool force_save_site_settings,
                          bool store_last_modified,
                          bool restore_session,
                          bool should_record_metrics);
@@ -510,6 +511,8 @@ class HostContentSettingsMap : public content_settings::Observer,
   // Whether this settings map is for an incognito or guest session.
   bool is_off_the_record_;
 
+  bool force_save_site_settings_ = false;
+
   // Whether ContentSettings in the PrefProvider will store a last_modified
   // timestamp.
   bool store_last_modified_;
diff --git a/components/omnibox/browser/autocomplete_provider_client.cc b/components/omnibox/browser/autocomplete_provider_client.cc
--- a/components/omnibox/browser/autocomplete_provider_client.cc
+++ b/components/omnibox/browser/autocomplete_provider_client.cc
@@ -46,3 +46,7 @@ base::WeakPtr<AutocompleteProviderClient>
 AutocompleteProviderClient::GetWeakPtr() {
   return nullptr;
 }
+
+bool AutocompleteProviderClient::IsAlwaysIncognitoEnabled() const {
+  return false;
+}
diff --git a/components/omnibox/browser/autocomplete_provider_client.h b/components/omnibox/browser/autocomplete_provider_client.h
--- a/components/omnibox/browser/autocomplete_provider_client.h
+++ b/components/omnibox/browser/autocomplete_provider_client.h
@@ -137,6 +137,7 @@ class AutocompleteProviderClient : public OmniboxAction::Client {
   virtual bool IsOffTheRecord() const = 0;
   virtual bool IsIncognitoProfile() const = 0;
   virtual bool IsGuestSession() const = 0;
+  virtual bool IsAlwaysIncognitoEnabled() const = 0;
 
   virtual bool SearchSuggestEnabled() const = 0;
 
diff --git a/components/omnibox/browser/base_search_provider.cc b/components/omnibox/browser/base_search_provider.cc
--- a/components/omnibox/browser/base_search_provider.cc
+++ b/components/omnibox/browser/base_search_provider.cc
@@ -386,7 +386,7 @@ bool BaseSearchProvider::CanSendSuggestRequestWithoutPageURL(
   }
 
   // Don't make a suggest request if in incognito mode.
-  if (client->IsOffTheRecord()) {
+  if (client->IsOffTheRecord() && client->IsAlwaysIncognitoEnabled() == false) {
     return false;
   }
 
diff --git a/components/omnibox/browser/search_provider.cc b/components/omnibox/browser/search_provider.cc
--- a/components/omnibox/browser/search_provider.cc
+++ b/components/omnibox/browser/search_provider.cc
@@ -778,7 +778,9 @@ bool SearchProvider::IsQuerySuitableForSuggest(bool* query_is_private) const {
   // keyword input to a keyword suggest server, if any.)
   const TemplateURL* default_url = providers_.GetDefaultProviderURL();
   const TemplateURL* keyword_url = providers_.GetKeywordProviderURL();
-  return !client()->IsOffTheRecord() && client()->SearchSuggestEnabled() &&
+  return (client()->IsOffTheRecord() == false ||
+                client()->IsAlwaysIncognitoEnabled() == true) &&
+         client()->SearchSuggestEnabled() &&
          ((default_url && !default_url->suggestions_url().empty() &&
            !*query_is_private) ||
           (keyword_url && !keyword_url->suggestions_url().empty()));
diff --git a/cromite_flags/chrome/browser/about_flags_cc/add-an-always-incognito-mode.inc b/cromite_flags/chrome/browser/about_flags_cc/add-an-always-incognito-mode.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/chrome/browser/about_flags_cc/add-an-always-incognito-mode.inc
@@ -0,0 +1,13 @@
+#ifdef FLAG_SECTION
+
+#if BUILDFLAG(IS_ANDROID)
+
+    {"offline-pages-auto-save",
+     "Enables autosave of offline page",
+     "Enables autosave of offline page, as automatic switching in case "
+     "the device goes offline.", kOsAndroid,
+     FEATURE_VALUE_TYPE(offline_pages::kOfflinePagesAutoSaveFeature)},
+
+#endif
+
+#endif
diff --git a/cromite_flags/chrome/browser/flags/android/chrome_feature_list_cc/add-an-always-incognito-mode.inc b/cromite_flags/chrome/browser/flags/android/chrome_feature_list_cc/add-an-always-incognito-mode.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/chrome/browser/flags/android/chrome_feature_list_cc/add-an-always-incognito-mode.inc
@@ -0,0 +1 @@
+SET_CROMITE_FEATURE_ENABLED(kCCTIncognitoAvailableToThirdParty);
diff --git a/cromite_flags/components/offline_pages/core/offline_page_feature_cc/add-an-always-incognito-mode.inc b/cromite_flags/components/offline_pages/core/offline_page_feature_cc/add-an-always-incognito-mode.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/components/offline_pages/core/offline_page_feature_cc/add-an-always-incognito-mode.inc
@@ -0,0 +1,3 @@
+CROMITE_FEATURE(kOfflinePagesAutoSaveFeature,
+                "OfflinePagesAutoSaveEnabled",
+                base::FEATURE_DISABLED_BY_DEFAULT);
diff --git a/cromite_flags/components/offline_pages/core/offline_page_feature_h/add-an-always-incognito-mode.inc b/cromite_flags/components/offline_pages/core/offline_page_feature_h/add-an-always-incognito-mode.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/components/offline_pages/core/offline_page_feature_h/add-an-always-incognito-mode.inc
@@ -0,0 +1 @@
+BASE_DECLARE_FEATURE(kOfflinePagesAutoSaveFeature);
-- 

